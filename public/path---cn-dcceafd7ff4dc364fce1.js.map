{"version":3,"sources":["webpack:///path---cn-dcceafd7ff4dc364fce1.js","webpack:///./.cache/json/cn.json"],"names":["webpackJsonp","493","module","exports","data","allMarkdownRemark","edges","node","id","excerpt","html","frontmatter","path","doc_title","author","date","language","label","keywords","group","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,QAAUC,MAAQC,GAAA,0HAAAC,QAAA,yGAAAC,KAAA,2KAAAC,aAAmbC,KAAA,oBAAAC,UAAA,KAAAC,OAAA,KAAAC,KAAA,KAAAC,SAAA,KAAAC,MAAA,UAAAC,SAAA,UAAAC,MAAA,SAA8IZ,MAAQC,GAAA,mHAAAC,QAAA,+IAAAC,KAAA,g7EAAAC,aAAutFC,KAAA,kBAAAC,UAAA,KAAAC,OAAA,KAAAC,KAAA,KAAAC,SAAA,KAAAC,MAAA,UAAAC,SAAA,QAAAC,MAAA,SAA0IZ,MAAQC,GAAA,2HAAAC,QAAA,6GAAAC,KAAA,o+GAAAC,aAAuwHC,KAAA,oBAAAC,UAAA,KAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,WAAgJZ,MAAQC,GAAA,kIAAAC,QAAA,qHAAAC,KAAA,85BAAAC,aAAssCC,KAAA,mBAAAC,UAAA,KAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,WAA+IZ,MAAQC,GAAA,+HAAAC,QAAA,IAAAC,KAAA,40OAAk6JC,aAA8nFC,KAAA,gBAAAC,UAAA,OAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,WAA8IZ,MAAQC,GAAA,sIAAAC,QAAA,iBAAAC,KAAA,6JAA+TC,aAA4BC,KAAA,wBAAAC,UAAA,QAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,WAAuJZ,MAAQC,GAAA,8HAAAC,QAAA,uCAAAC,KAAA,2nJAAAC,aAAm6JC,KAAA,eAAAC,UAAA,MAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,WAA4IZ,MAAQC,GAAA,4IAAAC,QAAA,kIAAAC,KAAA,+tIAAohEC,aAAsgFC,KAAA,8BAAAC,UAAA,cAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAsKZ,MAAQC,GAAA,yIAAAC,QAAA,IAAAC,KAAA,kmGAAAC,aAAoyGC,KAAA,2BAAAC,UAAA,WAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAgKZ,MAAQC,GAAA,uIAAAC,QAAA,kIAAAC,KAAA;AAA6iFC,aAAo7BC,KAAA,yBAAAC,UAAA,KAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAwJZ,MAAQC,GAAA,+IAAAC,QAAA,qIAAAC,KAAA,+yBAAAC,aAA8mCC,KAAA,iCAAAC,UAAA,QAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAmKZ,MAAQC,GAAA,0IAAAC,QAAA,+IAAAC,KAAA,0yLAAAC,aAAonMC,KAAA,4BAAAC,UAAA,KAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAA2JZ,MAAQC,GAAA,sIAAAC,QAAA,2IAAAC,KAAA,+8LAAAC,aAAixMC,KAAA,gCAAAC,UAAA,OAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAiKZ,MAAQC,GAAA,8IAAAC,QAAA,IAAAC,KAAA,6iDAA01BC,aAAk5BC,KAAA,gCAAAC,UAAA,OAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAiKZ,MAAQC,GAAA,sIAAAC,QAAA,uEAAAC,KAAA,qgCAAAC,aAA2vCC,KAAA,wBAAAC,UAAA,KAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAuJZ,MAAQC,GAAA,6IAAAC,QAAA,0IAAAC,KAAA,m5CAA0hCC,aAAmsBC,KAAA,+BAAAC,UAAA,OAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAgKZ,MAAQC,GAAA,sIAAAC,QAAA,qHAAAC,KAAA,iwCAAAC,aAAuiDC,KAAA,wBAAAC,UAAA,MAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAwJZ,MAAQC,GAAA,mJAAAC,QAAA,mIAAAC,KAAA,4vTAA80UC,aAAyCC,KAAA,qCAAAC,UAAA,SAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,cAAwKZ,MAAQC,GAAA,sIAAAC,QAAA,IAAAC,KAAA;AAAAC,aAAsiBC,KAAA,wBAAAC,UAAA,QAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,eAA2JZ,MAAQC,GAAA,wIAAAC,QAAA,iEAAAC,KAAA,uyDAAAC,aAAyhEC,KAAA,0BAAAC,UAAA,OAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,eAA4JZ,MAAQC,GAAA,qIAAAC,QAAA,wIAAAC,KAAA,gQAAAC,aAAojBC,KAAA,uBAAAC,UAAA,OAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,eAAyJZ,MAAQC,GAAA,wIAAAC,QAAA,4IAAAC,KAAA,0iJAAAC,aAAq5JC,KAAA,0BAAAC,UAAA,aAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAAmKZ,MAAQC,GAAA,wIAAAC,QAAA,+IAAAC,KAAA,ggGAAugGC,aAAmVC,KAAA,0BAAAC,UAAA,aAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAAmKZ,MAAQC,GAAA,gJAAAC,QAAA,kHAAAC,KAAA,+kFAAAC,aAAg5FC,KAAA,kCAAAC,UAAA,iBAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAA+KZ,MAAQC,GAAA,0IAAAC,QAAA,IAAAC,KAAA,orIAAAC,aAAm4IC,KAAA,4BAAAC,UAAA,WAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAAmKZ,MAAQC,GAAA,8IAAAC,QAAA,+FAAAC,KAAA,0+DAAgtCC,aAAwjCC,KAAA,gCAAAC,UAAA,cAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAA0KZ,MAAQC,GAAA,0IAAAC,QAAA,8IAAAC,KAAA,iqJAAAC,aAA89JC,KAAA,4BAAAC,UAAA,QAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAAgKZ,MAAQC,GAAA,+IAAAC,QAAA,IAAAC,KAAA,23EAAw1DC,aAA2yBC,KAAA,iCAAAC,UAAA,cAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAA2KZ,MAAQC,GAAA,uIAAAC,QAAA,gFAAAC,KAAA;AAAAC,aAA8wSC,KAAA,yBAAAC,UAAA,aAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAAkKZ,MAAQC,GAAA,sIAAAC,QAAA,mIAAAC,KAAA,mvUAAAC,aAAipVC,KAAA,wBAAAC,UAAA,YAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAAgKZ,MAAQC,GAAA,oIAAAC,QAAA,yIAAAC,KAAA,yoRAAAC,aAAiiSC,KAAA,sBAAAC,UAAA,eAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,gBAAiKZ,MAAQC,GAAA,2IAAAC,QAAA,8IAAAC,KAAA;AAAAC,aAA8osCC,KAAA,6BAAAC,UAAA,eAAAC,OAAA,KAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,OAAAC,SAAA,KAAAC,MAAA,kBAAyKC","file":"path---cn-dcceafd7ff4dc364fce1.js","sourcesContent":["webpackJsonp([29311135075861],{\n\n/***/ 493:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/content/welcome-text.en.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读论文和实现的差异，然后再阅读协议和实现的文档。 本文档目标读者是 IOHK…\",\"html\":\"<p>亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读论文和实现的差异，然后再阅读协议和实现的文档。</p>\\n<p>本文档目标读者是 IOHK 的开发人员，第三方软件开发人员，审计和致力于实现卡尔达诺结算层或使用卡尔达诺结算层参考实现的咨询人员。</p>\",\"frontmatter\":{\"path\":\"/cn/welcome-text/\",\"doc_title\":null,\"author\":null,\"date\":null,\"language\":\"cn\",\"label\":\"content\",\"keywords\":\"welcome\",\"group\":null}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/en/content/intro.en.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Cardano SL (或卡尔达诺运算层）是由 IOHK 联合爱丁堡大学，雅典大学和康涅狄格大学共同设计开发的一种加密货币。卡尔达诺运算层是基于 Aggelos Kiayias，Alexander Russell，Bernardo David 和 Roman Oliynykov…\",\"html\":\"<h3>Cardano SL</h3>\\n<p>(或卡尔达诺运算层）是由 IOHK 联合爱丁堡大学，雅典大学和康涅狄格大学共同设计开发的一种加密货币。卡尔达诺运算层是基于 Aggelos Kiayias，Alexander Russell，Bernardo David 和 Roman Oliynykov 的白皮书 『乌洛波罗斯：可证明安全的权益证明协议』的 Haskell 实现。</p>\\n<p>您可以将卡尔达诺结算层视为基于比特币重新设计的针对比特币缺陷的自由修复。 有关卡尔达诺结算层和比特币之间的相似之处和差异的更多信息，请阅读『卡尔达诺结算层为什么特别?』。</p>\\n<h3>加密货币基础</h3>\\n<p>在给出加密货币的定义之前，我们先来谈谈为什么我们在意数字货币，特别是加密货币。</p>\\n<h3>我们为什么在意?</h3>\\n<ul>\\n<li>\\n<h4>速度</h4>\\n<p>与传统（也称为法定）中心银行货币，与日元或美元相反，电子货币不需要一个银行系统来转移价值。这一限制的解除，使用数字货币的速度要快于银行业务，尤其是在全球范围内。使用数字货币从大阪转移10美元到丹佛不再需要数天的时间。无论距离如何，所有交易都能迅速完成。</p>\\n</li>\\n<li>\\n<h4>你掌控你自己的钱</h4>\\n<p>所有的商业银行账户所有者在收到支付请求后在合理的时间内只能支付一定的金额。银行体系对任何价值量都有限制，使个人无法迅速撤出或转移大量资金。有加密货币的情况下，持有一种称为密钥这一特殊信息的人就可以随意花钱。没有其他实体有权操纵用户拥有的价值。</p>\\n</li>\\n<li>\\n<h4>匿名</h4>\\n<p>人们可以根据需要，拥有任意多的加密货币地址，从不同的地址接收，消费资产。经营电子商务商店的商家可以拥有一组收款和退款的地址，以及一个用于他们自身需要的单独的个人『钱包』。通过统一的接口控制所有这些钱包，并且不需要登录到多个支付平台，这使得该过程非常节省时间。</p>\\n</li>\\n<li>\\n<h4>安全</h4>\\n<p>你的钱就像可用于消费的密钥一样安全。这意味着将密钥存储在保险箱中的 USB 闪存上相当于让纸币处于安全状态。即使进行了成功的网络攻击，也绝对没有人能够窃取这笔钱。</p>\\n</li>\\n<li>\\n<h4>扩展性</h4>\\n<p>使用一种称为侧链的方法，以及通用加密货币，如卡尔达诺结算层和比特币，就可以启用特定领域的加密货币，例如以太经典。这样一来，通过特定领域的加密货币开发的任何创新产品都可以让参与者在通用的加密货币中保持价值。这样的应用程序的例子有身份管理，游戏和赌博，以及可验证计算。</p>\\n</li>\\n</ul>\\n<h3>什么是加密货币?</h3>\\n<p>加密货币是一种数字货币形式，使用密码来控制价值。密码学提供了一种生成任何类型信息的真实真实性证据的方法。这就是所谓的数字签名。在加密货币中，我们通过签署和发送交易到网络并接收已确认的交易块，生成一个总账（一个提供每个地址有多少钱的信息的数据库）。加密货币通常是分散的，这意味着来自全球各地的许多人通过运行加密货币节点参与总账的生成。因此，必须达成关于总账状况的共识。下一节讨论实现这种共识的两个最重要的方法。</p>\\n<h3>卡尔达诺结算层为什么特别</h3>\\n<p>虽然比特币和卡尔达诺结算层之间有相似之处，但这两个加密货币之间也有很多不同之处。最显着的区别是，比特币是工作量证明类型的加密货币，而卡尔达诺结算层使用权益证明的方法达成共识。这鼓励诚信和长期的参与。</p>\\n<h3>共识算法的目的</h3>\\n<p>共识算法被用来产生新的交易区块，使账本更新状态。每当有人发布一个交易区块时，他们（或者说他们的运行加密货币协议的节点）就必须附上他们已经证明的证据。下面讨论两种类型的证明。</p>\\n<h3>工作量证明和挖矿</h3>\\n<p>工作量证明是加密货币最普遍的共识算法类型。它起源于比特币，加密货币就是这么工作的。为了生成工作证明，计算机必须解决一个挑战。这是难以解决的计算繁重的问题，但解决方案很容易验证。当一台基于网络的工作量证明的计算机找到一个解决方案时，它会将交易发布于同它一起计算的其他计算机。这台计算机会因为产生区块得到交易费和奖励。整个过程被称为挖矿。挖矿是非常耗能的，所需的能源数量在不断增加，这可能导致不健康的竞争。</p>\\n<h3>权益证明和铸币</h3>\\n<p>权益证明是一种生成区块的新方法。由 Aggelos Kiayias 教授领导的 IOHK 科学家们设计了第一个可证明的，称为乌洛波罗斯的权益证明算法。乌洛波罗斯是卡尔达诺结算层的核心。研究小组已经发表了一篇白皮书 ，这封白皮书对于那些拥有加密货币理论背景的人来说是值得一读的。权益证明的核心思想是，不要浪费电力来解决计算繁重的问题，而是选择一个节点来铸造一个新的区块，其概率与这个节点的硬币数量成正相关。如果一个节点有整数个(> 0)的 slot，它被称为 slot 所有人。如果一个节点最终被选中来铸造一个区块，那么这个节点被称为 slot 领导者。您可以在卡尔达诺结算层的股权证明中了解更多关于该流程的信息。</p>\\n<h3>卡尔达诺结算层之上</h3>\\n<p>卡尔达诺结算层被称为『层』是有原因的。这是卡尔达诺平台的第一个组件。最终，它将被扩展到一个控制层，作为一个可信的计算框架来评估一种特殊的证明，以确保一定的计算正确执行。在游戏和赌博中，这样的系统被用于验证随机数生成和游戏结果的真实性。伴随着侧链，它将有可能完成诸如在游戏中公平分配奖金的任务。但是控制层的应用远远超出了游戏和赌博。身份管理，信用系统等将成为卡尔达诺平台的一部分。我们将迭代卡尔达诺钱包应用程序 Daedalus，使其变成一个具有自动加密货币交易功能和合法加密货币交易功能的通用加密货币钱包。</p>\",\"frontmatter\":{\"path\":\"/cn/intro-text/\",\"doc_title\":null,\"author\":null,\"date\":null,\"language\":\"cn\",\"label\":\"content\",\"keywords\":\"intro\",\"group\":null}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-01-index.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读 论文和实现的差异 ，然后再阅读 协议和实现的文档 。 本文档目标读者是 IOHK…\",\"html\":\"<!-- Reviewed at d0868afac50ba6ffcbd95054e65cbf77fa513082 -->\\n<p>亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读<a href=\\\"/cardano/differences/\\\">论文和实现的差异</a>，然后再阅读<a href=\\\"/technical/protocols/csl-application-level/\\\">协议和实现的文档</a>。</p>\\n<p>本文档目标读者是 IOHK 的开发人员，第三方软件开发人员，审计和致力于实现卡尔达诺结算层或使用卡尔达诺结算层参考实现的咨询人员。</p>\\n<!-- CARDANO_SL_README_BEGIN_1 -->\\n<h2>什么是卡尔达诺结算层?</h2>\\n<p>Cardano SL（或卡尔达诺运算层）是由 <a href=\\\"https://iohk.io/team\\\">IOHK</a> 联合爱丁堡大学，雅典大学和康涅狄格大学共同设计开发的一种加密货币。卡尔达诺运算层是基于 Aggelos Kiayias，Alexander Russell，Bernardo David 和 Roman Oliynykov 的白皮书 <a href=\\\"https://iohk.io/research/papers/#9BKRHCSI\\\">『乌洛波罗斯：可证明安全的权益证明协议』</a>的 Haskell 实现。</p>\\n<p>您可以将卡尔达诺结算层视为基于比特币重新设计的针对比特币缺陷的自由修复。 有关卡尔达诺结算层和比特币之间的相似之处和差异的更多信息，请阅读<a href=\\\"http://cardanodocs.com/introduction/cn/#%E5%8D%A1%E5%B0%94%E8%BE%BE%E8%AF%BA%E8%BF%90%E7%AE%97%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB\\\">『卡尔达诺结算层为什么特别?』</a>。</p>\\n<!-- CARDANO_SL_README_END_1 -->\\n<h2>加密货币基础</h2>\\n<p>在给出加密货币的定义之前，我们先来谈谈为什么我们在意数字货币，特别是加密货币。</p>\\n<h3>我们为什么在意?</h3>\\n<h4>速度</h4>\\n<p>与传统（也称为法定）中心银行货币，与日元或美元相反，电子货币不需要一个银行系统来转移价值。这一限制的解除，使用数字货币的速度要快于银行业务，尤其是在全球范围内。使用数字货币从大阪转移10美元到丹佛不再需要数天的时间。无论距离如何，所有交易都能迅速完成。</p>\\n<h4>你掌控你自己的钱</h4>\\n<p>所有的商业银行账户所有者在收到支付请求后在合理的时间内只能支付一定的金额。银行体系对任何价值量都有限制，使个人无法迅速撤出或转移大量资金。有加密货币的情况下，持有一种称为<strong>密钥</strong>这一特殊信息的人就可以随意花钱。没有其他实体有权操纵用户拥有的价值。</p>\\n<h4>匿名</h4>\\n<p>人们可以根据需要，拥有任意多的加密货币地址，从不同的地址接收，消费资产。经营电子商务商店的商家可以拥有一组收款和退款的地址，以及一个用于他们自身需要的单独的个人『钱包』。通过统一的接口控制所有这些钱包，并且不需要登录到多个支付平台，这使得该过程非常节省时间。</p>\\n<h4>安全</h4>\\n<p>你的钱就像可用于消费的<strong>密钥</strong>一样安全。这意味着将密钥存储在保险箱中的 USB 闪存上相当于让纸币处于安全状态。即使进行了成功的网络攻击，也绝对没有人能够窃取这笔钱。</p>\\n<h4>扩展性</h4>\\n<p>使用一种称为<a href=\\\"https://www.blockstream.com/sidechains.pdf\\\">侧链</a>的方法，以及通用加密货币，如卡尔达诺结算层和比特币，就可以启用特定领域的加密货币，例如以太经典。这样一来，通过特定领域的加密货币开发的任何创新产品都可以让参与者在通用的加密货币中保持价值。这样的应用程序的例子有身份管理，游戏和赌博，以及可验证计算。</p>\\n<h3>什么是加密货币?</h3>\\n<p>加密货币是一种数字货币形式，使用密码来控制价值。密码学提供了一种生成任何类型信息的真实真实性证据的方法。这就是所谓的<em>数字签名</em>。在加密货币中，我们通过签署和发送交易到网络并接收已确认的交易块，生成一个总账（一个提供每个地址有多少钱的信息的数据库）。加密货币通常是分散的，这意味着来自全球各地的许多人通过运行加密货币节点参与总账的生成。因此，必须达成关于总账状况的共识。下一节讨论实现这种共识的两个最重要的方法。</p>\\n<h2>卡尔达诺结算层为什么特别</h2>\\n<!-- v0.1.0.0 -->\\n<p>虽然比特币和卡尔达诺结算层之间有相似之处，但这两个加密货币之间也有很多不同之处。最显着的区别是，比特币是工作量证明类型的加密货币，而卡尔达诺结算层使用权益证明的方法达成共识。这鼓励诚信和长期的参与。</p>\\n<h3>共识算法的目的</h3>\\n<p>共识算法被用来产生新的交易区块，使账本更新状态。每当有人发布一个交易区块时，他们（或者说他们的运行加密货币协议的节点）就必须附上他们已经证明的证据。下面讨论两种类型的证明。</p>\\n<h3>工作量证明和挖矿</h3>\\n<p>工作量证明是加密货币最普遍的共识算法类型。它起源于比特币，加密货币就是这么工作的。为了生成工作证明，计算机必须解决一个挑战。这是难以解决的计算繁重的问题，但解决方案很容易验证。当一台基于网络的工作量证明的计算机找到一个解决方案时，它会将交易发布于同它一起计算的其他计算机。这台计算机会因为产生区块得到交易费和奖励。整个过程被称为<em>挖矿</em>。挖矿是非常耗能的，所需的能源数量在不断增加，这可能导致不健康的竞争。</p>\\n<h3>权益证明和铸币</h3>\\n<p>权益证明是一种生成区块的新方法。由 <a href=\\\"https://iohk.io/team/aggelos-kiayias/\\\">Aggelos Kiayias 教授</a>领导的 IOHK 科学家们设计了第一个可证明的，称为乌洛波罗斯的权益证明算法。乌洛波罗斯是卡尔达诺结算层的核心。研究小组已经发表了一篇<a href=\\\"https://iohk.io/research/papers/a-provably-secure-proof-of-stake-blockchain-protocol/\\\">白皮书</a> ，这封白皮书对于那些拥有加密货币理论背景的人来说是值得一读的。权益证明的核心思想是，不要浪费电力来解决计算繁重的问题，而是选择一个节点来铸造一个新的区块，其概率与这个节点的硬币数量成正相关。如果一个节点有整数个(> 0)的 <a href=\\\"/cardano/proof-of-stake/#stake\\\">slot</a>，它被称为 slot 所有人。如果一个节点最终被选中来铸造一个区块，那么这个节点被称为 slot 领导者。您可以在<a href=\\\"/cardano/proof-of-stake/\\\">卡尔达诺结算层的股权证明</a>中了解更多关于该流程的信息。</p>\\n<!-- CARDANO_SL_README_BEGIN_2 -->\\n<h2>卡尔达诺结算层之上</h2>\\n<p>卡尔达诺结算层被称为『层』是有原因的。这是卡尔达诺平台的第一个组件。最终，它将被扩展到一个控制层，作为一个可信的计算框架来评估一种特殊的证明，以确保一定的计算正确执行。在游戏和赌博中，这样的系统被用于验证随机数生成和游戏结果的真实性。伴随着侧链，它将有可能完成诸如在游戏中公平分配奖金的任务。但是控制层的应用远远超出了游戏和赌博。身份管理，信用系统等将成为卡尔达诺平台的一部分。我们将迭代卡尔达诺<a href=\\\"https://github.com/input-output-hk/daedalus\\\">钱包应用程序 Daedalus</a>，使其变成一个具有自动加密货币交易功能和合法加密货币交易功能的通用加密货币钱包。</p>\\n<!-- CARDANO_SL_README_END_2 -->\",\"frontmatter\":{\"path\":\"/cn/introduction/\",\"doc_title\":\"介绍\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-04-installation.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"安装 支持的平台 支持的平台包括 Windows, macOS 和 Linux。这是 代达罗斯钱包 的  Windows 和 macOS 平台安装器 。 Linux 平台的安装器将在不久发布。目前来说，有两种方式在 Linux…\",\"html\":\"<!-- Reviewed at d0868afac50ba6ffcbd95054e65cbf77fa513082 -->\\n<h1>安装</h1>\\n<!-- CARDANO_SL_README_BEGIN_3 -->\\n<h2>支持的平台</h2>\\n<p>支持的平台包括 Windows, macOS 和 Linux。这是<a href=\\\"https://github.com/input-output-hk/daedalus\\\">代达罗斯钱包</a>的 <a href=\\\"https://daedaluswallet.io/#download\\\">Windows 和 macOS 平台安装器</a>。</p>\\n<p>Linux 平台的安装器将在不久发布。目前来说，有两种方式在 Linux 上运行卡尔达诺结算层：</p>\\n<ol>\\n<li>从源码构建（推荐方式）。请参考<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/develop/docs/how-to/build-cardano-sl-and-daedalus-from-source-code.md\\\">如何通过源代码构建卡尔达诺结算层以及代达罗斯钱包</a>文档。</li>\\n<li>\\n<p>使用<strong>非官方</strong> Arch Linux 安装包：</p>\\n<ul>\\n<li><a href=\\\"https://aur.archlinux.org/packages/cardano-sl/\\\">cardano-sl</a></li>\\n<li><a href=\\\"https://aur.archlinux.org/packages/daedalus-bridge/\\\">daedalus-bridge</a></li>\\n<li><a href=\\\"https://aur.archlinux.org/packages/daedalus/\\\">daedalus</a></li>\\n</ul>\\n</li>\\n</ol>\\n<!-- CARDANO_SL_README_END_3 -->\",\"frontmatter\":{\"path\":\"/cn/installation\",\"doc_title\":\"安装\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-10-technical.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at d0868afac50ba6ffcbd95054e65cbf77fa513082 -->\\n<h1>卡尔达诺结算层技术细节</h1>\\n<p>对于想要贡献原始客户端，以及想基于卡尔达诺结算层创建自己的客户端的开发人员来说，这一章节是一个起点。尽管如此，这一节将主要覆盖原始客户端，并有所扩展，在一段时间内可以把它当做最初的参考文档</p>\\n<h2>高层次概述</h2>\\n<p>一个卡尔达诺结算层节点是一个区块链节点。运行时，他会找到其他节点(通过 <a href=\\\"http://ast-deim.urv.cat/cpairot/dhts.html\\\">DHT</a>)，然后开始执行区块链的相关任务。</p>\\n<p>卡尔达诺结算层中的时间会以 epochs 划分。epochs 又会以 slots 划分。 Epochs 和 slots 会被编号。 因此，slot <code>(3,5)</code> 被读作『第3个 epochs 的第5个 slot』 (第0个 slot 以及第0个 epoch 也是可以的).</p>\\n<p>卡尔达诺结算层会使用一些常量集, 特殊值定义在\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/bf5dd592b7bf77a68bf71314718dc7a8d5cc8877/core/constants.yaml\\\"><code>constants.yaml</code> 配置文件中</a>。\\n主要有两种：生产模式和开发模式。 在本指南中，我们将参考生产常量。</p>\\n<p>假设卡尔达诺结算层的值是：:</p>\\n<ul>\\n<li>slot 持续时间: 120秒,</li>\\n<li>安全参数 <em>k</em>: 60.</li>\\n</ul>\\n<p>换句话说，<strong>一个 slot 可以持续120秒</strong>, 而一个 epochs有 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/9ee12d3cc9ca0c8ad95f3031518a4a7acdcffc56/core/Pos/Core/Constants/Raw.hs#L161\\\"><code>10×k</code></a>\\n个 slot, 所以它可以持续<strong>1200分钟</strong>或<strong>20个小时</strong>.</p>\\n<p>每个 slot 上有一个节点被称作 slot 领导者。只有这个 slot 有权在这些 slot 中生成一个新区块；这个区块会被加入到区块链中。然而我们并不能确保这个区块一定会被生成(比如 slot 领导者在响应的过程中可能会离线)。</p>\\n<p>此外，slot 领导者可以将其权利委托给另一个节点 <code>N</code>；在这种情况下，节点 <code>N</code> 而非 slot 领导者将有权生成一个新的块。请注意，<code>N</code> 具有委托权的节点不能被称为 slot 领导者，它只是一个委托。</p>\\n<p>理论上可以将 slot 领导者的权力委托给多个节点，但是不推荐，之后会解释原因。此外，使用相同的密钥（即一台计算机上）我们可以运行中多个节点，假设有节点 <code>A</code>, <code>B</code>, <code>C</code>，如果节点 <code>A</code> 被选为 slot 领导者，不仅 <code>A</code> 本身，节点 <code>B</code> 和 <code>C</code> 都能够生成一个新区块。在这种情况下，每一个节点都将发出一个不同的块，网络将分叉 - 每个其他节点将只接受这些并发区块块中的一个。之后，这个分叉将被淘汰。</p>\\n<p>在 epoch 中，节点之间相互发送 MPC 消息，以达成共识，谁将被允许在下一个时期生成区块。Data 消息中的有效载荷 （以及事务）会被包含在块中。</p>\\n<p>一个地址持有的货币（或『股份』）越多，被选择生成一个区块的可能性就越大。请阅读<a href=\\\"/cardano/proof-of-stake/\\\">乌洛波罗斯权益证明算法</a>获取更多细节。</p>\\n<p>简而言之:</p>\\n<ol>\\n<li>发送信息，</li>\\n<li>接收信息/交易/等等，</li>\\n<li>形成一个区块 (如果你是 slot 领导者的话)，</li>\\n<li>重复。</li>\\n</ol>\\n<h2>商业逻辑</h2>\\n<h3>接收者</h3>\\n<p>接收者处理传入的消息并对其作出响应。各种补充的听众不会被覆盖，而是集中在一个接收者上。</p>\\n<p>接收者大多使用<a href=\\\"/technical/protocols/csl-application-level/#invreqdata-and-messagepart\\\">中继框架</a>，其中包括三种类型的消息：</p>\\n<ul>\\n<li><code>Inventory</code> 消息：节点在获取新数据时向网络发布消息。  </li>\\n<li><code>Request</code> 消息：如果某个新数据没有被这个节点获取的话，节点会向其他节点获取在 <code>Inventory</code> 消息中的新数据。  </li>\\n<li><code>Data</code> 消息：节点对 <code>Request</code> 消息回复的数据。<code>Data</code>消息包含具体的数据。</li>\\n</ul>\\n<p>例如，当用户创建新的交易时，钱包将具有交易 ID 的 <code>Inventory</code> 消息发送到网络。如果收到 <code>Inventory</code> 的节点没有该 ID 相关的交易记录，那么它会回复 <code>Request</code> 消息，然后钱包会在 <code>Data</code> 消息中发送该交易信息。节点收到 <code>Data</code> 消息后，将 <code>Inventory</code> 消息发送给 DHT 网络中的邻居，并重复之前的操作。</p>\\n<p>另一个例子 - 区块接收者：<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/src/Pos/Block/Network/Listeners.hs#L30\\\"><code>handleGetHeaders</code></a>，\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/src/Pos/Block/Network/Listeners.hs#L50\\\"><code>handleGetBlocks</code></a>，\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/src/Pos/Block/Network/Listeners.hs#L77\\\"><code>handleBlockHeaders</code></a>。</p>\\n<h3>Worker</h3>\\n<p>一个 Worker 会在一个时间区间内进行重复性的工作. 比如：</p>\\n<ul>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/infra/Pos/Communication/Protocol.hs#L218\\\"><code>onNewSlotWorker</code></a>：在每个插槽的开始时运行。做一些清理，然后运行其他功能。这个 Worker 在这个 epoch 的开始时也会创造了一个 『起始块』。有两种类型的块：『生成块』和『主块』。主块储存在区块链中; 在 epoch 之间，每个节点都会间断性地生成块。主块不会被告知其他节点。但是，如果节点离线一段时间，并且需要同步区块链，节点可以请求其他人的创世区块。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/d01d392d49db8a25e17749173ec9bce057911191/src/Pos/Block/Worker.hs#L69\\\"><code>blkOnNewSlot</code></a>: 创建一个新块（当轮到节点创建一个新块时），并将其发给其他节点。</li>\\n</ul>\\n<h2>权益证明</h2>\\n<p>卡尔达诺结算层的核心基于 乌洛波罗斯 权益证明算法。正如同名的<a href=\\\"https://eprint.iacr.org/2016/889\\\">白皮书</a>所描述的那样。</p>\\n<h2>分叉</h2>\\n<p>通常，一个链（主链）由一个节点维护，但最终可能会出现分叉链。回想一下，只有区块 <code>k</code> 和更多 slot 被认为是稳定的。这样一来，如果接收一个区块，它既不是区块链的一部分也不是 blockchain 的延续，我们首先检查其复杂程度（复杂性是链的长度）是否比我们的大，TODO</p>\\n<p>然后我们开始随后请求来自先前块提供替代链头的节点。如果我们来得深入k插槽前，替代链被拒绝。否则，一旦我们到达我们连锁店中​​存在的区块，替代链就会被添加到存储区。从国家的角度来看，我们存储和维护所有可行的替代链。如果看起来一个替代链比主链更长，那么它们被替换，使替代链成为新的主链。</p>\\n<h2>补充部分</h2>\\n<h3>Slotting</h3>\\n<p>我们使用的共识方案依赖于正确的 slot。更具体地说，它依赖于系统中的节点可以访问的当前时间（小的偏差是可接受的），然后用于确定何时开始和结束任何特定的 slot，并且在该 slot 执行特定的动作。</p>\\n<p>系统开始时间是 <code>(0,0)</code> slot 的时间戳（即，第0 epoch 的第0slot）。</p>\\n<h2>P2P 网络</h2>\\n<h3>Peer 发现</h3>\\n<p>我们使用 Kademlia DHT 进行对等节点的发现。这是基于 <a href=\\\"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf\\\">Kademlia: 基于 XOR 度量的 P2P 信息系统</a> 的哈希表的通用解决方案。</p>\\n<p>简言之，在 Kademlia 网络的每个节点都被提供一个 <code>160</code> 字节的随机生成的 id。节点之间的距离由 <code>XOR</code> 确定。网络以这样的方式组织：节点对于每个相对距离：<code>2^i &#x3C; d &#x3C;= 2^(i+1)</code> 只知道 <code>K</code> (在最初的客户端实现中 <code>K=7</code>)。</p>\\n<p>初始对等节点通过<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia/Implementation.hs#L194\\\">发送</a> Kademlia 的 <code>FIND_NODE</code> 信息完成，它带有以自己节点 ID 作为<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/src/Pos/Constants.hs#L89\\\">预先配置的一组节点</a>以及通过用户命令行输入的节点的参数。我们的实现中会一次<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/infra/Pos/DHT/Real/Real.hs#L228\\\">发送</a>这个请求给所有已知的对等节点，然后等待第一个回复。</p>\\n<p>客户端运行时，每个 Kademlia 协议收集对等节点。已知对等节点在后续启动之间保存，<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia.hs#L197\\\">恢复</a>。对于每个对等体，我们保存其<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia/Types.hs#L42\\\">主机和端口号</a>，以及它们的<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia/Types.hs#L70\\\">节点 id</a>。</p>\\n<h3>Messaging</h3>\\n<p>Kademlia 已经提供了已知节点的概念。这样的节点可以被称为<em>邻居</em>。要将消息发送到网络上的所有节点，你可以发送给邻居，它们会将其发送给它们的邻居，依次类推。但有时候我们可能不需要在整个网络上传播消息，而是只将消息发送给邻居。因此我们有三种类型的发送消息：</p>\\n<ul>\\n<li>发送给一个节点，</li>\\n<li>发送给邻居，</li>\\n<li>发送给网络。</li>\\n</ul>\\n<h4>消息类型</h4>\\n<p>为了处理这个，使用三种消息头，并且有两种消息：</p>\\n<ul>\\n<li>简单：发送给一个同伴。</li>\\n<li>广播：试图发送到整个网络，迭代地发送消息到邻居。</li>\\n</ul>\\n<p>广播消息在检索（在处理之前）重新发送给邻居。而且，它们会通过 LRU 缓存检查，已经收到的消息会被忽略。</p>\\n<h3>领导者和富人计算（LRC）</h3>\\n<p>『Slot 领导者』和『富人』是乌洛波罗斯权益证明算法的重要概念。</p>\\n<ul>\\n<li>\\n<p>Slot 领导者：当前 epoch（当前 epoch 的每个 slot） 的 slot 领导者是在而当前 epoch 开始时通过<a href=\\\"/cardano/proof-of-stake/#%E8%BF%BD%E9%9A%8F%E4%B8%AD%E6%9C%AC%E8%81%AA\\\">追随中本聪</a>（FTS）计算的。FTS 使用 <code>shared seed</code>，它是前一个 epoch <a href=\\\"/cardano/proof-of-stake/#%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97\\\">多方计算</a>（MPC）算法的结果：MPC 结果中，一些节点揭露它们的 种子，这些种子的 <code>xor</code> 称为 <code>shared seed</code>。</p>\\n</li>\\n<li>\\n<p>富人：只有已经发送 VSS 证书并且有足够权益的节点才能参与 MPC 算法。在 epoch 的开始，节点必须知道所有潜在的参与者以在这个 epoch 中验证 MPC 消息。富人也是在当前 epoch 的开始计算的。</p>\\n</li>\\n</ul>\\n<p>富人对于其他组件也很重要；例如，更新系统使用富人判断节点是否可以发布更新协议和投票。</p>\\n<p>有两种计算富人的方法：</p>\\n<ul>\\n<li>考虑共同权益 </li>\\n<li>考虑委派权益（乌洛波洛斯提供委派自己权益给其他节点的机会，更多信息请参阅<a href=\\\"/cardano/differences/#%E6%9D%83%E7%9B%8A%E5%A7%94%E6%B4%BE\\\">委派章节</a>。</li>\\n</ul>\\n<p>MPC 和更新系统组件需要具有委派权益的富人，但不需要拥有共同权益的委派组成。</p>\\n<h2>常量</h2>\\n<p>卡尔达诺结算层使用一些基础常量。他们的值经过了协议原作者和独立安全评论员的讨论，因此强烈推荐可选客户端使用这些常量。 </p>\\n<p>这些常量在\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/bf5dd592b7bf77a68bf71314718dc7a8d5cc8877/core/constants.yaml\\\"><code>constants.yaml</code> 配置文件</a>\\n中定义，分为生产环境和开发环境。</p>\",\"frontmatter\":{\"path\":\"/cn/technical\",\"doc_title\":\"技术细节\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-13-for-contributors.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Redirecting...\",\"html\":\"<h1>Redirecting...</h1>\\n<script>\\n    //window.location.replace(\\\"https://github.com/input-output-hk/cardano-sl/blob/develop/CONTRIBUTING.md\\\");\\n</script>\",\"frontmatter\":{\"path\":\"/cn/for-contributors/\",\"doc_title\":\"对于贡献者\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-19-glossary.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"术语表 Ada 我们的货币的名字，为纪念  Ada\\nLovelace…\",\"html\":\"<!-- Reviewed at d0d6c2fedefb642744a24b4b0a6d8d7ad11532f6 -->\\n<h1>术语表</h1>\\n<h2>Ada</h2>\\n<p>我们的货币的名字，为纪念 <a href=\\\"https://en.wikipedia.org/wiki/Ada_Lovelace\\\">Ada\\nLovelace</a> 而命名。</p>\\n<h2>地址</h2>\\n<p><a href=\\\"#%E8%8A%82%E7%82%B9\\\">节点</a>的唯一标示符。请阅读<a href=\\\"/cardano/addresses/\\\">卡尔达诺结算层的地址</a>获得更多信息。</p>\\n<h2>余额</h2>\\n<p>请阅读<a href=\\\"/cardano/balance-and-stake/\\\">卡尔达诺结算层的余额和权益</a> 获得解释。</p>\\n<h2>区块</h2>\\n<p><a href=\\\"#%E8%B4%A6%E6%9C%AC\\\">账本</a>的基础元素。请阅读<a href=\\\"/technical/blocks/\\\">卡尔达诺区块</a>获取技术细节。</p>\\n<h2>区块链</h2>\\n<p>请阅读<a href=\\\"#%E8%B4%A6%E6%9C%AC\\\">账本</a>。</p>\\n<h2>卡尔达诺结算层</h2>\\n<p>卡尔达诺 SL (或者说卡尔达诺结算层) 是由 <a href=\\\"https://iohk.io/team\\\">IOHK</a> 设计和开发的去中心化加密货币。为纪念 <a href=\\\"https://en.wikipedia.org/wiki/Gerolamo_Cardano\\\">Gerolamo Cardano</a> 而命名。</p>\\n<h2>掷币</h2>\\n<p>掷币协议是允许两方或多方获得均匀随机值的协议。我们使用掷币协议作为 <a href=\\\"#ssc\\\">SSC</a> 的基础。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>（第36页）以了解掷币协议的更多详情。</p>\\n<h2>一致性算法</h2>\\n<p>分布式系统对于共享数据集合达成一致观点的一种方式。卡尔达诺结算层使用<a href=\\\"/cardano/proof-of-stake/\\\">乌洛波罗斯一致性算法</a>，这是一个基于<a href=\\\"#%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E\\\">权益证明</a>的算法。</p>\\n<h2>加密货币</h2>\\n<p>使用加密协议来生成账本的计算机系统，请阅读<a href=\\\"/introduction/#cryptocurrency-basics\\\">加密货币基础</a>了解更多信息。</p>\\n<h2>代达罗斯</h2>\\n<p>卡尔达诺结算层钱包应用。 它为用户提供一个用户界面, 用户可以管理，发送，收取资金等等。请阅读<a href=\\\"/technical/wallet-frontend/\\\">卡尔达诺结算层钱包应用前端</a>获取更多信息。</p>\\n<h2>去中心化</h2>\\n<p>通过独立节点进行交互操作的计算机系统的概念。在维护共享数据集合，如账本的情况下，需要对数据的一致性和可靠性达成共识。</p>\\n<h2>Epoch</h2>\\n<p>我们将知道谁有权利在每个 slot 中生成一个区块的更长的时间段。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>（第3页）了解技术细节。</p>\\n<h2>追随中本聪</h2>\\n<p>一种随机选择权益所有者在区块链中建立一个新区块的机制，根据协议中的股份数量，按比例获得选举机会。</p>\\n<h2>保证输出交付</h2>\\n<p>保证输出交付是一种机制，能证明诚实方能保证成功完成多方计算（MPC）。我们在 <a href=\\\"#ssc\\\">SSC</a> 中使用 G.O.D.</p>\\n<h2>诚实的大多数</h2>\\n<p>诚实的大多数是指诚实的参与者数量严格大于攻击者数量的情况，即至少 50% + 1 是诚实的大多数。</p>\\n<h2>Kademlia</h2>\\n<p>请阅读<a href=\\\"#%E5%AF%B9%E7%AD%89%E7%82%B9%E5%8F%91%E7%8E%B0\\\">对等点发现</a>。</p>\\n<h2>领导者选举</h2>\\n<p>挑选谁将在下一个 epoch 生成区块的过程。将依据领导者的股权比例选出（参见<a href=\\\"#%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E\\\">权益证明</a>, <a href=\\\"#%E8%BF%BD%E9%9A%8F%E4%B8%AD%E6%9C%AC%E8%81%AA%E7%AE%97%E6%B3%95\\\">追随中本聪算法</a>)。</p>\\n<h2>账本</h2>\\n<p>个人所拥有的价值的数据集合。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>了解技术细节。</p>\\n<h2>Lovelace</h2>\\n<p>我们的货币的最小单位的名称。为纪念 <a href=\\\"https://en.wikipedia.org/wiki/Ada_Lovelace\\\">Ada\\nLovelace</a> 而命名。</p>\\n<h2>铸币</h2>\\n<p>在<a href=\\\"/introduction/#%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E%E5%92%8C%E9%93%B8%E5%B8%81\\\">权益证明和铸币</a>系统中生成新区块的过程。</p>\\n<h2>节点</h2>\\n<p>参与分布式协议系统的计算机程序。请阅读<a href=\\\"/technical/#%E9%AB%98%E5%B1%82%E6%AC%A1%E6%A6%82%E8%BF%B0\\\">高层次概述</a>获取更多细节。</p>\\n<h2>论文</h2>\\n<p>官方协议论文：<a href=\\\"https://eprint.iacr.org/2016/889\\\">乌洛波罗斯：一个可证安全的权益证明区块链协议</a>。请注意，卡尔达诺结算层的实现与论文的实现不同，<a href=\\\"/cardano/differences/\\\">请阅读差异</a>以了解详情。</p>\\n<h2>节点发现</h2>\\n<p>节点运行后找到其他节点的方法。我们使用的节点发现基于 Kademlia DHT。请阅读 <a href=\\\"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf\\\"> Kademlia\\n论文</a>获得技术细节。</p>\\n<h2>Plutus</h2>\\n<p>在卡尔达诺中定义智能协议的强类型纯函数式语言。请阅读 <a href=\\\"/technical/plutus/introduction/\\\">Plutus</a> 获取更多细节。</p>\\n<h2>权益证明</h2>\\n<p>乌洛波罗斯权益证明算法是<a href=\\\"#%E8%AE%BA%E6%96%87\\\">协议</a>中最重要的部分。它定义了<a href=\\\"#%E8%8A%82%E7%82%B9\\\">节点</a>对<a href=\\\"#%E8%B4%A6%E6%9C%AC\\\">账本</a>状态达成共识的方式。请阅读<a href=\\\"/cardano/proof-of-stake/\\\">乌洛波罗斯权益证明算法</a>获取更多细节。</p>\\n<h2>PVSS</h2>\\n<p>公开验证密钥共享模式 (Publicly Verifiable Secret Sharing)是我们在 <a href=\\\"#ssc\\\">SSC</a> 中使用的密码方案。请阅读<a href=\\\"/technical/pvss/\\\">卡尔达诺结算层 PVSS</a> 获取更多细节。</p>\\n<h2>富人</h2>\\n<p>有足够股权参与一些行动的权益所有人。具体来说，有三种类型的动作：随机性生成（<a href=\\\"/technical/leader-selection/\\\">slot 领导者选举过程</a>），<a href=\\\"/technical/delegation/#%E9%87%8D%E9%87%8F%E7%BA%A7%E6%9D%83%E7%9B%8A%E5%A7%94%E6%B4%BE\\\">重量级权益委派</a>，<a href=\\\"/cardano/update-mechanism/#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9B%B4%E6%96%B0%EF%BC%9A%E7%AD%BE%E7%BD%B2%E5%92%8C%E5%AE%A3%E5%B8%83\\\">更新提案的投票</a>。</p>\\n<h2>签名</h2>\\n<p>一种用来生成我们在<a href=\\\"#%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81\\\">加密货币</a>中使用的保证任何类型信息真实性证据的方法。</p>\\n<h2>Slot</h2>\\n<p>在不同节点上显著大于预期的不同时钟数的一小段物理时间。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>(第4页)获取更多技术细节。</p>\\n<h2>Slot 领导者</h2>\\n<p>slot 领导者是一个被选举为有权在当前 slot 创建区块的节点。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>(第7页)获取更多技术细节。</p>\\n<h2>SSC</h2>\\n<p>SSC (Shared Seed Computation) 是 <a href=\\\"#%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE\\\">Slot 领导者选举</a>的一部分。这部分被实现为<a href=\\\"#%E4%BF%9D%E8%AF%81%E8%BE%93%E5%87%BA%E4%BA%A4%E4%BB%98\\\">保证输出交付</a>的<a href=\\\"#%E6%8E%B7%E5%B8%81\\\">掷币</a>协议。作为 SSC 的结果，我们得到一个将用于<a href=\\\"#%E8%BF%BD%E9%9A%8F%E4%B8%AD%E6%9C%AC%E8%81%AA\\\">追随中本聪</a>机制的随机算法。</p>\\n<h2>权益</h2>\\n<p>请阅读 <a href=\\\"/cardano/balance-and-stake/\\\">卡尔达诺结算层的余额和权益</a> 章节获取解释。</p>\\n<h2>权益所有人</h2>\\n<p>一个拥有正数股权的节点。</p>\\n<h2>转账</h2>\\n<p>表示价值转移的数据。请阅读<a href=\\\"/cardano/transactions/\\\">卡尔达诺结算层的转账</a>获取更多细节。</p>\\n<h2>转账费用</h2>\\n<p>请阅读<a href=\\\"/cardano/transaction-fees/\\\">卡尔达诺结算层转账费用</a>章节获取解释。</p>\",\"frontmatter\":{\"path\":\"/cn/glossary\",\"doc_title\":\"术语表\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-01-proof-of-stake.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"乌洛波罗斯权益证明算法 乌洛波罗斯权益证明算法是协议中最重要的部分。它定义了节点达到 账本 一致性的方式。 乌洛波罗斯算法是唯一一个基于科学证明的安全的区块链权益证明协议。 为什么要有权益证明？ 不选择被比特币采用的 PoW（工作量证明）而选择 PoS…\",\"html\":\"<!-- Reviewed at c4c45ce9a7a8f4aa6d88a32829755196a017f6a1 -->\\n<h1>乌洛波罗斯权益证明算法</h1>\\n<p>乌洛波罗斯权益证明算法是协议中最重要的部分。它定义了节点达到<a href=\\\"/glossary/#ledger\\\">账本</a>一致性的方式。</p>\\n<p>乌洛波罗斯算法是唯一一个基于科学证明的安全的区块链权益证明协议。</p>\\n<h2>为什么要有权益证明？</h2>\\n<p>不选择被比特币采用的 PoW（工作量证明）而选择 PoS (权益证明) 最重要的原因是考虑了能源消耗。运行比特币协议非常消耗资源，据估计，一个比特币的转账所需要的能源是3.8个美国家庭一天消耗的能源。随着越来越多的比特币矿工将资金投入矿业，运行比特币协议的能源要求只会越来越高，他们挖矿的难度也会越来越大。这也是为什么研究人员尽力研究达成共识的替代算法，比如使用所谓的 BFT（Byzantine Fault Tolerant）一致性算法和 PoS 算法。</p>\\n<h2>什么是权益证明算法</h2>\\n<p>权益证明是生成区块的新方法。权益证明的核心思想是，不要浪费电力来解决计算量大的问题，而是选择一个节点来产生（或『铸造』）一个新的区块，其概率与这个节点所拥有的币数量成正比。如果一个节点具有正数（>0）的股权，则被称为权益所有人。如果一个节点最终被选中来铸造新的区块，它被称为『slot 领导者』。</p>\\n<h3>证明</h3>\\n<p>『权益证明』的『证明』部分是指证明交易块是合法的。</p>\\n<h3>权益</h3>\\n<p>『权益』指的是节点上的地址所拥有的相对价值。『相对价值』指的是『卡尔达诺结算层系统中某个节点钱包上的价值除以总价值』。请阅读<a href=\\\"/cardano/balance-and-stake/\\\">卡尔达诺结算层的平衡和权益</a> 章节获取更多信息。</p>\\n<h2>关于 Slot 领导者</h2>\\n<p>有正资产的节点称作权益所有人，只有权益所有人能参与运行协议。权益所有人必须被选举为 slot 领导者才让区块链生成区块。Slot 领导者可能监听到其他节点的交易信息，然后通过密钥生成一个交易区块发给全网。</p>\\n<p>你可以认为 slot 领导者是比特币中的矿工，但上述的一致性协议会确定谁，什么时候能挖矿，能挖到多少矿。</p>\\n<h2>Epochs 和 Slots</h2>\\n<p>乌洛波罗斯协议将物理的时间划分为 <strong>epochs</strong>, 每一个 epoch 又划分为 <strong>slots</strong>:</p>\\n<pre><code>+----------+----------+-------+----------+--------------------> t\\n|  slot 0  |  slot 1  |  ...  |  slot N  |\\n\\n \\\\                                      / \\\\\\n  -------------- epoch M ---------------   -- epoch M+1 -- ...\\n</code></pre>\\n<p>请注意 slot 是相对较短的一段时间（比如20秒）。</p>\\n<p>每个 slot 有且只有一个领导者（slot leader，SL）：</p>\\n<pre><code>+----------+----------+-------+----------+----> t\\n|  slot 0  |  slot 1  |  ...  |  slot N  |\\n\\n    SL 0       SL 1               SL N\\n</code></pre>\\n<p>slot 领导者有权在他的 slot 内生成一个区块。</p>\\n<pre><code>  +------+   +------+           +------+\\n  | Bl 0 |&#x3C;--| Bl 1 |&#x3C;-- ... &#x3C;--| Bl N |\\n  +------+   +------+           +------+\\n+----------+----------+-------+----------+----> t\\n|  slot 0  |  slot 1  |  ...  |  slot N  |\\n\\n    SL 0       SL 1               SL N\\n</code></pre>\\n<p>这意味着 slot 领导者的数量一定等于一个 epoch 内 slots 的数量（不妨设为 <code>N</code>)，因此不可能在一个 epoch 里面生成超过 <code>N</code> 个区块。</p>\\n<p>如果 slot 领导者错过了它的 slot（比如，在那个阶段它离线了），在下一次被选举为领导者之前，它没有权利再生成区块。</p>\\n<p><strong>请注意：</strong> 可以有一个或多个 slots 是空的（即，不生成区块），但在一个 epoch 期间，它必须生成大部分块（至少50%+1）。</p>\\n<h2>Slot 领导者选举是怎么工作的</h2>\\n<p>Slot 领导者从所有的权益所有人中选举。请注意并不是所有的权益所有人能参与这次选举，只有有足够多的权益（比如，总量的2%)才有资格。我们称这些权益所有人为『候选人』</p>\\n<p>在 epoch 的选举中会选举一个 slot 领导者参与下一次 epoch。因此，在 epoch <code>N</code> 结束的时候，我们就能知道 epoch <code>N+1</code> 的 slot 领导者是谁，并且这是不可更改的。</p>\\n<p>你可以把这样的选举当做 『公平抽签』：权益所有人中的任何一个都能成为 slot 领导者。但 PoS 中一个很重要的的思想是，权益所有人拥有的股份越多，它被选举为 slot 领导者的可能性也就越大。</p>\\n<p><strong>请注意：</strong>同一个 epoch，一个权益所有人可以被多次选做 slot 领导者。</p>\\n<h3>多方计算</h3>\\n<p>选举过程的根本问题之一是无偏性。我们需要一些随机性作为选举的基础，这样的话，选举的结果是随机的，公平的，问题是，这个随机性从哪来？</p>\\n<p>多方计算（multiparty computation (MPC) ）方法用来实现这个随机性，每个参选人独立进行一次『投硬币』的行为，然后与其他参选人分享结果。这个想法就是：结果由每个参选人随机产生，但最终它们在相同的最终价值上达成一致。</p>\\n<h4>提交阶段</h4>\\n<p>首先，参选人会产生一个密钥（特殊的随机值）。接着，参选人会形成一个『提交』，这是一个包含加密份额（见下面的解释）以及密码的证明的消息。</p>\\n<p>然后参选人会用密钥来签署这个提交，指定 epoch 编号，附上它的公钥。在这种情况下，每个人都可以知道谁创建了这个提交，以及这个提交属于哪个 epoch。</p>\\n<p>随后，参选人会将其提交交给其他参选人，最终每个参选人都会拿到其他参选人的提交。</p>\\n<p>注意：这些提交将被放入区块中，也就是说它们将成为区块链的一部分。</p>\\n<h4>开启阶段</h4>\\n<p>在这个阶段参选人发送一个『开启』状态，这是一个打开提交的特殊值。一个提交就像一个锁着的盒子（里面有一个密钥），我们需要一个开启的钥匙来打开这个盒子，获取里面的密钥。</p>\\n<p><strong>注意：</strong>所有的开启都将放入区块中，它们会变成区块链的一部分。</p>\\n<h4>恢复阶段</h4>\\n<p>这是最后的阶段。</p>\\n<p>最终，参选者既有提交，也有开启。从理论上来说，一些选民可以是对手。它可以公布它的提交，但<strong>不</strong>公开它的开启。</p>\\n<p>在这种情况下，诚实的选民可以张贴（上面有提到）来重建密钥，这个想法很简单：即使某些选民是对手，选举也能成功结束。</p>\\n<p>随后，参选者验证提交，开启匹配，如果成功，从提交中提取密钥，并从这些密钥中形成种子（随机生成的字符串）。所以所有的选民都会得到相同的种子，并且会被用于追随中本聪算法。</p>\\n<h3>追随中本聪</h3>\\n<p>在参选者获取种子之后（我们需要随机性），他们必须为下一个 epoch 选择特定的 slot 领导者。这时候就引入了追随中本聪算法。它类似于这样：</p>\\n<pre><code>         +-----+\\nSEED --->| FTS |---> ELECTED_SLOT_LEADERS\\n         +-----+\\n</code></pre>\\n<p>我们解释一下 slot 领导者是怎么被选中的。我们将最小的，原子级的币叫做 『<a href=\\\"/glossary/#lovelace\\\">Lovelace</a>』。基本上，因为 slot 领导者只能从权益所有者中选择，账本会生成币的分发。FTS 是一个挑选币的可证算法，当权益所有人 <code>S</code> 的币被选中时，<code>S</code> 就成为一个 slot 领导者。很明显，<code>S</code> 的币越多，他的币被选中的几率也就越大。</p>\\n<p>为什么它被称为『追随中本聪算法』是因为在比特币中，货币的最小单位被称为『聪』，这是为了表彰比特币的发明人中本聪（Satoshi Nakamoto）</p>\\n<h2>大多数都是诚实的</h2>\\n<p>协议的基本假设前提是<strong>大多数都是诚实的</strong>。这意味着至少有 50%+1 的权益所有人是诚实的。在这种情况下，我们可以<strong>证明</strong>攻击者无法打破区块链的<em>持久化</em>和<em>活跃度</em>。欲了解更多信息，请参阅<a href=\\\"/glossary/#paper\\\">论文</a> (2到3页)。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/proof-of-stake/\",\"doc_title\":\"乌洛波罗斯权益证明算法\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-04-differences.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at c4c45ce9a7a8f4aa6d88a32829755196a017f6a1 -->\\n<h1>乌洛波罗斯协议论文与实现的区别</h1>\\n<p>本文档的目标是概述卡尔达诺结算层实现方式与<a href=\\\"/glossary/#%E8%AE%BA%E6%96%87\\\">论文</a>中提供的乌洛波罗斯算法协议规范的不同，并阐明论文中的典型问题。</p>\\n<p>本文档分为四个部分：</p>\\n<ol>\\n<li><em>说明</em> - 阐述在论文中没有提到但实际实现中非常重要的细节。  </li>\\n<li><em>修改</em> - 列出哪些在论文中有说明，但在卡尔达诺结算层中以不同的方式实现。  </li>\\n<li><em>新增功能</em> - 简要概述了在论文中没有介绍但在卡尔达诺结算层中实现的新功能。  </li>\\n<li><em>遗漏</em> - 列出了论文中有描述，但尚未在卡尔达诺结算层中实现的特性。</li>\\n</ol>\\n<h1>说明</h1>\\n<p>这一章节概述需要阐明的任何话题。</p>\\n<h2>时间, Slots, 和同步</h2>\\n<p>在协议的基本模型中，时间被分成称为 slot 的离散单位。但是，没有安全获得足够精度的当前时间的详细方法。</p>\\n<p>在卡尔达诺结算层中，当前时间值从用户的计算机系统时间值获取。</p>\\n<p>我们还有一个功能来通知用户他们的系统时间是否不正确（我们将它与 NTP 服务器的时间进行比较）。这个功能计划将来发布。</p>\\n<h2>投币和可验证的密钥共享</h2>\\n<p>论文中由 Schoenmakers 为卡尔达诺结算层提供 PVSS(Publicly Verifiable Secret Sharing) 方案。但是，卡尔达诺结算层目前使用 <a href=\\\"https://eprint.iacr.org/2017/216.pdf\\\">\\\"SCRAPE: Scalable Randomness Attested by\\nPublic Entities\\\"</a> PVSS 方案 </p>\\n<p>使用 VSS（可验证的密钥分享，Verifiable Secret Sharing）方案时的一个挑战是将用于签名的公钥与用于 VSS 方案的公钥相关联（<code>VssPublicKey</code>）。这是通过引入 <code>VssCertificate</code> 来解决的。这个证书是一个由签名密钥给出的签名，它由一个对 <code>VssPublicKey</code> 以及这个证书的有效时间组成。最初，所有参与随机生成的权益所有者都拥有证书。当出现一个拥有足够股份的新权益所有人时，或现有证书到期时，应该生成一个新的证书并提交给网络。<code>VssCertificate</code> 被存储在区块中。</p>\\n<p>PVSS 方案使用共享验证信息，这也包括了对密钥的提交。它也被用做协议中的提交。PVSS 提交已经在 elliptic curve (TODO)\\nsecp256r1 实现，请参考 <a href=\\\"/technical/pvss/\\\">PVSS 在卡尔达诺结算层的实现</a>获取更多细节。</p>\\n<h2>区块生成时间</h2>\\n<p>在论文中，他们没有明确说明何时 slot 领导者应该生成一个新的区块发送给网络：它可以在 slot 的开始，slot 的结尾，slot 的中间等等。在卡尔达诺结算层中有一个特殊的常量，叫做『网络直径』（network diameter），它接近于将区块广播到网络中所有节点所需的最大时间。例如，如果网络直径值为3，则在 slot 结束前，区块会被生成，并且广播3秒。</p>\\n<h2>权益委派</h2>\\n<p>权益委派，如论文中描述的，不明确规定代理签名证书是否应存储在区块链中（尽管建议存储区块链中的撤销列表）。在区块链没有存储代理签名证书的情况下，几乎没有可能考虑检查委派的股份的阈值合格性。另一方面，如果所有的证书都存储在区块链中，当大部分区块被代理证书占用时，可能会导致区块链膨胀。提交证书是免费的，所以攻击者可以根据需要生成尽可能多的证书。</p>\\n<p>卡尔达诺结算层有两种委派：重量级和轻量级。加入重量级委派有一个门槛。来自重量级代理的代理签名证书存储在区块链中。相反，每个人都可以使用轻量级委派，但证书不会存储在区块链中，在检查资格限制时不会考虑证书，正如论文所建议的，使用委派代理方案。</p>\\n<p>请阅读<a href=\\\"(/technical/delegation/)\\\">卡尔达诺结算层权益委派</a> 获取实现细节。</p>\\n<h1>修改</h1>\\n<h2>领导者选举过程</h2>\\n<p>在论文中，领导者选举过程被描述为翻转币的有偏估计量 <code>(1 - p₁) … (1 - pⱼ₋₁) pⱼ</code>，以判断第 j 个权益所有人是否为给定 slot 的领导者。这里 <code>pⱼ</code> 为选择第 j 个权益所有人的可能性。</p>\\n<p>在卡尔达诺结算层中，它以稍微不同的方式实现。生成 R 个范围为 <code>[0 .. totalCoins]</code> 的随机数，这里 <code>R</code> 为一个 epoch 里面的 slot 数量。权益所有人在这个范围内占据不同的部分，这与他们的股权成正比。这样一来，每个随机数据对应权益所有人。另外，正如论文所建议的，使用一个短的（32位）的种子来初始化 PRG，而不是使用 <code>n ⌈log λ⌉</code> 随机位数。</p>\\n<p>请阅读<a href=\\\"/technical/leader-selection/\\\">卡尔达诺结算层领导者选举</a>获得实现细节。</p>\\n<h2>提交，开放，股权发送</h2>\\n<p>发送时间是在一个很小的时间间隔内随机分配的。这样做是为了避免所有投币者同时发送数据时的网络过载。这个时间间隔必须足够小，以保证协议安全。如果这个数据发送得太晚，则可能会发生数据不包含在区块中的情况。</p>\\n<h2>多个权益所有人</h2>\\n<p>在论文中，每个权益所有人都是基本 VSS 模型的参与者。然而，拥有更多股份的权益所有人比秘密共享股份的权益所有人更重要。例如，如果3个诚实的权益所有人控制了总共60%的股份（每个控制20%），并且有40个敌对权益所有人各持有1%的股份，那么对手就完全控制了秘密股份。</p>\\n<p>为了解决这个问题，卡尔达诺结算层为每个利益相关者分配了一定比例的股份。</p>\\n<h2>随机生成失败</h2>\\n<p>论文没有涵盖提交无法恢复的情况。但是，一个现实的实现应该考虑这种情况。如果没有可以收回的提交，卡尔达诺结算层的实现使用由全零组成的种子。</p>\\n<h1>增加的特性</h1>\\n<h2>更新系统</h2>\\n<p>请查阅这篇文章：<a href=\\\"/cardano/update-mechanism/\\\">更新系统</a>.</p>\\n<h2>P2P 的安全性</h2>\\n<p>请查阅这篇文章：<a href=\\\"/technical/protocols/p2p/\\\">P2P 的实现和强化</a>.</p>\\n<h1>遗漏</h1>\\n<p><em>输入背书人</em>和<em>激励结构</em>还没有实现。这些部分将与侧链悬而未决的研究一起实现，并随侧链的发布一起发布。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/differences/\",\"doc_title\":\"论文与实现的区别\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-07-addresses.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层的地址 要发送和接收价值，基本所有加密货币都使用地址。卡尔达诺结算层支持3种类型的地址： 公钥地址 脚本地址 兑换地址 公钥地址在就像其他的加密货币一样，是个正常的，经过哈希的公钥。 脚本地址被用在一个称为『支付脚本 Hash』（P2SH…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<h1>卡尔达诺结算层的地址</h1>\\n<p>要发送和接收价值，基本所有加密货币都使用地址。卡尔达诺结算层支持3种类型的地址：</p>\\n<ol>\\n<li>公钥地址</li>\\n<li>脚本地址</li>\\n<li>兑换地址</li>\\n</ol>\\n<p>公钥地址在就像其他的加密货币一样，是个正常的，经过哈希的公钥。</p>\\n<p>脚本地址被用在一个称为『支付脚本 Hash』（P2SH）的交易中。它会自动运作，就像银行里的存款一样：你可以向它汇款，但为了兑换这笔钱你必须满足一些特定的条件，条件由于地址相关的脚本决定。地址本身包含着序列化脚本的哈希值。请阅读下面的 <a href=\\\"#pay-to-script-hash\\\">P2SH</a> 获取更多信息。</p>\\n<p>赎回地址是 ADA 赎回的一种特殊地址类型。</p>\\n<p>不仅如此，卡尔达诺结算层还支持 <code>Unknown</code> 地址类型。这种类型可以允许我们在未来使用自定义的地址类型。</p>\\n<h2>地址看起来像什么？</h2>\\n<p>地址是 <code>base58</code> 编码的字符串，例如：</p>\\n<pre><code>Ae2tdPwUPEZKmwoy3AU3cXb5Chnasj6mvVNxV1H11997q3VW5ihbSfQwGpm\\n</code></pre>\\n<h3>编码</h3>\\n<p><code>base58</code> 编码也是比特币中使用的编码。它使用58个符号的字母表来对数据进行编码，这也是它名字的由来。下面就是我们使用的字母表：</p>\\n<pre><code>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\n</code></pre>\\n<p>它去除了非字母数字字符和显示时看起来模棱两可的字母（<code>0</code>, <code>O</code>, <code>I</code>, <code>l</code>）；因此它适用于手动输入数据，从可视化的源代码复制数据的普通用户，并且允许通过双击来简单的拷贝和粘贴，不过双击通常会选择整个字符串。</p>\\n<h2>公钥地址</h2>\\n<p>就像<a href=\\\"/introduction/#you-own-your-money\\\">介绍</a>章节提到的，在用户界面你看到钱包就代表着在这个特定的钱包中你拥有可以花费这笔钱的私钥。但是这样的花销是如何被网络验证，你又如何接收到别人支付给你的钱呢？答案就是跟控制你钱包价值的私钥一起产生的一个公钥。这个公共的部分即指可以被任何人知道，因此叫做『公钥』。</p>\\n<p>一个公钥的地址包含了公钥的哈希值。</p>\\n<p>公钥同时用来在你创建一个交易或其他辅助用途的时候验证你的身份。</p>\\n<h2>P2SH</h2>\\n<p>P2SH 的思想是为花费制定复杂的规则提供很大的灵活性。与发送一笔交易到公钥地址不同，我们创建一个验证脚本，该脚本使用赎回脚本当做参数。为了赎回里面的资金，我们发送一个赎回请求给验证器，然后开始计算。如果计算结果是 <code>success</code>, 钱就会被汇到指定的赎回者那里，否则的话什么都不会发生。</p>\\n<p>引用一下比特币 WiKi：</p>\\n<blockquote>\\n<p>使用 P2SH，你可以将比特币打给一个用多种不常见的方法保护着的地址，不用知道关于该地址安全设置的任何详细信息。接收者可能需要多个人的签名，或一个密码，或一个非常独特的要求才能使用这些比特币。</p>\\n</blockquote>\\n<h2>赎回地址</h2>\\n<p>赎回地址就是 P2PKH。这样的地址包含了赎回公钥的哈希值，并且这个钥匙是 <a href=\\\"http://ed25519.cr.yp.to/\\\">Ed25519</a> 公钥。</p>\\n<h2>其他地址类型</h2>\\n<p>在未来，我们可能会用升级的系统来引入其他地址类型。请阅读<a href=\\\"/cardano/update-mechanism/#soft-fork-updates\\\">查看更多</a> 来了解以无缝升级的方式来扩展系统的相关信息。</p>\\n<h2>地址结构</h2>\\n<p>地址由三部分组成</p>\\n<ul>\\n<li>地址根</li>\\n<li>地址属性</li>\\n<li>地址类型</li>\\n</ul>\\n<p>我们可以把地址想象成类似 JSON 的结构，例如：</p>\\n<pre><code>Address {\\n    addrRoot = AbstractHash e63175c654dfd93a9290342a067158dc0f57a1108ddbd8cace3839bd,\\n    addrAttributes = Attributes {\\n        data: AddrAttributes {\\n            aaPkDerivationPath = Nothing,\\n            aaStakeDistribution = BootstrapEraDistr\\n        } \\n    },\\n    addrType = ATPubKey\\n}\\n</code></pre>\\n<p><code>addrRoot</code> 是由 <code>addrType</code>、<code>addrSpendingData</code>、<code>addrAttributes</code> 组成数组的 BLAKE2b-224 哈希值。</p>\\n<p>addrSpendingData 是一个与地址绑定的特殊值，消费在这个地址的币必须是被公开的。例如，对于公钥来说，这个值就包含着公钥。这样一来，在不知道公钥的时候不可能改变地址属性，因为如果属性改变了，整个地址就变成无效的了。</p>\\n<p><code>addrAttributes</code> 包含了每个地址重要的属性：衍生的路径和权益的分配。</p>\\n<p>想要了解更多关于衍生路径的内容请阅读<a href=\\\"https://cardanodocs.com/technical/hd-wallets/\\\">卡尔达诺结算层的 HD 钱包</a>章节。</p>\\n<p>想要了解更多关于权益分配的内容请阅读<a href=\\\"https://cardanodocs.com/cardano/transactions/#stake-distribution\\\">卡尔达诺结算层的转账</a>章节。</p>\\n<p><code>addrType</code> 的值与上面提到的地址类型相对应，在上面的例子中它是一个公钥地址。</p>\\n<h3>长度</h3>\\n<p>地址的长度可能是不同的，地址长度与地址类型和附加数据有关。</p>\\n<p>例如这个地址：</p>\\n<pre><code>Ae2tdPwUPEZKmwoy3AU3cXb5Chnasj6mvVNxV1H11997q3VW5ihbSfQwGpm\\n</code></pre>\\n<p>以及这个地址：</p>\\n<pre><code>4swhHtxKapQbj3TZEipgtp7NQzcRWDYqCxXYoPQWjGyHmhxS1w1TjUEszCQT1sQucGwmPQMYdv1FYs3d51KgoubviPBf\\n</code></pre>\\n<p>都是公钥地址。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/addresses/\",\"doc_title\":\"地址\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-13-balance-and-stake.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层的余额和权益是怎么运行的 卡尔达诺结算层中有两个重要的概念：余额和权益。这一章将解释着两个概念的差异。 余额 余额是用户真实拥有的币数。当你在计算机上安装了代达罗斯钱包，执行  Ada 兑换 流程时，您会收到一定数量的 Ada 币。这个 Ada…\",\"html\":\"<!-- Reviewed at e070e675764738b5190b2f93424de403f1937216 -->\\n<h1>卡尔达诺结算层的余额和权益是怎么运行的</h1>\\n<p>卡尔达诺结算层中有两个重要的概念：余额和权益。这一章将解释着两个概念的差异。</p>\\n<h3>余额</h3>\\n<p>余额是用户真实拥有的币数。当你在计算机上安装了代达罗斯钱包，执行 <a href=\\\"/timeline/bootstrap/\\\">Ada 兑换</a>流程时，您会收到一定数量的 Ada 币。这个 Ada 币的数量称为你的余额，您可以向其他用户发送一定数量的 Ada 币（在此余额内），也可以从其他用户接收任意数量的 Ada 币。</p>\\n<p>因此，当我们谈到余额时，我们讨论的是用户的实际资金。</p>\\n<h3>权益</h3>\\n<p>与余额（拥有的实际数额）不同，权益是卡尔达诺结算层整个金融系统的关键因素。权益让用户能够控制各种卡尔达诺结算层的算法，比如：成为 slot 领导者，在更新系统中投票，参加 MPC/ SSC，这就是为什么卡尔达诺结算层协议中的所有阈值都以权益，而不是余额来表示。</p>\\n<p>因此，当我们谈到权益时，我们正在讨论用户实际控制卡尔达诺结算层的能力。有关权益的更多信息，请参阅<a href=\\\"/glossary/#%E8%AE%BA%E6%96%87\\\">论文</a></p>\\n<h3>余额和权益的关系</h3>\\n<p>卡尔达诺结算层的每一枚币都与余额和权益相关。我们使用<a href=\\\"/cardano/transactions/#design\\\">交易输出</a>将币 <code>C</code> 与用户余额相关联，并且我们使用股权分配将币 <code>C</code> 与用户权益相关联。</p>\\n<p>注意：可以使用权益委派来更改币和股权之间的关联。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/balance-and-stake/\",\"doc_title\":\"余额和权益\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-10-transactions.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层的转账 概要 一个交易（ tx ) 是一组特殊的数据，代表着节点间价值转移的 行为 （从用户的角度来看就是钱包之间价值的转移）。因此，当用户 Alice 汇款给用户 Bob 时，新的交易就产生了。\\n让我们称该交易为  Tx1 ，Alice 钱包下的节点称为  N…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<h1>卡尔达诺结算层的转账</h1>\\n<h2>概要</h2>\\n<p>一个交易（<strong>tx</strong>) 是一组特殊的数据，代表着节点间价值转移的<em>行为</em>（从用户的角度来看就是钱包之间价值的转移）。因此，当用户 Alice 汇款给用户 Bob 时，新的交易就产生了。\\n让我们称该交易为 <code>Tx1</code>，Alice 钱包下的节点称为 <code>N1</code>，Bob 钱包下的节点称为 <code>N2</code>。</p>\\n<p>节点 <code>N1</code> 会执行下面的步骤：</p>\\n<ul>\\n<li>创建一个 <code>Tx1</code> 交易然后用自己的私钥给交易签名。</li>\\n<li>将交易发送给所有节点（也就是相邻节点）。</li>\\n<li>将该交易保存到本地的数据中。</li>\\n</ul>\\n<p><code>N1</code> 的每个相邻节点也会将 <code>Tx1</code> 发送给自己相邻的节点，依次类推。然后某个领导者会将该笔交易放入到账本中的某个区块里面。请注意，如果网络处于高负荷状态，可能需要很长的时间才能让交易真正地加入到某个区块中。</p>\\n<h2>设计</h2>\\n<p>每个交易都包含了一系列的<em>输入</em>和一系列的<em>输出</em>；交易 <code>Tx0</code> 的输出可以被当用来当做其他如 <code>Tx1</code> 交易的输入，以此类推：</p>\\n<pre><code>            Tx0                           Tx1\\n  +----------------------+      +----------------------+\\n  |                      |      |                      |\\n  |  Inputs     Outputs  |      |  Inputs     Outputs  |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | In0  |   | Out0  + |      | | In0  |   | Out0  | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | In1  |   | Out1  | |      | | In1  |   | Out1  | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | ...  |   | ...   | |      | | ..   |   | ...   | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | InN  |   | OutM  | |      | | InN  |   | OutM  | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  |                      |      |                      |\\n  +----------------------+      +----------------------+     ...\\n</code></pre>\\n<p>输入和输出携带着金钱走向的信息：输入告知金钱是从哪里来的，输出告知金钱往哪里去。请注意上面有 N 和 M，是因为实际的情况输入和输出的个数可能并不相同。</p>\\n<p>每个输入包括：</p>\\n<ul>\\n<li>交易 <code>TxN</code> 的 ID，<code>TxN</code> 的输出就是该输入（每笔交易的输出就是另一笔交易的输入）。交易 ID 是一个 BLAKE2b-256 哈希值，就像这样：<code>f9bcbe752aee4512457f1fd350200cf870906b7e6e836688c9a3779645c86c01</code>。  </li>\\n<li>在 <code>TxN</code> 的输出中使用的输出的索引。  </li>\\n</ul>\\n<p>每个输出包括：</p>\\n<ul>\\n<li>节点 <code>N</code> 的地址，该节点就是我们想要发送价值给它的节点。一个地址就是节点 <code>N</code> 的公钥的 BLAKE2b-224 哈希值，大概像这样：<code>1fsAhhf4E1LQDB8agSds8teuD4E7U8JsRESngEX52kinBhi</code>。请阅读<a href=\\\"/cardano/addresses/\\\">卡尔达诺结算层的地址</a>来获取更多信息。</li>\\n<li>我们想要汇款的金额。这是一个64位，无符号的整形数字，最大值为 <code>45000000000000000</code>。</li>\\n</ul>\\n<p>例如：</p>\\n<pre><code>  Tx 891971a4cc31e32..                           Tx f9bcbe752aee4512..\\n------------------------+           +----------------------------------------------+\\n\\\\                       |           |                                              |\\n/        Outputs        |           |       Inputs                  Outputs        |\\n\\\\  +------------------+ |           | +-----------------+     +------------------+ |\\n/  | Out0             | |           | | In0             |     | Out0             | |\\n\\\\  | +--------------+ | |           | | +-------------+ |     | +--------------+ | |\\n/  | | Value        | | |           | | | Tx id       | |     | | Value        | | |\\n\\\\  | | 100 ADA      | | |           | | | 891971a4c.. | |     | | 100 ADA      | | |\\n/  | +--------------+------->>  ------>>+-------------+ |     | +--------------+------->>\\n\\\\  | | Node address | | |           | | | Out index   | |     | | Node address | | |\\n/  | | a00e4bb2..   | | |           | | | 0           | |     | | 88ca7f79..   | | |\\n\\\\  | +--------------+ | |           | | +-------------+ |     | +--------------+ | |\\n/  | ...              | |           | | ...             |     | ...              | |\\n\\\\  +------------------+ |           | +-----------------+     +------------------+ |\\n/                       |           |                                              |\\n------------------------+           +----------------------------------------------+\\n</code></pre>\\n<p>节点 <code>a00e4bb2..</code> 生成交易 <code>f9bcbe752aee4512..</code>，这笔交易告诉我们：</p>\\n<ol>\\n<li>我们想要从地址为 <code>a00e4bb2..</code> 的当前节点发送100 ADA 到地址 <code>88ca7f79..</code> 节点。  </li>\\n<li>这笔钱对应上笔 ID 为 <code>891971a4c..</code> 的交易的第0个输出。</li>\\n</ol>\\n<h2>验证</h2>\\n<p>如上所述，一笔交易的输出会变成另一笔交易的输入。在这种情况下，我们把交易输出称为<em>成交的交易输出</em>。因为它已经是交易 <code>f9bcbe752aee4512..</code> 的输入。</p>\\n<p>但这种成交不会立刻发生，一个<em>还未</em>成为其他交易输入的输出称为<em>未成交的交易输出</em>。为了防止<a href=\\\"https://en.bitcoin.it/wiki/Double-spending\\\">双重支付</a>，只有未成交的输出才能被用来当做其他交易的输入。</p>\\n<p>因此在网络中的每个节点不仅仅接收交易，还会验证它们。为了验证交易，每个节点都必须保持对未成交输出的跟踪，这样就可以验证发布的交易中的输入是未成交的输出。所有未成交的输出叫做 <em>utxo</em>，它也是一个被称为<em>全球状态</em>的特殊键值数据库的一部分。</p>\\n<h2>交易合法性的证明</h2>\\n<p>在卡尔达诺结算层中的每笔交易都有一个证明（也叫做见证）来表明这笔交易是合法的。即使一个输出是一个未成交的输出，我们也应该有权来让它成交。由于一个 <code>TxN</code> 交易可以有多个输入，那么它的见证就包含了 <code>TxN</code> 中所有输入的见证，如果所有的输入都是合法的，<code>TxN</code> 就是合法的。如果某个交易不是合法的，那么网络就会拒绝这笔交易。</p>\\n<p>因为有<a href=\\\"/cardano/addresses/#what-does-an-address-look-like\\\">两种可用的节点地址类型</a>，所以我们使用两种对应版本进行验证：基于公钥的和基于脚本的。</p>\\n<p>例如，基于公钥的验证使用公钥 <code>PK</code> 和交易签名：合法的输入必须使用与 <code>PK</code> 相对应的私钥进行签名。以此来检查这个签名是被接收了还是被拒绝了。</p>\\n<p>验证被存储在区块链中，每个人都可以看见，可以查看，单独验证。但经过一段时间后，节点为了节省空间可能会删除老的证明。分开存储交易和证明被称为『隔离见证』（你可能听到过它，最近在<a href=\\\"https://bitcoincore.org/en/2016/01/26/segwit-benefits/\\\">比特币中实现</a>了）。在这种策略下，交易和证明被存储在两个不同的地方，并且可以独立地进行处理。</p>\\n<h2>权益分配</h2>\\n<p>权益分配是卡尔达诺结算层另一个组成部分，虽然和委派没有直接关系，但都可以通过它来获取相应的利润分红。</p>\\n<p>有些地址有多个拥有者，这也产生了一个权益计算的问题。因为追随中本聪算法的每个币对于每个股东的总权益而言只能计数一次。与余额（余额中的真实币数）不同，权益赋予用户控制算法不同部分的权利：成为领导者、投票更新系统、参加 MPC/SSC。</p>\\n<p>权益分配关联了每个地址的值。技术上来说该值是地址属性的一部分，该值对应于下面三种情况的某一种：</p>\\n<ol>\\n<li>Bootstrap 时代分配。这是一个特殊的值，它是 Bootstrap 时代里的受托者，但是它在 Bootstrap 时代之后还可以使用。 </li>\\n<li>单密钥分配，这是指所有的权益会被分配给一个指定的股东。在这种分配情况下会包含股东的身份。\\n3。 多个密钥分配，这是指权益会被分配给多个股东（至少两个）。在这种分配情况下包含了一对『股东身份-输出部分』的信息。交易的输出有一个值，该值的一部分就是权益。</li>\\n</ol>\\n<p><a href=\\\"http://cardanodocs.com/technical/leader-selection/cn\\\">领导者选举过程</a>和富人计算两者都考虑了权益分配。</p>\\n<p>这个特性可以以类似的方式用在<a href=\\\"http://cardanodocs.com/technical/delegation/cn\\\">委派</a>中，但是有点区别：</p>\\n<ol>\\n<li>没有凭证。要撤销委派 <code>A</code> 必须移动资金，提供不同的权益分配。  </li>\\n<li><code>A</code> 的部分权益可以通过分配来委托。相反的是，委托需要你同时委托全部地址的资金。</li>\\n</ol>\",\"frontmatter\":{\"path\":\"/cn/cardano/transactions/\",\"doc_title\":\"转账\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-16-updating.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"更新研究概览 在更新机制研究中，我们设法提出了一个更新系统，它能够进行不影响生产环境的，几乎无缝的软件更新，并为权益所有人提供投票选择硬分叉（向后不兼容的协议更新）的选项，无需引入任何非协议级别的工具。 我们建议使用权益来对软硬分叉进行投票。 更新系统模型 对于 CSL…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<!-- Updated at 6b5eda44e5942599a9781e5ad3f51eb820665b83 -->\\n<h1>更新研究概览</h1>\\n<p>在更新机制研究中，我们设法提出了一个更新系统，它能够进行不影响生产环境的，几乎无缝的软件更新，并为权益所有人提供投票选择硬分叉（向后不兼容的协议更新）的选项，无需引入任何非协议级别的工具。</p>\\n<p>我们建议使用权益来对软硬分叉进行投票。</p>\\n<h2>更新系统模型</h2>\\n<p>对于 CSL，我们决定在协议层本身增加对协议更新的支持。它给区块链处理带来了一些开销，但有几个重要的好处：</p>\\n<ol>\\n<li>对于每个实现该协议的用户，其最新版本的区块链是已知的。</li>\\n<li>没有中央实体负责维护或分发更新，任何此类更新都是在大多数权益的默认或明确同意下提出的，然后以分布式的方式分发。</li>\\n<li>我们不依赖客户及时更新 PC 上的软件；这是自动完成的，更新通过区块链直接发布。</li>\\n<li>如果在某些版本的 CSL 协议或某些特定实现中检查到任何安全漏洞，将会有一种机制来快速分发更新（仍然在大多数权益的同意下）</li>\\n</ol>\\n<h2>应用程序更新：签署和宣布</h2>\\n<p>这里，我们考虑如何安全地更新应用。协议更新是本文档相关部分涵盖的一个独立问题。</p>\\n<p>要进行更新，首先需要批准其提案。至少有一个协议达成，更新提案才能通过。</p>\\n<ol>\\n<li><strong>明确通过</strong>：它拥有权益的大部分肯定投票（即严格大于 50%）。</li>\\n<li><strong>隐式通过</strong>：权益的肯定投票大于否定投票，并且至少在 <code>U</code> 个 slot 的区块链中。</li>\\n</ol>\\n<p>这个方法似乎自然地适用于 CSL 模型，就像 PoS 加密货币一样。每个权益相关者都负责按照他们股权的相对比例维护系统，区块链则通过权益所有人之间的共识来维持。</p>\\n<p>软件更新也是这个维护过程的一部分，所以权益相关者应该考虑这个可信更新。</p>\\n<h3>隐式通过</h3>\\n<p>权益所有人负责系统更新的事实并不会限制我们每个更新都需要大部分股权签名的系统。我们可以介绍一个<strong>隐式通过</strong>的概念。</p>\\n<p>更新必须至少有在区块链发布的权益签名的最小限度（<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/e26ad11397c87ce8b00f2a26d5e237f54d6ea90a/lib/configuration.yaml\\\">configuration.yaml</a> 中的 <code>updateProposalThd</code>）。权益所有人签署更新是不够的，他们应该赞成或反对。</p>\\n<h3>接入第三方客户</h3>\\n<p>IOHK 将维护一个唯一的官方客户端。但社区维护的第三方客户端也有生存空间。人们需要从权益所有人收集足够多签名来发布他们的系统更新，当然也有可能不是一个『更新』，而是一个从头开始的不同的客户端，或者是官方客户端的一个分支。只要这个更新有足够多的权益所有人的签名，网络就认为它是可信的，可以通过与官方客户端相同的机制进行更新。</p>\\n<h2>应用更新：分发和应用</h2>\\n<p>IOHK 维护的一系列 HTTP 的镜像足够作为开始。</p>\\n<p>在这个过程中，我们计划维护一个基于 Bittorrent 的，或类似 Bittorrent 的解决方案来分发更新。总的来说，基于法律上的考虑，P2P 分发更新是一个至关重要的业务需求。这决定我们将使用哪种类似于 Bittorrent 的解决方案。</p>\\n<p>此外，有趣的是，更新本身并不需要安全且可信的通道来分发，因为它已经预先知道了一些已知的可信密钥（或一组密钥）。</p>\\n<p>应用更新通过 <a href=\\\"https://github.com/mendsley/bsdiff\\\">bsdiff</a> 准备，可以直接或通过安装程序更新。我们正在考虑将来转移到 <a href=\\\"http://dev.chromium.org/developers/design-documents/software-updates-courgette\\\">courgette</a>。</p>\\n<h2>协议更新</h2>\\n<p>首先，我们需要区分软硬协议更新。</p>\\n<p>软分叉会修改区块链共识规则，以便新版本仍然与旧版本客户端兼容，硬分叉则不会与旧版本保持向前兼容。</p>\\n<p><a href=\\\"https://github.com/bitcoin/bips/blob/ed283b05b332b85b6fd683be3a5d73fab6c15554/bip-0099.mediawiki\\\">BIP-99</a> 提供了很好的标准来区分这两种分叉。</p>\\n<ul>\\n<li>一个<strong>软分叉</strong>引入新的规则，对区块进行限制。这样一来，之前无效的仍然无效，而之前有效的一些区块也会变成无效。 </li>\\n<li>硬分叉是一个让之前无效区块变成有效的分叉。</li>\\n</ul>\\n<p>软分叉具有向后兼容等部署优势，不需要大家的共识，因为大多数用户可以添加新的规则。相比之下，硬分叉需要所有用户升级。</p>\\n<p>理论上，硬分叉可能会导致网络分裂为两个部分的情况，每部分都维护一个单独的链：一个来自采用最新系统更新的节点，另一个则来自拒绝这样做的节点。这意味着第一部分的一些区块被另一部分认为是无效的，反之亦然。</p>\\n<p>我们将<strong>协议版本定义为一个元组 <code>(Maj, Min, Alt)</code></strong>：</p>\\n<ul>\\n<li>主版本号（2字节）：很少修改，改变不是向后兼容的，会产生一个硬分叉。</li>\\n<li>\\n<p>次版本号（2字节）：每个更新需要调整的整数</p>\\n<ul>\\n<li>更新应该是向后兼容的，因为新版本生成的区块应该被旧版本以某种方式接受。</li>\\n<li>一个特定的区块可能包含未知类型的地址。对于这种情况，应该找到一个简洁的解决方法，以免影响系统的稳定性和正确性。</li>\\n</ul>\\n</li>\\n<li>替代版本（1字节）：管理多个同时存在的协议更新版本。</li>\\n</ul>\\n<p>协议版本将在应用程序更新中公布，稍后将放入到由更新的软件创建的每个区块中。</p>\\n<p>主版本号的改变会在将来触发硬分叉的问题。</p>\\n<p>次版本的版本更新通知网络后续应用程序更新修改了软分叉的协议。</p>\\n<p>替代版本是新功能的标志。它允许独立开发人员向协议引入多个更改。例如，如果一个供应商决定经由软分叉引入特性 X，另一个引入特性 Y（经过软分叉），他们的软件将以版本 <code>a.b.X</code> 和版本 <code>a.b.Y</code> 生成区块，其可以在区块链上共存，但是，最终只有一个会被采纳。</p>\\n<h2>软分叉更新</h2>\\n<p>在软分叉中，我们可以做什么，不可以做什么，有一条细线：</p>\\n<ol>\\n<li>老版本的客户端应该总是能找到最近的有效区块。（这是 <a href=\\\"https://github.com/bitcoin/bips/blob/ed283b05b332b85b6fd683be3a5d73fab6c15554/bip-0099.mediawiki\\\">BIP-99</a> 所说的『一些无效仍然无效』）</li>\\n<li>较旧版本的客户端发出的某些模块可能会被认为是无效的。</li>\\n</ol>\\n<p>显然，强行推行规则2可能会导致网络分为两部分：一个权益所有人的股份足够大，可以更新，维护自己的链，拒绝其他链，但其他权益所有人还是能够维持链，拒绝这个权益所有人的区块（因为他没有占多数的股份，因此不能追上其他人，所以他的链更短）。一个简单的解决方案规则可能是这样的：如果最新的2016个区块有95%具有较新的区块版本，则旧版本会被拒绝。</p>\\n<p><strong>注意</strong>：此处和之后的<strong>区块版本</strong>和协议版本具有相同的含义。</p>\\n<p>为什么我们想在某个时刻想让某个块版本无效这一点可能不是很清楚。这里关键的一点是，一个新的功能实际上是对我们之前所做的一个限制。例如，目前我们可能有基于公钥或基于脚本的普通旧提交。然后在某个时候，我们决定包含第三种地址类型（不管目的是什么）。我们使用哪种策略来验证具有未知类型地址的提交的区块？显然唯一的选择是不验证这个地址。</p>\\n<p>想象有人提出一个交易到这个地址，可能这么做是带着满足一些条件之前保障资金的意图，一旦条件满足，它们在版本1上的区块花费了其他交易，这是关键的一点。如果网络没有假定旧版本被启用了（因为我们只能在启用旧版本时开始拒绝区块），我们就不能使用限制。（TODO)</p>\\n<p>我们也不能接受所有高于目前所采用的区块的区块，因为在我们的实现中，每个区块都有一个专门用于存储辅助信息的字段。攻击者可以生成她使用了更高版本的协议，并生成一个 <code>attributes</code> 被无意义密钥污染的区块。如果我们接受它，它会使我们的区块链变得臃肿。</p>\\n<p>这是下面要描述的逻辑的动机。</p>\\n<p>在我们实现中，区块版本可以以下面的状态存在：</p>\\n<ul>\\n<li><strong>已采用</strong>，确认区块版本的软分叉规则被触发了（见下文）</li>\\n<li><strong>已确认</strong>，当有包含软件的确认版本和此区块版本的更新提案时。注意，『软件的确认版本』是<a href=\\\"/cardano/update-mechanism/#soft-fork-updates\\\">其他地方</a>的技术术语。如果有多个区块版本，相应的软件被确认，但这些版本不被采用，我们称之为竞争。举例来说，有可能有版本 <code>2.0.0</code>, <code>2.0.1</code>, <code>1.2.0</code>, <code>1.2.1</code>, <code>1.1.1</code> 和 <code>1.1.2</code>，最后通过的版本是 <code>1.1.3</code>。在这种情况，那些竞争的版本是 <code>2.0.0</code>, <code>2.0.1</code>, <code>1.2.0</code> 和 <code>1.2.1</code>。旧版本 <code>1.1.1</code> 和 <code>1.1.2</code> 没有竞争，因为 <code>1.1.3</code> 已经被采纳。</li>\\n<li>其他情况。举例来说，提出一个新的区块版本，但软件版本没有确认。这种状态没有特殊的名字。</li>\\n</ul>\\n<p>软分叉的工作原理如下：</p>\\n<ul>\\n<li>非正式的，当一个确定比例的权益以版本 <code>X</code> 创建区块，区块版本变成<em>已采用</em>。</li>\\n<li>正式的，我们做以下事情。首先回顾一下，我们的系统在设计上，不允许回滚超过某个固定的全局阈值 <code>k</code>，这样可以为每个权益所有者确定稳定的股权。当我们处理创始块 <code>e</code> 时，我们从网络的一开始就计算所有 slot 的所有领导者的稳定股权。对于版本 <code>X</code> 的区块当前竞争的版本，我们取所有版本 <code>X</code> 的稳定版本，收集这些领导者的区块，统计他们的股权。如果其中一个版本大于 75%，则被采纳。如果多于一个版本大于 75%，我们采用其中一个（TODO）。</li>\\n</ul>\\n<p>请注意，采用的区块版本在 epoch 期间（只在 epoch 之间）是不可变的，因此在一个 epoch 中的所有区块都根据相同的规则进行验证（因为规则是由采用的区块版本定义的）。但假设一个 epoch 中的所有区块都具有相同的区块版本是错误的。在采用区块版本之后，另一个区块版本可以竞争，并且一些节点可以使用这个新版本创建区块。</p>\\n<p>所以，总结一下：</p>\\n<ol>\\n<li>一旦确认了更新，协议的版本（比如说 <code>0.5.0</code>）就可以使用了。</li>\\n<li>\\n<p>该节点的行为<em>已</em>被更新（即可以发出，验证新版本的区块）：</p>\\n<ol>\\n<li>在软分叉解决之前（即在解析规则被出发之前），使用新版本 <code>0.5.0</code> 发布区块，但不包括任何新的 <code>attributes</code>（如果有的话）。同区块版本 <code>0.4.0</code> 一样验证 <code>0.5.0</code>。</li>\\n<li>一旦软分叉解决，发布和验证每个版本为 <code>0.5.0</code> 的区块，包括新的 <code>attributes</code></li>\\n</ol>\\n</li>\\n<li>\\n<p>该节点的行为<em>还没有</em>被更新（即不能发出并使用新版本验证模块）：</p>\\n<ol>\\n<li>软分叉解决之前，发行并验证每个版本为 <code>0.4.0</code> 的区块。除此之外，任何包含未知 <code>attributes</code> 的区块都不会被接受</li>\\n<li>一旦软分叉解决，开始接收所有版本为 <code>0.5.0</code> 的区块，包括有未知 <code>attributes</code> 的区块。同时也验证 <code>0.4.0</code> 的版本。</li>\\n</ol>\\n</li>\\n</ol>\\n<h2>硬分叉更新</h2>\\n<p>硬分叉通过修改后的 PoB（proof of burn）来解决。由于尚未实现，我们从本文中省略本节，并将其作为单独的文档发布。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/update-mechanism/\",\"doc_title\":\"更新机制\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-02-transaction-fees.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<h1>卡尔达诺结算层的转账费用</h1>\\n<h2>驱动力</h2>\\n<p>卡尔达诺结算层需要交易费主要因为两个原因：</p>\\n<ol>\\n<li>\\n<p>人们运行卡尔达诺结算层完整节点，需要花费时间、金钱和经历来运行协议，为此他们应得到补偿和奖励。在卡尔达诺结算层中与比特币不同的是，当新货币在每个区块被挖出时，交易费用是协议参与者的唯一收入来源。</p>\\n</li>\\n<li>\\n<p>第二个原因是为了防 DDoS（分布式拒绝服务攻击）。在 DDoS 攻击者，攻击者尝试用虚假交易来冲击网络，如果他必须为每个虚假交易支付足够高的费用，这种攻击形式对于他来说就过于昂贵了。</p>\\n</li>\\n</ol>\\n<h2>交易费用如何运作</h2>\\n<p>每当有人想要转移一定数量的 Ada，这笔转账就会有一个最低的转账费。如果想让这个交易有效，必须包含这笔很小的费用，尽管发送者可以选择支付更高的费用。</p>\\n<p>请阅读<a href=\\\"#transaction-fees-distribution\\\">下面</a>的交易分配方式。</p>\\n<h2>最低转账费</h2>\\n<p>一笔转账的最低费用通过下面的公式计算：</p>\\n<pre><code>a + b × size\\n</code></pre>\\n<p>其中:</p>\\n<ul>\\n<li><code>a</code> 是一个特殊常量，目前是 0.155381 ADA;</li>\\n<li><code>b</code> 是一个特殊常量，目前是 0.000043946 ADA/byte;</li>\\n<li><code>size</code> 是以字节为单位的转账数据大小</li>\\n</ul>\\n<p>这意味着每笔交易至少需要 0.155381 ADA, 每字节的交易需要额外的 0.000043946 ADA。例如，大小为200字节（相当典型的大小）的转账费用是：</p>\\n<pre><code>0.155381 ADA + 0.000043946 ADA/byte × 200 byte = 0.1641702 ADA.\\n</code></pre>\\n<p>有参数 <code>a</code> 的原因是为了防止上面提到的 DDoS 攻击：即使是非常小的虚假交易也要花费足够的代价，以此来防止试图产生成千上万交易的攻击者。</p>\\n<p>引入参数 <code>b</code> 用来反映实际成本：存储更大的交易比存储更小的交易需要更多计算机内存，因此数据量更大的交易应该比数据量小的交易收费更贵。</p>\\n<p>虽然是通过特定参数 <code>a</code> 和 <code>b</code> 计算的，这些值可能会在未来进行调整，以更好地反映实际成本。</p>\\n<h2>交易分配方式</h2>\\n<p>在一个特定 <a href=\\\"http://cardanodocs.com/glossary/cn/#epoch\\\">epoch</a> 中产生的交易费用会被收集到一个虚拟池里，然后将这个池里的资金重新分配给由 PoS 算法选举的那些 <a href=\\\"https://cardanodocs.com/glossary/cn/#slot-leader\\\">slot 领导者</a>。</p>\\n<p>在卡尔达诺结算层这个阶段，所有的区块都是有 IOHK 以及我们的合作伙伴运行的节点创建的，收集了费用（为了防止 DDoS 攻击），但它们不会被重新分配，而是被销毁。</p>\\n<p>不久，卡尔达诺结算层进入下一个阶段，<a href=\\\"https://cardanoroadmap.com/\\\">完全分布式阶段</a>后，费用会按如上所述分配。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/transaction-fees/\",\"doc_title\":\"转账费用\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-19-topology.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层网络拓扑 这一篇是卡尔达诺结算层网络拓扑的概述 节点组 虽然卡尔达诺结算层被设计，实现为一个分布式网络，为了防 DDoS…\",\"html\":\"<!-- Reviewed at ba744590c89d8ffa6d6f0919ec11f52202a6d8f2 -->\\n<h1>卡尔达诺结算层网络拓扑</h1>\\n<p>这一篇是卡尔达诺结算层网络拓扑的概述</p>\\n<h2>节点组</h2>\\n<p>虽然卡尔达诺结算层被设计，实现为一个分布式网络，为了防 DDoS，卡尔达诺结算层的实现和拓扑加入了一些额外的功能。当前所有的节点被分为三组：</p>\\n<ul>\\n<li>核心组</li>\\n<li>中继组</li>\\n<li>边缘组</li>\\n</ul>\\n<p>让我们分别讲解一下每组的节点。</p>\\n<h3>核心节点</h3>\\n<p>核心节点是最重要的。</p>\\n<p>就像<a href=\\\"/timeline/bootstrap/#stake-locking\\\">这里</a>描述的, 在 Byron 版本中，我们将会把权益高效地锁定在核心节点联盟上。只有很少的节点能够成为<a href=\\\"/glossary/#slot-leader\\\">领导者</a>，所以只有这些节点能够在这个时期生成新区块。这是网络核心节点能够很好的运行和维护区块链的精髓所在。我们还为核心节点提供了更高的安全级别：我们把它们放在中介节点的中间，因此核心节点与公有网络隔离，并且只允许中继节点和核心节点进行同学。这就是我们减少核心节点被攻击的方法。</p>\\n<p>请注意核心节点永远不会创建货币交易（只有边缘节点可以创建，请看下文）。</p>\\n<h3>中继节点</h3>\\n<p>你可以将中继节点想象为核心节点和公有网络的代理。</p>\\n<p>因为中继节点是不隔离的，所以它们可以被攻击，原则上它们没有状态而且没有权益，所以它们可以被移除，也可以增加数量。如果中继节点崩溃了，会导致拒绝服务，但核心节点（和区块链）的完整性不会受影响。</p>\\n<p>由于中继节点没有任何权益，所以它们不能成为领导者。不仅如此，它们也不能创建货币交易。</p>\\n<p>中继节点是完全被初始股东联合会控制的。</p>\\n<h3>边缘节点</h3>\\n<p>边缘节点是最简单的节点，每个人都可以在自己的电脑上运行边缘节点，只有这些节点可以创建货币交易。</p>\\n<p>由于边缘节点没有任何的权益，它们同中继节点一样不能成为领导者，此外，边缘节点不能直接与核心节点通信，只能与中继节点以及其他边缘节点进行通信。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/topology/\",\"doc_title\":\"拓扑\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-01-monetary-policy.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺货币政策 ADA 币在卡尔达诺协议发布时发行 启动期间的销售，卖出了 25,927,070,538 个 Ada 币。5,185,414,108 个 ADA 币，相当于所售 ADA 数量的 20%，生成并分发给组成卡尔达诺技术和业务生态系统的三个实体： IOHK…\",\"html\":\"<!-- Reviewed at 1bd2a2f5979233f4f50a7e66ab4e1819ac486400 -->\\n<h1>卡尔达诺货币政策</h1>\\n<div style=\\\"border-radius:5px;padding:5px 10px;background: #cdeffc;\\\" markdown=\\\"1\\\">\\n<h3>ADA 币在卡尔达诺协议发布时发行</h3>\\n<p>启动期间的销售，卖出了 25,927,070,538 个 Ada 币。5,185,414,108 个 ADA 币，相当于所售 ADA 数量的 20%，生成并分发给组成卡尔达诺技术和业务生态系统的三个实体：<a href=\\\"https://iohk.io\\\">IOHK</a>, <a href=\\\"http://emurgo.io/\\\">Emurgo</a> 以及 <a href=\\\"https://cardanofoundation.org/\\\">卡尔达诺基金会</a>。因此 ADA 发布时的总量是 31,112,484,646 个。</p>\\n<h3>ADA 供给量</h3>\\n<p>Ada 币以 45,000,000,000 或者说 450 亿封顶。</p>\\n<h3>卡尔达诺协议运行期间发行的 ADA 币</h3>\\n<p>剩余的 13,887,515,354 个 ADA 币，将在铸币的过程中发行。</p>\\n<p>注意：ADA 的数量永远不会超过 45,000,000,000</p>\\n</div>\\n<h2>财政和费用</h2>\\n<div style=\\\"border-radius:5px;padding:5px 10px;background: #cdeffc;\\\" markdown=\\\"1\\\">\\n这一章将概述财政政策和相关费用。\\n<h3>启动阶段 (发行)</h3>\\n<p>卡尔达诺正处于启动阶段。在这个阶段，交易费没有被收集起来，没有 ADA 被铸造。这一时期的费用会在未来被收集然后他们就会被销毁。</p>\\n<h3>国库</h3>\\n<p>卡尔达诺将有一个国库。这个国库由部分（还没决定）新铸造的 ADA 币以及转账费用捐赠。国库为 ADA 持有者所有。</p>\\n<h3>最小费用 (当前计算方式)</h3>\\n<p>最小费用 = 0.155381 ADA + 0.000043946 (ADA/字节) x 转账数据大小</p>\\n<p>费用计算和激励措施仍在研究中。</p>\\n<h3>面额</h3>\\n<ul>\\n<li>1 ADA = 1,000,000 Lovelaces</li>\\n<li>1 Lovelace = 1/1,000,000 Ada</li>\\n<li>Ada 有6个小数点</li>\\n<li>1.000000 = 1 ADA</li>\\n<li>0.000001 = 1 Lovelace</li>\\n</ul>\\n<p>在货币单位方面有两点考虑。首先在日本，日元面额要大得多，10000 日元相当于 100美元，相当于250亿 ADA 对应 两亿五千万。第二点，与比特币的8位小数不同，ADA 有6位小数，一个 ADA 有100万个 Lovelaces（最小单位）。Adjusting for this takes you to 2.5 million. (TODO)</p>\\n</div>\",\"frontmatter\":{\"path\":\"/cn/cardano/monetary-policy/\",\"doc_title\":\"货币政策\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-05-explorer.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺运算层浏览器 这是卡尔达诺浏览器服务的概述 (下文称作『浏览器』). 浏览器是一个搜索卡尔达诺网络中的地址，转账，epochs，slots 信息的 在线服务 地址 找到一个用户的地址信息是有可能的。在得到一个 hash…\",\"html\":\"<!-- Reviewed at dec0d911d6c4beb8e708ed4076f832ff871f6125 -->\\n<h1>卡尔达诺运算层浏览器</h1>\\n<p>这是卡尔达诺浏览器服务的概述 (下文称作『浏览器』).</p>\\n<p>浏览器是一个搜索卡尔达诺网络中的地址，转账，epochs，slots 信息的<a href=\\\"https://cardanoexplorer.com/\\\">在线服务</a></p>\\n<h2>地址</h2>\\n<p>找到一个用户的地址信息是有可能的。在得到一个 hash 地址后，我们将看到：</p>\\n<ol>\\n<li>与这个地址有关的交易数量</li>\\n<li>这个地址的最终余额</li>\\n<li>这个地址的 QR 码</li>\\n</ol>\\n<p>Hash 地址的例子: <code>1fhXcTriF8i8FFSdCTaU9d3yp3oCLFQhon5KBkevT8rQDPP</code>.</p>\\n<h2>转账</h2>\\n<p>我们可以找到转账的相关信息。在得到一个交易 ID 后，我们将看到：</p>\\n<ol>\\n<li>交易日期和时间</li>\\n<li>交易的来源地址</li>\\n<li>交易的目标地址</li>\\n<li>这次交易转移的 ADA 金额</li>\\n<li>手续费</li>\\n</ol>\\n<p>交易 ID 的例子:</p>\\n<p><code>fe0681c7fe20c27071befc329caac059bb183afaf68b9595744c52125c61cf68</code>.</p>\\n<h2>时间</h2>\\n<p>我们能找到某个时间点的交易信息。目前只能指定 <a href=\\\"/glossary/#epoch\\\">epoch</a> 和 <a href=\\\"/glossary/#slot\\\">slot</a>，在得到 epoch 和 slot 的索引后，我们将看到：</p>\\n<ol>\\n<li>这个 slot 的交易数</li>\\n<li>在这次 slot 中的转移的 ADA 金额</li>\\n<li>在这个 slot 中产生的区块的大小</li>\\n</ol>\\n<h3>Slot</h3>\\n<p>我们可以找到特定 slot 的相关信息。在得到 slot 的 hash 值之后，我们可以看到：</p>\\n<ol>\\n<li>这个 slot 的交易次数</li>\\n<li>总产值</li>\\n<li>这个 slot 的预计 ADA 数量</li>\\n<li>费用</li>\\n<li>slot 的 ID</li>\\n</ol>\\n<p>此外，我们还能得到散列的信息：</p>\\n<ol>\\n<li>slot 的散列</li>\\n<li>前一个 slot 的散列（如果存在的话）</li>\\n<li>下一个 slot 的散列（如果存在的话）</li>\\n<li>The Merkle root. (TODO)</li>\\n</ol>\",\"frontmatter\":{\"path\":\"/cn/cardano/explorer/\",\"doc_title\":\"浏览器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-03-transaction-assurance.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"交易确认层级 下面的表格基于颜色表示确认层级，以确保交易不会被某些分叉取消。 举个例子，在正常的安全级别，如果攻击者的份额是10％（或600万美元，卡尔达诺市值6000万美元），则用户交易的确认级别是： 最低确认（用红色编码） - 当用户的转账确认数小于…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<style>\\n.full-width {\\n    width: 100%;\\n}\\n\\n.r {\\n    color: white;\\n    background-color: #ef4e4e;\\n    text-align: right;\\n    font-weight: 400;\\n}\\n\\n.y {\\n    color: white;\\n    background-color: #c09e0f;\\n    text-align: right;\\n    font-weight: 400;\\n}\\n\\n.g {\\n    color: white;\\n    background-color: green;\\n    text-align: right;\\n    font-weight: 400;\\n}\\n\\n.gr {\\n    color: white;\\n    background-color: #aaa;\\n    font-weight: 700;\\n}\\n\\n.rd {\\n    background-color: #fca8a8;\\n    text-align: right;\\n    font-weight: 700;\\n}\\n\\n.yd {\\n    background-color: #eccd4a;\\n    text-align: right;\\n    font-weight: 700;\\n}\\n\\n.gd {\\n    background-color: #53d153;\\n    text-align: right;\\n    font-weight: 700;\\n}\\n\\n.center {\\n    text-align: center;\\n}\\n\\n.pct25 {\\n    width: 25%;\\n}\\n</style>\\n<h1>交易确认层级</h1>\\n<p>下面的表格基于颜色表示确认层级，以确保交易不会被某些分叉取消。</p>\\n<p>举个例子，在正常的安全级别，如果攻击者的份额是10％（或600万美元，卡尔达诺市值6000万美元），则用户交易的确认级别是：</p>\\n<ol>\\n<li>最低确认（用红色编码） - 当用户的转账确认数小于<strong>3</strong>个区块时。</li>\\n<li>中等确认（用黄色编码） - 用用户的转账确认数为<strong>3</strong>到<strong>7</strong>块。</li>\\n<li>高度确认（用绿色编码） - 当用户的转账具有<strong>9</strong>个或更多区块的确认时。</li>\\n</ol>\\n<h2>正常安全层级</h2>\\n<p>正常级别可以防攻击（这个模型将包含在最新版本的乌洛波罗斯算法中），表中的数值对应6亿美元的卡尔达诺市值。</p>\\n<table class=\\\"full-width\\\">\\n<tr>\\n    <th class=\\\"center\\\">             攻击者的份额，%</th>\\n    <th class=\\\"center pct25\\\">       攻击者的份额，$ mln </th> \\n    <th colspan=\\\"6\\\" class=\\\"center\\\"> 确认水平         </th>\\n</tr>\\n<tr class=\\\"center\\\">\\n    <td></td>\\n    <td></td>\\n    <td> Low    </td>\\n    <td> 0.950  </td>\\n    <td> 0.990  </td>\\n    <td> 0.995  </td>\\n    <td> 0.999  </td>\\n    <td> High   </td>\\n</tr>\\n<tr>\\n    <td class=\\\"gr\\\"> 10          </td>\\n    <td class=\\\"gr\\\"> 6           </td>\\n    <td class=\\\"rd\\\"> &lt; 3      </td>\\n    <td class=\\\"yd\\\"> 3           </td>\\n    <td class=\\\"yd\\\"> 5           </td>\\n    <td class=\\\"yd\\\"> 7           </td>\\n    <td class=\\\"gd\\\"> 9           </td>\\n    <td class=\\\"gd\\\"> 9 &lt;      </td>\\n</tr>\\n<tr>\\n    <td>            15          </td>\\n    <td>            9           </td>\\n    <td class=\\\"r\\\">  &lt; 5      </td>\\n    <td class=\\\"y\\\">  5           </td>\\n    <td class=\\\"y\\\">  9           </td>\\n    <td class=\\\"y\\\">  11          </td>\\n    <td class=\\\"g\\\">  15          </td>\\n    <td class=\\\"g\\\">  15 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            20          </td>\\n    <td>            12          </td>\\n    <td class=\\\"r\\\">  &lt; 7      </td>\\n    <td class=\\\"y\\\">  7           </td>\\n    <td class=\\\"y\\\">  13          </td>\\n    <td class=\\\"y\\\">  15          </td>\\n    <td class=\\\"g\\\">  21          </td>\\n    <td class=\\\"g\\\">  21 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            25          </td>\\n    <td>            15          </td>\\n    <td class=\\\"r\\\">  &lt; 9      </td>\\n    <td class=\\\"y\\\">  9           </td>\\n    <td class=\\\"y\\\">  19          </td>\\n    <td class=\\\"y\\\">  23          </td>\\n    <td class=\\\"g\\\">  33          </td>\\n    <td class=\\\"g\\\">  33 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            30          </td>\\n    <td>            18          </td>\\n    <td class=\\\"r\\\">  &lt; 17     </td>\\n    <td class=\\\"y\\\">  17          </td>\\n    <td class=\\\"y\\\">  31          </td>\\n    <td class=\\\"y\\\">  39          </td>\\n    <td class=\\\"g\\\">  55          </td>\\n    <td class=\\\"g\\\">  55 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            35          </td>\\n    <td>            21          </td>\\n    <td class=\\\"r\\\">  &lt; 29     </td>\\n    <td class=\\\"y\\\">  29          </td>\\n    <td class=\\\"y\\\">  57          </td>\\n    <td class=\\\"y\\\">  71          </td>\\n    <td class=\\\"g\\\">  101         </td>\\n    <td class=\\\"g\\\">  101 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            40          </td>\\n    <td>            24          </td>\\n    <td class=\\\"r\\\">  &lt; 67     </td>\\n    <td class=\\\"y\\\">  67          </td>\\n    <td class=\\\"y\\\">  133         </td>\\n    <td class=\\\"y\\\">  163         </td>\\n    <td class=\\\"g\\\">  235         </td>\\n    <td class=\\\"g\\\">  235 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            45          </td>\\n    <td>            27          </td>\\n    <td class=\\\"r\\\">  &lt; 269    </td>\\n    <td class=\\\"y\\\">  269         </td>\\n    <td class=\\\"y\\\">  539         </td>\\n    <td class=\\\"y\\\">  661         </td>\\n    <td class=\\\"g\\\">  951         </td>\\n    <td class=\\\"g\\\">  951 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            46          </td>\\n    <td>            27.6        </td>\\n    <td class=\\\"r\\\">  &lt; 421    </td>\\n    <td class=\\\"y\\\">  421         </td>\\n    <td class=\\\"y\\\">  843         </td>\\n    <td class=\\\"y\\\">  1033        </td>\\n    <td class=\\\"g\\\">  1487        </td>\\n    <td class=\\\"g\\\">  1487 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            47          </td>\\n    <td>            28.2        </td>\\n    <td class=\\\"r\\\">  &lt; 751    </td>\\n    <td class=\\\"y\\\">  751         </td>\\n    <td class=\\\"y\\\">  1501        </td>\\n    <td class=\\\"y\\\">  1841        </td>\\n    <td class=\\\"g\\\">  2649        </td>\\n    <td class=\\\"g\\\">  2649 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            48          </td>\\n    <td>            28.8        </td>\\n    <td class=\\\"r\\\">  &lt; 1691   </td>\\n    <td class=\\\"y\\\">  1691        </td>\\n    <td class=\\\"y\\\">  3381        </td>\\n    <td class=\\\"y\\\">  4143        </td>\\n    <td class=\\\"g\\\">  5965        </td>\\n    <td class=\\\"g\\\">  5965 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            49          </td>\\n    <td>            29.4        </td>\\n    <td class=\\\"r\\\">  &lt; 6763   </td>\\n    <td class=\\\"y\\\">  6763        </td>\\n    <td class=\\\"y\\\">  13527       </td>\\n    <td class=\\\"y\\\">  16585       </td>\\n    <td class=\\\"g\\\">  23869       </td>\\n    <td class=\\\"g\\\">  23869 &lt;  </td>\\n</tr>\\n</table>\\n## 严格安全层级\\n<p>严格的安全层级可以防止所有的攻击（它需要更多的块确认）。表中的数值对应6亿美元的卡尔达诺市值。</p>\\n<table class=\\\"full-width\\\">\\n<tr>\\n    <th class=\\\"center\\\">             攻击者的份额，%</th>\\n    <th class=\\\"center pct25\\\">       攻击者的份额，$ mln </th> \\n    <th colspan=\\\"6\\\" class=\\\"center\\\"> 确认水平         </th>\\n</tr>\\n<tr class=\\\"center\\\">\\n    <td></td>\\n    <td></td>\\n    <td> Low    </td>\\n    <td> 0.950  </td>\\n    <td> 0.990  </td>\\n    <td> 0.995  </td>\\n    <td> 0.999  </td>\\n    <td> High   </td>\\n</tr>\\n<tr>\\n    <td class=\\\"gr\\\"> 10          </td>\\n    <td class=\\\"gr\\\"> 6           </td>\\n    <td class=\\\"rd\\\"> &lt; 5      </td>\\n    <td class=\\\"yd\\\"> 5           </td>\\n    <td class=\\\"yd\\\"> 9           </td>\\n    <td class=\\\"yd\\\"> 11          </td>\\n    <td class=\\\"gd\\\"> 15          </td>\\n    <td class=\\\"gd\\\"> 15 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            15          </td>\\n    <td>            9           </td>\\n    <td class=\\\"r\\\">  &lt; 7      </td>\\n    <td class=\\\"y\\\">  7           </td>\\n    <td class=\\\"y\\\">  14          </td>\\n    <td class=\\\"y\\\">  16          </td>\\n    <td class=\\\"g\\\">  23          </td>\\n    <td class=\\\"g\\\">  23 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            20          </td>\\n    <td>            12          </td>\\n    <td class=\\\"r\\\">  &lt; 12     </td>\\n    <td class=\\\"y\\\">  12          </td>\\n    <td class=\\\"y\\\">  21          </td>\\n    <td class=\\\"y\\\">  25          </td>\\n    <td class=\\\"g\\\">  35          </td>\\n    <td class=\\\"g\\\">  35 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            25          </td>\\n    <td>            15          </td>\\n    <td class=\\\"r\\\">  &lt; 19     </td>\\n    <td class=\\\"y\\\">  19          </td>\\n    <td class=\\\"y\\\">  34          </td>\\n    <td class=\\\"y\\\">  40          </td>\\n    <td class=\\\"g\\\">  55          </td>\\n    <td class=\\\"g\\\">  55 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            30          </td>\\n    <td>            18          </td>\\n    <td class=\\\"r\\\">  &lt; 32     </td>\\n    <td class=\\\"y\\\">  32          </td>\\n    <td class=\\\"y\\\">  57          </td>\\n    <td class=\\\"y\\\">  68          </td>\\n    <td class=\\\"g\\\">  94          </td>\\n    <td class=\\\"g\\\">  94 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            35          </td>\\n    <td>            21          </td>\\n    <td class=\\\"r\\\">  &lt; 63     </td>\\n    <td class=\\\"y\\\">  63          </td>\\n    <td class=\\\"y\\\">  111         </td>\\n    <td class=\\\"y\\\">  132         </td>\\n    <td class=\\\"g\\\">  181         </td>\\n    <td class=\\\"g\\\">  181 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            40          </td>\\n    <td>            24          </td>\\n    <td class=\\\"r\\\">  &lt; 157    </td>\\n    <td class=\\\"y\\\">  157         </td>\\n    <td class=\\\"y\\\">  274         </td>\\n    <td class=\\\"y\\\">  325         </td>\\n    <td class=\\\"g\\\">  443         </td>\\n    <td class=\\\"g\\\">  443 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            45          </td>\\n    <td>            27          </td>\\n    <td class=\\\"r\\\">  &lt; 729    </td>\\n    <td class=\\\"y\\\">  729         </td>\\n    <td class=\\\"y\\\">  1246         </td>\\n    <td class=\\\"y\\\">  1470         </td>\\n    <td class=\\\"g\\\">  1990         </td>\\n    <td class=\\\"g\\\">  1990 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            46          </td>\\n    <td>            27.6        </td>\\n    <td class=\\\"r\\\">  &lt; 1190   </td>\\n    <td class=\\\"y\\\">  1190        </td>\\n    <td class=\\\"y\\\">  2020        </td>\\n    <td class=\\\"y\\\">  2379        </td>\\n    <td class=\\\"g\\\">  3214        </td>\\n    <td class=\\\"g\\\">  3214 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            47          </td>\\n    <td>            28.2        </td>\\n    <td class=\\\"r\\\">  &lt; 2230   </td>\\n    <td class=\\\"y\\\">  2230        </td>\\n    <td class=\\\"y\\\">  3758        </td>\\n    <td class=\\\"y\\\">  4418        </td>\\n    <td class=\\\"g\\\">  5953        </td>\\n    <td class=\\\"g\\\">  5953 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            48          </td>\\n    <td>            28.8        </td>\\n    <td class=\\\"r\\\">  &lt; 5382   </td>\\n    <td class=\\\"y\\\">  5382        </td>\\n    <td class=\\\"y\\\">  8986        </td>\\n    <td class=\\\"y\\\">  10542       </td>\\n    <td class=\\\"g\\\">  14157       </td>\\n    <td class=\\\"g\\\">  14157 &lt;  </td>\\n</tr>\\n<tr>\\n    <td>            49          </td>\\n    <td>            29.4        </td>\\n    <td class=\\\"r\\\">  &lt; 24029  </td>\\n    <td class=\\\"y\\\">  24029       </td>\\n    <td class=\\\"y\\\">  39603       </td>\\n    <td class=\\\"y\\\">  46320       </td>\\n    <td class=\\\"g\\\">  61922       </td>\\n    <td class=\\\"g\\\">  61922 &lt;  </td>\\n</tr>\\n</table>\",\"frontmatter\":{\"path\":\"/cn/cardano/transaction-assurance/\",\"doc_title\":\"交易确认层级\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/timeline/2017-01-01-testnet.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at 357ac1f7b4a9f1d98ee7f7bee46e874d7356958f -->\\n<h1>测试网阶段</h1>\\n<p>让社区掌握加密货币，打磨实现，消除可能的缺陷和不稳定性，卡尔达诺测试网络（测试网）是必须的。</p>\\n<p>在测试网阶段，包括奖励机制在内的所有功能都将被激活，任何人都可以从卡尔达诺测试网接口兑换密钥，拿到币。</p>\\n<p>我们鼓励大家下载对应平台的卡尔达诺结算层客户端，从接口获取一些币（我们称它们为 <a href=\\\"/cn/glossary/#lovelace\\\">Lovelace</a>），邀请其他人参与 beta 版本的测试。</p>\\n<p>测试网的结束是卡尔达诺结算层的<a href=\\\"/timeline/bootstrap\\\">发布</a>。</p>\",\"frontmatter\":{\"path\":\"/cn/timeline/testnet/\",\"doc_title\":\"测试网阶段\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"timeline\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/timeline/2017-01-02-bootstrap.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"引导阶段 在卡尔达诺测试网阶段和卡尔达诺结算层发布之后，该网络会在『引导模式』下运行一段时期，称为引导阶段。当购买 Ada…\",\"html\":\"<!-- Reviewed at c23493d7a33a82d559d5bd9d289486795cf6592f -->\\n<h1>引导阶段</h1>\\n<p>在卡尔达诺测试网阶段和卡尔达诺结算层发布之后，该网络会在『引导模式』下运行一段时期，称为引导阶段。当购买 Ada 的人兑换他们的币时，股权将自动被委派给维护网络的可信节点池。在此期间，不会发放任何区块奖励 - 我们将保持网络在线。这是必要的，因为为了协议功能正常，拥有大部分期权的一些权益所有人必须在线，而在网络运行的头几个月，情况并非如此。</p>\\n<p>引导阶段将慢慢进入<a href=\\\"/timeline/reward\\\">奖励阶段</a>，在这期间更新协议将被发布，将为大宗权益所有人提供在云服务器运行的方便选项。</p>\\n<h2>股权锁定</h2>\\n<p>引导阶段存在于卡尔达诺结算层存在的时期，它只允许固定的预定义用户对系统进行控制。这些用户集（引导阶段权益所有人）以及他们各自控制的总权益的比例，在创始区块中定义。</p>\\n<p>引导阶段的目的是为了解决在主网开始的时候，大部分股权可能会脱机（开始时违反协议）的担忧。引导阶段将在网络稳定，并且大部分股权在线时结束。</p>\\n<p>引导阶段之后的下一个阶段被称为<a href=\\\"https://cardanodocs.com/timeline/reward/cn/\\\">奖励阶段</a>，奖励阶段实际上是卡尔达诺结算层作为 PoS 加密货币的『正常』运行模式。</p>\\n<h3>要求</h3>\\n<ol>\\n<li>在引导阶段，卡尔达诺的股权应当被有效地委派给一组固定的密钥 <code>S</code>。</li>\\n<li><code>S</code> = 7</li>\\n<li>股权应该在 <code>s</code> ∈  <code>S</code></li>\\n<li>\\n<p>在引导阶段结束时应该解开股权</p>\\n<ol>\\n<li>Ada 买家能够自己参与协议（或将其权利委派给某个代表 <code>S</code>)。</li>\\n<li>\\n<p>每个 Ada 买方都应该明确声明自己想要控制的股份。</p>\\n<ul>\\n<li>否则，一旦奖励阶段开始，很容易导致在少于大多数股权在线的情况。</li>\\n</ul>\\n</li>\\n<li>在撤销股权行动之前，股权应该仍然由 <code>S</code> 节点控制。</li>\\n</ol>\\n</li>\\n</ol>\\n<h3>提案</h3>\\n<p>现在让我们来看看引导阶段的解决方案：</p>\\n<ol>\\n<li>初始 <code>utxo</code> 包含引导阶段股权所有人的所有股权。初始 <code>utxo</code> 由 <code>(txIn, txOut)</code> 组成，并且每个 <code>txOut</code> 都有一个存有股权分发的地址。所以我们只是以一种将所有币发送给所有股权所有的方式设置分配。</li>\\n<li>引导阶段开始时，用户可以发送更改初始 <code>utxo</code> 的请求。我们为每个交易输出设定股权分配，以将权益分配给引导阶段权益相关者。这有效得使得利益分配是系统不变的。</li>\\n<li>\\n<p>重量级代表团有成因状态。它包含对 <code>(Issuer, ProxySK)</code>，其中 <code>Issuer</code> 是被委托的利益相关者的标识符，<code>ProxySK</code> 是委派的代理密钥。请注意：</p>\\n<ul>\\n<li>代表必须与发行人不同，即不允许撤销；</li>\\n<li>委派人不能成为发行人，即不支持过渡性委派。</li>\\n</ul>\\n</li>\\n<li>当引导阶段结束后，我们禁用股权分配的限制。股权所有人将投票让引导阶段结束：将形成特殊的更新提案，其中一个特定的常量将被适当设置，以触发引导阶段结束的更新提案获得通过。系统的运行方式与引导阶段相同，但用户需要明确说明自己的股份所有权，能承担处理节点的责任。为了获取他的股权，用户应该发送一个交易，指定股权分配的代理密钥（s）。它可能是用户自己拥有的密钥，也可能是某个关键代表（可能是引导阶段股权所有人中的一个或几个）。</li>\\n</ol>\",\"frontmatter\":{\"path\":\"/cn/timeline/bootstrap/\",\"doc_title\":\"引导阶段\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"timeline\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/timeline/2017-01-03-reward.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"奖励阶段 在 引导阶段 之后，奖励阶段将开始。在这个阶段，网络将是完全去中心化，非可信模式。我们预计在这个阶段权益池将会出现，让股权比较少的股民也能获得奖励，因为大股东会让节点时刻保持在线来维护去中心化协议。 系统将会定期收到软件更新，并在不久的将来发布大量新功能。\",\"html\":\"<!-- Reviewed at 357ac1f7b4a9f1d98ee7f7bee46e874d7356958f -->\\n<h1>奖励阶段</h1>\\n<p>在<a href=\\\"/timeline/bootstrap\\\">引导阶段</a>之后，奖励阶段将开始。在这个阶段，网络将是完全去中心化，非可信模式。我们预计在这个阶段权益池将会出现，让股权比较少的股民也能获得奖励，因为大股东会让节点时刻保持在线来维护去中心化协议。</p>\\n<p>系统将会定期收到软件更新，并在不久的将来发布大量新功能。</p>\",\"frontmatter\":{\"path\":\"/cn/timeline/reward/\",\"doc_title\":\"奖励阶段\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"timeline\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-02-launcher.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层启动器 概述 可执行文件  cardano-launcher  是启动卡尔达诺结算层的工具。它实际运行整个卡尔达诺结算层系统（即一个节点，一个钱包）并处理更新。要做到这一点， cardano-launcher  使用两个独立的工具： cardano-node…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺结算层启动器</h1>\\n<h2>概述</h2>\\n<p>可执行文件 <a href=\\\"/technical/cli-options/#cardano-launcher\\\"><code>cardano-launcher</code></a> 是启动卡尔达诺结算层的工具。它实际运行整个卡尔达诺结算层系统（即一个节点，一个钱包）并处理更新。要做到这一点，<a href=\\\"/technical/cli-options/#cardano-launcher\\\"><code>cardano-launcher</code></a> 使用两个独立的工具：<a href=\\\"/technical/cli-options/#cardano-node\\\"><code>cardano-node</code></a> 和 <a href=\\\"https://github.com/input-output-hk/cardano-updater\\\"><code>cardano-updater</code></a>。</p>\\n<p>有关可选项的详细信息，请查阅 <a href=\\\"/technical/cli-options/#cardano-launcher\\\"><code>cardano-launcher</code> 的说明</a>。</p>\\n<h2>场景</h2>\\n<p><code>cardano-launcher</code> 有两种工作场景：客户端场景和服务端场景。如果你在启动过程中用 <code>--wallet</code> 参数提供一个钱包（例如代达罗斯）路径，<code>cardano-node</code> 将在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L178\\\">客户端</a>场景下运行，\\n否则将在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L171\\\">服务端</a>场景下运行。</p>\\n<h3>服务端场景</h3>\\n<p>开始时，有两个步骤：</p>\\n<ol>\\n<li>运行更新程序。</li>\\n<li>运行一个节点。</li>\\n</ol>\\n<p>更新程序的工作<a href=\\\"#%E6%9B%B4%E6%96%B0%E5%99%A8\\\">如下所述</a>。</p>\\n<p>一个节点<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L280\\\">以一个单独的进程运行</a>。之后，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L201\\\">等待，直到节点停止</a>。节点退出后，将检查其退出代码，如果等于 <code>20</code>，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L204\\\">重新启动 launcher</a>，否则我们退出。</p>\\n<p>在退出前日志会<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L207\\\">写入到日志文件</a>。要做到这一点，我们在启动时必须提供两个额外的参数：<code>--report-server</code> 和\\n<code>--node-log</code>。第一个参数定义了收集日志的 URl，第二个参数定义了日志文件的路径。我们将日志<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L343\\\">异步发送到收集日志服务器</a>。请注意 <code>--node-log</code> 参数中的文件必须存在。</p>\\n<h3>客户端场景</h3>\\n<p>当进程开始时，有三个步骤：</p>\\n<ol>\\n<li>运行更新程序。</li>\\n<li>运行一个节点。</li>\\n<li>运行一个钱包。</li>\\n</ol>\\n<p>对于步骤1和2，请参与上面的<a href=\\\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9C%BA%E6%99%AF\\\">服务器场景</a>。</p>\\n<p>钱包<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L227\\\">作为一个独立进程运行</a>。</p>\\n<p>之后，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L228\\\">等待节点或钱包停止</a>。当它停止时，我们会检查它：</p>\\n<ol>\\n<li>如果节点退出了，我们写一条日志（见上面<a href=\\\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9C%BA%E6%99%AF\\\">服务端场景</a>的解释），然后<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L235\\\">等待钱包退出</a>。  </li>\\n<li>如果钱包退出，我们会检查其退出代码，如果它等于 <code>20</code>，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L242\\\">杀死这个节点</a>，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L244\\\">重新启动客户端场景的启动程序</a>。请注意，不会立即杀死这个节点；节点在一定的超时过后才会被终止，其值从上述的 <code>--node-timeout</code> 参数获得。</li>\\n<li>如果钱包退出<em>并且</em>退出码不等于 <code>20</code>，我们立即杀死节点。</li>\\n</ol>\\n<h2>更新器</h2>\\n<p><code>cardano-launcher</code> 另一个非常重要的作用是更新节点。两种场景的公共步骤是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L255\\\">运行更新程序</a>。</p>\\n<p>核心思想非常简单。节点更新是一个特殊的 <code>.tar</code> 存档：它表明节点的旧（当前）版本和新版本之间的区别。这个归档的路径通过 <code>--update-archive</code> 参数获得。\\n因此，<code>cardano-launcher</code> 将该归档应用到该节点，并且在重新启动后可以使用该节点的新版本。</p>\\n<p>请注意，当我们的 <code>cardano-launcher</code> 在客户端场景下运行时，钱包的用户能够看到更新已经准备就绪，并且有两种可能的情况。</p>\\n<p>如果用户<em>同意</em>采用这次更新，钱包立即以退出码 <code>20</code> 退出。在这种情况下，如上所述，启动器重新启动节点并更新应用。</p>\\n<p>如果用户<em>不同意</em>采用这次更新，钱包将继续工作，当时，当它<em>被</em>重新启动（早晚的事情），这个更新<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L223\\\"><em>将</em>被应用</a></p>\\n<p><strong>重要</strong>：更新器同步运行，我们启动它，然后<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L269\\\">等待它完成</a>，如果更新程序<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L271\\\">成功</a>运行，<code>.tar</code> 文件将被删除。</p>\\n<h3>实现概述</h3>\\n<p>有关卡尔达诺结算层更新系统的更多实现细节，请参阅<a href=\\\"/technical/updater/\\\">这一章</a>。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/launcher/\",\"doc_title\":\"卡尔达诺结算层启动器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-06-explorer.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层浏览器 正如之前提到的，浏览器是一个在卡尔达诺网络中搜索卡尔达诺结算层 转账 ， 地址 ，时间区间（ epochs  和  slots ）信息的服务。 浏览器后端工作流 浏览器利用 命令行参数 选项启动。所有支持的选项都可以通过  cardano-explorer…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺结算层浏览器</h1>\\n<p>正如之前提到的，浏览器是一个在卡尔达诺网络中搜索卡尔达诺结算层<a href=\\\"/glossary/#%E8%BD%AC%E8%B4%A6\\\">转账</a>，<a href=\\\"/glossary/#address\\\">地址</a>，时间区间（<a href=\\\"/glossary/#epoch\\\">epochs</a> 和 <a href=\\\"/glossary/#slot\\\">slots</a>）信息的服务。</p>\\n<h2>浏览器后端工作流</h2>\\n<p>浏览器利用<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/explorer/ExplorerOptions.hs#L25\\\">命令行参数</a>选项启动。所有支持的选项都可以通过 <code>cardano-explorer --help</code> 命令查看。</p>\\n<p>然后，浏览器通过 <code>cardano-sl</code> 库运行『<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/explorer/Main.hs#L74\\\">内部节点</a>』。因此我们可以把浏览器当做有着两个<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/explorer/Main.hs#L70\\\">特殊插件</a> <code>explorerPlugin</code>, <code>notifierPlugin</code> 的普通节点。</p>\\n<p>第一个插件用于<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/e343db1def575cc2a47d9168414c22c2599c50e6/src/Pos/Explorer/Web/Api.hs#L25\\\">浏览器 web API</a>，第二个启动<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/e343db1def575cc2a47d9168414c22c2599c50e6/src/Pos/Explorer/Socket/App.hs#L164\\\">通知服务器</a>，这个基于 websocket 的服务器通知前端关于区块/转账的修改。</p>\\n<h2>浏览器后端 API</h2>\\n<p>目前，浏览器后端 Web API 提供了一系列从卡尔达诺网络获取信息的方法。<code>servant</code> 库提供了很多构建 API 的方法模块。该库使用组合器来构建 HTTP 原子操作，并将这些原子方法组合在一起形成更大，更完整的 API。</p>\\n<h3>HTTP API</h3>\\n<p>浏览器 web api 在<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/Pos/Explorer/Web/Api.hs#L25\\\">这里</a>定义。如果事件请求失败，则有一个 <a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/Pos/Explorer/Web/Error.hs#L11\\\"><code>ExplorerError</code></a> 类型，它简单地封装在 <code>Text</code> 里面，以显示发生了什么。</p>\\n<p>浏览器 Web API 的文档可以在<a href=\\\"https://cardanodocs.com/technical/explorer/api/\\\">这里</a>找到。</p>\\n<h3>socket.io API</h3>\\n<p>目前我们有这些事件客户可以订阅到：</p>\\n<pre><code class=\\\"language-haskell\\\">data ClientEvent\\n    = Subscribe Subscription\\n    | Unsubscribe Subscription\\n    | CallMe\\n</code></pre>\\n<p>订阅可以是以下事件：</p>\\n<pre><code class=\\\"language-haskell\\\">data Subscription\\n    = SubAddr\\n    | SubBlockLastPage\\n    | SubTx\\n</code></pre>\\n<p>相应的服务器事件是：</p>\\n<pre><code class=\\\"language-haskell\\\">data ServerEvent\\n    = AddrUpdated\\n    | BlocksLastPageUpdated\\n    | TxsUpdated\\n    | CallYou\\n</code></pre>\\n<p>用户可以调用所需的事件并订阅它们：</p>\\n<pre><code class=\\\"language-js\\\">var client = require('socket.io-client');\\nvar socket = client('http://localhost:8110');\\n\\nsocket.on('CallYou', function(msg){ console.log(msg); })\\nsocket.emit('CallMe', 'test');\\n</code></pre>\\n<p>你也可以尝试运行 purescript repl（<code>pulp psci</code> ），尝试一下事件：</p>\\n<pre><code class=\\\"language-purescript\\\">import Prelude\\nimport Control.SocketIO.Client\\nimport Control.Monad.Eff.Console\\n\\nlet socket = connect \\\"http://localhost:8110\\\"\\n\\nsocket >>= \\\\soc -> emit soc \\\"CallYou\\\" \\\"test\\\"\\n</code></pre>\",\"frontmatter\":{\"path\":\"/cn/technical/explorer/\",\"doc_title\":\"卡尔达诺结算层浏览器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-02-14-leader-selection.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层中的领导者选举 这一章描述 领导者 选举过程。 追随中本聪算法 如 前 所述，卡尔达诺结算层使用追随中本聪算法（FTS）来选择领导者。每个当前 epoch 的领导者在当前 epoch 开始的时候，由 FTS…\",\"html\":\"<!-- Reviewed at e1d0f9fb37a3f1378341716916f0321fb55698df -->\\n<h1>卡尔达诺结算层中的领导者选举</h1>\\n<p>这一章描述<a href=\\\"/glossary/#slot-leader\\\">领导者</a>选举过程。</p>\\n<h2>追随中本聪算法</h2>\\n<p>如<a href=\\\"/cardano/proof-of-stake/#follow-the-satoshi\\\">前</a>所述，卡尔达诺结算层使用追随中本聪算法（FTS）来选择领导者。每个当前 epoch 的领导者在当前 epoch 开始的时候，由 FTS 算法计算得出。所以创始区块包含一组领导者列表。领导者的数量和 epoch 的 slot 数量是一致的，这个数量<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/5f7b619c6ec9056c6fe778d862c426233af165df/core/Pos/Core/Constants/Raw.hs#L136\\\">取决</a>于在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/constants.yaml#L10\\\">配置文件</a>中定义的基本安全参数 <code>K</code>。</p>\\n<p>FTS 使用<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/Pos/Core/Types.hs#L256\\\">共享种子</a>，该<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/Pos/Core/Types.hs#L256\\\">共享种子</a>为上个 epoch 计算的结果：在 MPC 的结果中的一些节点会揭露它们的种子，这些种子的 XOR 就被称为共享种子，实际上共享种子就是一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/Pos/Core/Types.hs#L257\\\">字符串</a>。</p>\\n<p>股东被选举为领导者的概率与股东持有的币的数量相关。同一个股东可以在同一个 epoch 里面被选举为多个 slot 的领导者。</p>\\n<h2>算法</h2>\\n<p>在<a href=\\\"/glossary/#%E8%AE%BA%E6%96%87\\\">论文</a>的第11页从以学术角度描述了领导者的选举过程。</p>\\n<p>节点将所有未花费的输出(<code>utxo</code>)按照一种特定的方法（按字典）进行排序，因此结果是一对 <code>(StakeholderId, Coin)</code> 的有序<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/1f866450a8a530c119e3fc9edb84c97c56417aa2/src/Pos/Genesis.hs#L177\\\">序列</a>，<code>StakeholderId</code> 是股东的 ID（股东的公钥哈希值），<code>Coin</code> 是股东持有币的数量。这里假设 <code>utxo</code> <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/1f866450a8a530c119e3fc9edb84c97c56417aa2/src/Pos/Lrc/FtsPure.hs#L52\\\">不是空的</a>。</p>\\n<p>然后节点选择几个在 <code>1</code> 和<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/1f866450a8a530c119e3fc9edb84c97c56417aa2/src/Pos/Lrc/FtsPure.hs#L49\\\">系统中 Lovelaces 的数量</a>之间的随机数 <code>i</code>。为了找到第 <code>i</code> 个币的拥有者，节点找到最小的 <code>x</code>，使得这个列表从 <code>x</code> 到 <code>i</code> 的所有币的总数不小于 <code>i</code>(这样第 <code>x</code> 个地址就是第 <code>i</code> 个的拥有者)。</p>\\n<p>结果是一个非空的 <code>StakeholderId</code> 序列，也就是被选中的股东们的 ID，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/5f7b619c6ec9056c6fe778d862c426233af165df/core/Pos/Core/Types.hs#L264\\\"><code>SlotLeaders</code></a> 序列保存在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/da70b2597aab352d7574a3946a366395b09e97eb/node/src/Pos/Context/Context.hs#L94\\\">节点运行环境中</a>。</p>\\n<p>由于是 P2SH 地址，所以节点不知道是会谁将要给它们发送资金。因此，P2SH 地址可以包含目标地址，该目标地址指明哪些地址应该被视为『拥有』用于 FTS 的基金。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/leader-selection/\",\"doc_title\":\"卡尔达诺结算层中的领导者选举\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-02-16-delegation.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at c23493d7a33a82d559d5bd9d289486795cf6592f -->\\n<h1>卡尔达诺结算层股权委派</h1>\\n<p>这一章描述权益委托过程的实现细节。</p>\\n<p>如前所述。为了产生新区块，被选举为领导者的股东必须在线。这种情况可能没有什么吸引力，因为大多数的当选股东都必须为了刷新随机数而参加投币协议（领导者选举过程的关键属性）。如果有很多当选的领导者，会让股东和网络都有很大的压力，因为需要广播和存储大量的提交和共享。</p>\\n<p>委派的功能允许被称为发行人（<em>issuers</em>） <code>I1...In</code> 的股权所有人将他们的『参与义务』转移给某些代表团（<em>delegates</em>） <code>D1...Dm</code>，这些代表团会在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/4bd49d6b852e778c52c60a384a47681acec02d22/src/Pos/Ssc/GodTossing.hs\\\">投币协议</a>中代表股权所有人 <code>S1...Sn</code>。在这种情况下，真正参与到投币协议中节点的数量就少很多，可以看看<a href=\\\"/glossary/#paper\\\">论文</a>的第38页。</p>\\n<p>不仅如此，代表团不仅可以生产新区块，参与到 <a href=\\\"/technical/leader-selection/#follow-the-satoshi\\\">MPC/SSC</a> 中，还可以在<a href=\\\"/cardano/update-mechanism/\\\">系统更新</a>时进行投票。</p>\\n<h2>策略</h2>\\n<p>领导者可以将自己生产新区块的权利转移给代表团。为了转移这个权利，领导者使用一个代理委托的策略：领导者产生一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/4378a616654ff47faf828ef51ab2f455fa53d3a3/core/Pos/Crypto/SignTag.hs#L33\\\">代理签名钥匙</a>，或者说 PSK，然后代表团会使用它<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/ed6db6c8a44489e2919cd0e01582f638f4ad9b72/src/Pos/Delegation/Listeners.hs#L65\\\">签名</a>信息来认证一个区块。有两种类型的 PSK：重量级和轻量级（见下文）</p>\\n<p>具体来说，股权所有人通过自己的公钥构建一个特殊证书来指定代表团的身份。以便之后代表团可以在有限的信息空间内用已签名的证书在自己的公钥下为这些信息提供签名。</p>\\n<p>这是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/d01d392d49db8a25e17749173ec9bce057911191/core/Pos/Crypto/Signing.hs#L256\\\">代理签名</a>的格式。它包括了：</p>\\n<ul>\\n<li>代理私钥，</li>\\n<li>签名。</li>\\n</ul>\\n<p>代理私钥包括：</p>\\n<ol>\\n<li>omega 值，</li>\\n<li>发行人的公钥，</li>\\n<li>代表团的公钥，</li>\\n<li>代理证书。</li>\\n</ol>\\n<p>Omega (or ω) 是<a href=\\\"/glossary/#paper\\\">论文</a>中一个特殊的值。在我们的实现中，它是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f374a970dadef0fe62cf69e8b9a6b8cc606b5c7d/core/Pos/Core/Types.hs#L235\\\">一对 epoch 的标识符</a>。这些标识符定义了委托有效期：如果 epoch 索引在这个范围内那么生产的区块就是有效的。</p>\\n<p><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/d01d392d49db8a25e17749173ec9bce057911191/core/Pos/Crypto/Signing.hs#L209\\\">代理证书</a>就是 omega 和代表团公钥的<a href=\\\"https://github.com/input-output-hk/cardano-crypto/blob/84f8c358463bbf6bb09168aac5ad990faa9d310a/src/Cardano/Crypto/Wallet.hs#L74\\\">签名</a>。</p>\\n<h2>重量级委派</h2>\\n<p>重量级委托使用权益阈值 <code>T</code>，这意味着股权所有人拥有的权益不少于 <code>T</code> 时才能参与重量级委托。这个阈值在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/42f413b65eeacb59d0b439d04073edcc5adc2656/lib/configuration.yaml#L224\\\">配置文件</a>中定义。就像主网的这个阈值是总权益的 0.03%，这个值可以通过系统更新来改变。</p>\\n<p>来自重量级委托的代理签名证书存储在区块链中。请注意发行者在每个 epoch 只能发布一个证书。</p>\\n<p>请注意重量级委托有一个传递关系，所以，如果 <code>A</code> 委派给 B，然后 B 又委派给 <code>C</code>，那么 <code>C</code> 代表的权益等于 <code>A + B</code>，而不仅仅是 <code>B</code>。</p>\\n<h3>到期</h3>\\n<p>在每一个 epoch 开始时，股权所有人不再传递阈值 <code>T</code>, 那么重量级委派证书就会过期。这样做是为了预防委派池膨胀攻击：用户提交了一个证书然后将自己所有的钱（高于阈值）都转到另一个账户，并且重复此操作。</p>\\n<h2>轻量级委派</h2>\\n<p><strong>注意：目前轻量级委派功能是关闭的，在 <a href=\\\"https://cardanoroadmap.com/\\\">Shelley 版本</a>中会打开这个功能，所以下面的信息可能是过期的。</strong></p>\\n<p>与重量级委托相反，轻量级委派不要求代表团拥有 <code>T</code> 或更多的股份。所以轻量级委派可以用于任何的节点。但是轻量级委派的代理签名证书不存在区块链中，所以轻量级委派证书必须要广播到代表团。</p>\\n<p>之后轻量级 PSK 可以被指定发行者的公钥、签名和信息本身进行<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/42f413b65eeacb59d0b439d04073edcc5adc2656/lib/src/Pos/Delegation/Logic/Mempool.hs#L309\\\">验证</a>。</p>\\n<p>请注意『每个 epoch 只能发布一个证书』的规则在轻量级委托中不适用。因为轻量级证书不存储在区块链中，所以可以在每个 epoch 签发很多轻量级证书，不会导致区块链膨胀。</p>\\n<h3>确认代理签名支付</h3>\\n<p>代表团应该使用他拥有的代理签名密钥，使用 PSK 和代表团的钥匙制作一个 PSK 签名。如果签名是正确的，那么就是由代表团进行签名的（由 PSK 策略确保是这种结果）。</p>\\n<h2>为什么有两个委派</h2>\\n<p>你可以将重量级委托和轻量级委托想象成强委托和弱委托。</p>\\n<p>重量级委派证书被存储在区块链中，所以被委派的权益可能会通过加入到委派权益中而参与 MPC。所以有很多重量级委派的代表团可能会累计足够的权益通过阈值的门槛。不仅如此，重量级委派可以参与卡尔达诺结算层更新的投票。</p>\\n<p>与此相反，轻量级委派的权益不会被计算到代表团的 MPC 相关权益。所以轻量级委派只能用来生产新区块。</p>\\n<h2>回撤证书</h2>\\n<p>回撤证书是一种特殊的证书，发行者创建一个回撤证书来撤回委托。重量级委托和轻量级委托都可以被撤回，不过撤回的方法不同。</p>\\n<p>作为相同的标准 PSK 的发行者和委派，撤销证书也是相同的。（换句话说，发行者委派给他自己）</p>\\n<p>要撤销轻量级委派，发行者发送撤销证书给网络，要求撤销委派，但是不能强制撤销，因为轻量级的 PSK 不是区块链的一部分。所以理论上轻量级委派是可以忽略撤销证书的，这样的话，他就一直保持着委派直到它的委派过期。但这样的情况不会妨碍区块链。</p>\\n<p>重量级委派撤销的处理是另一种方式。因为来自重量级委派的代理签名证书是存储在区块链中的，撤销证书也会被提交到区块链中。这种情况下，节点会删除撤销证书签发之前的重量级委派证。不过有三点很重要：</p>\\n<ul>\\n<li>如果提交的重量级委派证书是在节点的内存池里，而且撤销证书也被提交了，那么委派证书将会从内存池中被删除，显然，这种情况下委派证书将永远不会添加到区块链中。  </li>\\n<li>如果一个用户提交委派证书后丢失了他的钱，他仍然可以撤销那个委派，即使那个时候他已经没有足够的钱了（也就是说他拥有的钱少于上面提到的阈值 <code>T</code>)  </li>\\n<li>尽管发行者在当前的 epoch 只能发布一个证书，在同一个 epoch 他可以撤销他的重量级委派。</li>\\n</ul>\",\"frontmatter\":{\"path\":\"/cn/technical/delegation/\",\"doc_title\":\"卡尔达诺股权委派\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-05-15-wallet-backend.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层钱包后端 地址 章节讨论的地址是发送和接收资金的基础，而钱包是简化用户最终流程的一种方式。 什么是钱包？ 在卡尔达诺中，钱包的定义如下： 其中  CWalletMeta…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺结算层钱包后端</h1>\\n<p><a href=\\\"/cardano/addresses/\\\">地址</a>章节讨论的地址是发送和接收资金的基础，而钱包是简化用户最终流程的一种方式。</p>\\n<h2>什么是钱包？</h2>\\n<p>在卡尔达诺中，钱包的定义如下：</p>\\n<pre><code class=\\\"language-haskell\\\">data CWallet = CWallet\\n    { cwId       :: !CWalletAddress\\n    , cwMeta     :: !CWalletMeta\\n    , cwAccounts :: ![CAccount]\\n    , cwAmount   :: !CCoin\\n    }\\n</code></pre>\\n<p>其中 <code>CWalletMeta</code> 指明当前钱包是共享的还是个人的，以及钱包使用的货币和钱包的名字。有了这个，钱包类型很容易扩展，因为任何附加的功能可以添加到 <code>CWalletMeta</code> 类型，而其他字段不变。每个钱包，无论名称，类型和货币，都必须具有上述字段。</p>\\n<h2>交易和钱包</h2>\\n<p>在<a href=\\\"/cardano/transactions/\\\">转账</a>章节定义了交易数据的结构。然而，为了方便客户的操作，交易在客户中有不同的表现形式，他们被表示为：</p>\\n<pre><code class=\\\"language-haskell\\\">data CTx = CTx\\n    { ctId            :: CTxId\\n    , ctAmount        :: CCoin\\n    , ctConfirmations :: Word\\n    , ctMeta          :: CTxMeta\\n    , ctInputAddrs    :: [CAddress Acc]\\n    , ctOutputAddrs   :: [CAddress Acc]\\n    }\\n</code></pre>\\n<p>本质上，一个客户端的转账由实际交易 <code>Id</code>，收到的币的数量，交易已得到的确认数（即当前位于包含所述交易区块顶部的区块数量），输入和输出地址。元数据，数据类型 <code>CTxMeta</code>，表明交易的货币，标题或名称，描述信息，以及 POSIX 格式的发送日期。</p>\\n<h2>钱包后端 API</h2>\\n<p>目前，钱包 API 提供了一系列使用钱包的方法。Haskell 库 <code>servant</code> 提供了一个模块化的 API 构建方法。该库使用组合器来构建院子 HTTP 操作，并将这些原子方法粘合在一起以形成更大和更完整的 API。</p>\\n<p>请注意，只有当您使用 <code>--wallet</code> 选项运行节点时，钱包 Web API 才可用，这个 API 的默认端口 <code>8090</code> 可以通过 <code>--wallet-port</code> 选项进行更改。</p>\\n<p>钱包 Web API 文档可以在<a href=\\\"https://cardanodocs.com/technical/wallet/api/\\\">这里</a>找到</p>\\n<h3>TLS 连接</h3>\\n<p>钱包 Web API 使用 TLS 进行安全通信。调用 API 需要发送客户端 CA 证书，该证书在启动节点时使用，并将客户端标识为允许调用服务器 API。</p>\\n<p>请注意，客户端证书文件是启动节点时 <code>--tlsca</code> 作为选项提供的文件。</p>\\n<p>例如，如果该文件是可用的 <code>ca.crt</code>，那么对于运行节点 <code>localhost:8090</code> 调用 curl 命令可以像这样：</p>\\n<pre><code class=\\\"language-bash\\\">curl --cacert ca.crt -v https://localhost:8090/api/settings/sync/progress\\n</code></pre>\\n<p>如果该请求成功，那么您已经正确配置了 TLS。</p>\\n<h3>处理错误</h3>\\n<p>如果事件请求失败，则有一个 <code>WalletError</code> 类型，它只封装一个 <code>Text</code> 来显示发生了什么。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/wallet-backend/\",\"doc_title\":\"卡尔达诺结算层钱包后端\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-05-14-hd-wallets.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"HD 钱包 HD 钱包是一个允许用户以一种确定性方式从普通种子中获取密钥的功能。基本上，你可以从一个随机种子中产生一个初始密钥。然后你就可以从  SK₀  得到孩子  SK₀-₀ ,  SK₀-₁ 。从这些孩子中，你可以得到  SK₀-₀-₀ ,  SK₀-₀-₁ ,  SK…\",\"html\":\"<!-- Reviewed at 866fd6a29a15c503e54426f17b91bd8b0903c5dc -->\\n<h1>HD 钱包</h1>\\n<p>HD 钱包是一个允许用户以一种确定性方式从普通种子中获取密钥的功能。基本上，你可以从一个随机种子中产生一个初始密钥。然后你就可以从 <code>SK₀</code> 得到孩子 <code>SK₀-₀</code>, <code>SK₀-₁</code>。从这些孩子中，你可以得到 <code>SK₀-₀-₀</code>, <code>SK₀-₀-₁</code>, <code>SK₀-₁-₀</code> 等（派生任意深度的树）。</p>\\n<!-- For subscripts and other symbols: https://help.ubuntu.com/community/ComposeKey -->\\n<p>我们会区分两种类型的键：</p>\\n<ul>\\n<li><strong>Hardened</strong></li>\\n<li><strong>Non-hardened</strong></li>\\n</ul>\\n<p>这里唯一的区别是 <strong>hardened</strong> 密钥允许从父密钥派生出子密钥。因此，为了派生一个 <strong>hardened</strong> 键，你必须拥有私钥。<strong>Non-hardened</strong>密钥允许从父公钥派生子公钥（不具有可用密钥）。</p>\\n<p>每个孩子被分配一个4字节的索引 <code>i</code>:</p>\\n<ul>\\n<li><code>i ≤ 2³¹ - 1</code> <strong>non-hardened</strong> 键。</li>\\n<li><code>i > 2³¹ - 1</code> <strong>hardened</strong> 键。</li>\\n</ul>\\n<h2>属性:</h2>\\n<ol>\\n<li>树结构保存在根地址中。用户需要复制公钥将其传递给任何想要恢复树的人。</li>\\n</ol>\\n<h2>地址格式</h2>\\n<p>我们使用 <code>PublicKey</code> 地址（已经存在于系统中），并添加属性字段。在由 <code>0</code> (<strong>HD 钱包属性</strong>) ，我们存储树数据。</p>\\n<p>树存储为<strong>派生路径</strong>的列表。每个<strong>派生路径</strong>被指定为<strong>派生索引</strong>的列表。每个<strong>派生索引</strong>都是4字节的无符号整数。</p>\\n<p>所得到的对象被序列化并使用对称方案（<em>ChaChaPoly1305</em>算法进行加密），密码被计算为根公钥的SHA-512散列。只要我们实际上没有再根密钥上存储任何资金（不通过共识规则，而是通过用户界面），那么将不允许攻击者将链上的所有地址映射到根。</p>\\n<p><strong>设计的关键点：</strong>根密钥不用于实际存储金钱。</p>\\n<h2>用例</h2>\\n<h3>财务审计</h3>\\n<p>应该提供一个根公钥的审计散列，让审计人员找到层次结构中的所有密钥。</p>\\n<h3>付款服务器</h3>\\n<p>它只适用于 <strong>non-hardened</strong> 键。</p>\\n<p>为了使服务器能够获得后续地址来收取付款，需要上传：</p>\\n<ul>\\n<li>根公钥</li>\\n<li>\\n<p>有效载荷：</p>\\n<ul>\\n<li><code>i</code> 级别的 <code>PK</code></li>\\n<li>跟公钥的哈希</li>\\n<li><code>PK</code> 的树路径</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>钱包</h3>\\n<p>要使钱包在某个子树上运行，需要提供：</p>\\n<ul>\\n<li>根密钥</li>\\n<li>\\n<p>有效载荷：</p>\\n<ul>\\n<li><code>SK</code> 级别的密钥 <code>i</code></li>\\n<li>根公钥的哈希</li>\\n<li><code>SK</code> 的树路径</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>要求</h2>\\n<p><code>A(K)</code> 表示保存密钥对信息的地址 <code>K</code>。<code>child(K, i)</code> 表示第 <code>i</code>个子密钥对 <code>K</code>。<code>tree(K)</code> 表示从 <code>K</code>（有证书余额）派生，以 <strong>utxo</strong> 保存的密钥对地址树。</p>\\n<p><code>a -> b</code> 表示 <code>b</code> 从 <code>a</code> 派生。<code>a -x b</code> 表示 <code>b</code> 不是从 <code>a</code> 派生的（在任何情况下）：</p>\\n<pre><code>priv(K) -> pub(K)\\npub(K) -> A(K)\\npub(K) -x priv(K)\\nA(K) -x pub(K)\\nA(K) -x A(child(K, i))\\n</code></pre>\\n<p>对于 <strong>hardened</strong> 键：</p>\\n<pre><code>(priv(K), utxo) -> tree(K)\\npub(K) -x pub(child(K, i))\\npriv(K) -> priv(child(K, i))\\n</code></pre>\\n<p>对于 <strong>non-hardened</strong> 键：</p>\\n<pre><code>(pub(K), utxo) -> tree(K)\\npub(K) -> pub(child(K, i))\\npriv(K) -> priv(child(K, i))\\n</code></pre>\\n<h2>派生加密接口</h2>\\n<h3>符号:</h3>\\n<ul>\\n<li><code>kp</code> 表示具有索引 <code>p</code> 的私钥。只是一个 <strong>Ed25519</strong> 私钥。</li>\\n<li><code>kp</code> 表示带有索引 <code>p</code> 的公钥。只是一个 <strong>Ed25519</strong> 公钥。</li>\\n<li><code>cp</code> 表示带有索引的链。</li>\\n</ul>\\n<h3>熵</h3>\\n<p>在比特币中，它们使用512位的散列，但 <code>kp</code> 只有 256 位，因为这个原因，我们需要遵循512位的密钥，所以我们不减少哈希空间。</p>\\n<ul>\\n<li>扩展的私钥是表示为 <code>(ki, ci)</code> 的一对。</li>\\n<li>扩展的私钥是表示为 <code>(Ki, ci)</code> 的一对。</li>\\n</ul>\\n<p>从应用角度来看，HD 钱包（BIP-32）引入了以下密码原语：</p>\\n<ul>\\n<li>\\n<p><code>CKDpriv :: ((kpar, cpar), i) → (ki, ci)</code><br>\\n从父扩展私钥计算自扩展私钥</p>\\n</li>\\n<li>\\n<p><code>CKDpub :: ((Kpar, cpar), i) → (Ki, ci)</code><br>\\n从父扩展私钥中调用一个子扩展私钥</p>\\n</li>\\n</ul>\\n<h1>代达罗斯 HD 钱包</h1>\\n<p>本节介绍 HD 钱包功能的使用方式。它分为两部分：</p>\\n<ol>\\n<li>扩展钱包后端 API 以在本地支持 HD 钱包结构（就像在比特币中完成的那样）</li>\\n<li>利用新的地指数型来扩展区块链处理以保持多个客户端实例的 HD 结构同步。</li>\\n</ol>\\n<h2>本地存储</h2>\\n<h3>旧的存储</h3>\\n<p>旧的钱包存储存的是地址列表。每个地址都与一个名称相关联，并且是从单独的密钥（由助记符备份并用消费密码加密）派生而来。</p>\\n<h3>新的存储</h3>\\n<p>钱包的存储扩展到存储<strong>钱包</strong>列表。每个钱包对应一个根密钥（由助记符备份并用消费密码加密）。</p>\\n<p>每个钱包都包含一个<strong>账户</strong>。</p>\\n<p>每个账户都包含多个<strong>地址</strong>（即地址是 HD 树中第二层的关键字）。</p>\\n<p>这映射到一个 HD 树：</p>\\n<ul>\\n<li>钱包组对应第 0 级（<em>根</em>）密钥。</li>\\n<li>钱包对应1级密钥（根的孩子）。</li>\\n<li>地址对应于第2级（根的孙子）的密钥。</li>\\n</ul>\\n<p>钱只保存在地址上。</p>\\n<p>当从一个或多个地址花费金钱时，如果有的话，将产生新的余额。</p>\\n<h3>可用性</h3>\\n<p>用户能够：</p>\\n<ul>\\n<li>导入/导出任意数量的<strong>钱包</strong>，</li>\\n<li>生成任意数量的<strong>账户</strong>，</li>\\n<li>分配<strong>钱包</strong>和<strong>账户</strong>名称，</li>\\n<li>生成任意数量的地址，</li>\\n<li>改变钱包消费密码。</li>\\n</ul>\\n<h2>从区块链中读取 HD 钱包数据</h2>\\n<p>有两种导入/导出钱包的方法：</p>\\n<ul>\\n<li>通过<strong>助记符</strong>，</li>\\n<li>通过导出文件。</li>\\n</ul>\\n<p>助记符在前端生成，并允许确定性地生成密钥。名称不会被恢复。</p>\\n<p>导出文件能够恢复整个钱包结构。</p>\\n<h3>导入</h3>\\n<p>在两种情况下我们都有一个根密钥。在导入的时候会执行下面的步骤：</p>\\n<ul>\\n<li>根密钥在本地存储中被检查为不存在。</li>\\n<li>遍历 <strong>utxo</strong> 查找与此根密钥对应的所有有余额的地址，并将它们与服务（钱包）一起添加到存储中。</li>\\n<li>在文件导入的情况下，从步骤2得到的结构标有名称。此外，导入的文件中列出的钱包/地址，目前没有被使用。</li>\\n</ul>\\n<h3>新的事务处理</h3>\\n<p>当有新的交易可用时（出现在区块或内存池中），输入会被分析。如果输入对应于具有 <strong>HD 钱包属性</strong>的公共密钥地址，则检查该地址是否对应于我们的<strong>钱包</strong>之一。如果是这样，地址将被导入到结构中（为了在用于界面显示余额）。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/hd-wallets/\",\"doc_title\":\"HD 钱包\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-05-16-wallet-frontend.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at cd26fb28eb48f893a4ca2d045a10da19c211b807 -->\\n<h1>卡尔达诺结算层钱包前端</h1>\\n<p>卡尔达诺结算层发展时，用户需要一个可以查看资金，发送接收转账，处理其他个人电子货币钱包的任务这样的用户界面，这一需求在增长。代达罗斯钱包是对于这些需求的解决方案。</p>\\n<p>目前，它允许用户使用上述功能，并计划在不久的将来提供对其他货币的支持，包括电子货币和非电子货币。</p>\\n<h2>构建代达罗斯客户端 API</h2>\\n<p>要在本地运行代达罗斯客户端 API，您必须按照下面的要求开启 <a href=\\\"https://github.com/input-output-hk/cardano-sl/\\\"><code>cardano-sl</code></a> 的钱包 API。</p>\\n<p>请确保您在 <code>cardano-sl</code> 的根目录。同时确保您已经安装 <a href=\\\"https://www.npmjs.com/\\\">npm</a> 程序。</p>\\n<h2>运行和测试代达罗斯客户端 API</h2>\\n<p>为了在操作中看到代达罗斯客户端 API，首先运行一个本地的卡尔达诺结算层网络：</p>\\n<pre><code class=\\\"language-bash\\\"># run tmux in another window\\n$ tmux\\n# launch nodes\\n$ ./scripts/launch/demo-with-wallet-api.sh\\n</code></pre>\\n<p>默认情况下，这将启动由3个互连节点组成的尔达诺结算层网络。一个节点运行钱包 API，它会同生产环境中运行的代达罗斯钱包行为一致。</p>\\n<h2>WEBSOCKETS 通知</h2>\\n<p>我们可以用一个小工具(<code>npm install -g wscat</code>)来测试 websocks：</p>\\n<pre><code class=\\\"language-bash\\\">> wscat -c ws://127.0.0.1:8090\\n\\nconnected (press CTRL+C to quit)\\n\\n&#x3C; {\\\"tag\\\":\\\"ConnectionOpened\\\"}\\n\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":1}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":1}}\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":2}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":2}}\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":3}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":3}}\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":4}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":4}}\\n</code></pre>\\n<p>从这我们可以看到相同的改变：</p>\\n<pre><code class=\\\"language-bash\\\">curl http://localhost:8090/api/settings/sync/progress\\n</code></pre>\\n<p>Accound 应该重命名为地址。请查看这个 issues <a href=\\\"https://issues.serokell.io/issue/CSM-249\\\">CSM-249</a> 获取更多细节。</p>\\n<h2>钱包事件</h2>\\n<p>除了这些 HTTP 接入点外，还有一个从服务器到客户端的单向 websocket 通道，<code>notify</code> 接入点。</p>\\n<p>这个通道充当通知系统。以便可以告知代达罗斯 UI 相关事件。目前支持的事件有：</p>\\n<ul>\\n<li><code>LocalDifficultyChanged</code> - 当前区块链高度，</li>\\n<li><code>NetworkDifficultyChanged</code> - 全球区块链高度，</li>\\n<li><code>UpdateAvailable</code> - 新的系统可用更新，</li>\\n<li><code>ConnectedPeersChanged</code> - 连接到对等节点数量的改变，</li>\\n<li><code>ConnectionOpened</code> - 打开 websocket 连接，</li>\\n<li><code>ConnectionClosed</code> - 关闭 websocket 连接。</li>\\n</ul>\\n<p>由于此通道是单向的，因此从客户端发送到通道的任何消息都会被忽略。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/wallet-frontend/\",\"doc_title\":\"卡尔达诺结算层钱包前端\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-04-updater.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层更新器概览 更新系统的实现可以从  Pos.Update  系列模块中找到。实现的方法与 CSL 的其他子系统相同，比如 Txp, Ssc…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<!-- Updated at 6b5eda44e5942599a9781e5ad3f51eb820665b83 -->\\n<h1>卡尔达诺结算层更新器概览</h1>\\n<p>更新系统的实现可以从 <a href=\\\"https://github.com/input-output-hk/cardano-sl/tree/6b5eda44e5942599a9781e5ad3f51eb820665b83/src/Pos/Update\\\">Pos.Update</a> 系列模块中找到。实现的方法与 CSL 的其他子系统相同，比如 Txp, Ssc 和委派。更新系统有一个全局状态，存储在数据库中。全局状态可以从区块链中明确导出。本地状态，有时候也被称为『内存池』，被存储在内存中。内存池用于数据传输，将传输的数据保存到区块中。在<a href=\\\"/technical/protocols/binary-protocols/\\\">二进制文档</a>中描述的二进制协议在<a href=\\\"/technical/protocols/csl-application-level/\\\">应用级文档</a>中描述了网络协议（使用标准的 <a href=\\\"https://github.com/input-output-hk/cardano-sl/tree/43a2d079a026b90ba860e79b5be52d1337e26c6f/infra/Pos/Communication/Relay\\\">Inv/Req/Data\\npattern</a> 模式构建)。</p>\\n<p>目前，通过软件更新，执行研究部分所述的硬分叉来增加硬分叉的功能已经准备好了；软分叉（或者说软件更新）已经完全实现。</p>\\n<h2>软分叉可更新字段</h2>\\n<p>一个 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/Core/Types.hs#L110\\\">UpdateProposal</a> 包含用于修改由卡尔达诺结算层使用的一些参数（例如 slot 持续时间）的字段。具体来说，<code>upBlockVersion</code> 用于提议协议有了一些修改；如果 <code>upBlockVersion</code> 比上一次使用的区块还新，<code>upBlockVersionData</code> 的修改就会被采用。</p>\\n<p><code>upBlockVersionData</code> 具有 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/fe5e6a377ab63c506173545fd4d8633cd1afbdc6/core/Pos/Core/Types.hs#L206\\\">BlockVersionData</a> 的类型。</p>\\n<p>这些字段如下所述：</p>\\n<ul>\\n<li><code>bvdScriptVersion</code> - 用于验证脚本转账的脚本语言版本，如果协议中 <code>upBlockVersion</code> 增加了，它必须也给增加 <code>upBlockVersion</code> 1（不能保持不变）。</li>\\n<li><code>bvdSlotDuration</code> - slot 持续时间（以毫秒为单位）。</li>\\n<li><code>bvdMaxBlockSize</code> - 区块大小限制（以字节为单位）。与上一个限制相比而言，协议不能将区块的大小限制增加两倍以上。</li>\\n<li><code>bvdMaxHeaderSize</code> - 区块大小限制（以字节为单位）。</li>\\n<li><code>bvdMaxTxSize</code> - 转账大小限制（以字节为单位，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/core/constants.yaml#L17\\\">当前为4096字节</a>)，限制 <a href=\\\"/technical/protocols/binary-protocols/#transaction-auxilary\\\">TxAux</a> 的大小。</li>\\n</ul>\\n<p>这些检查在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/893e3c838bf847613313e8dbf04330176a788af4/update/Pos/Update/Poll/Logic/Base.hs#L232\\\">verifyNextBVData</a> 中进行。</p>\\n<p>此外，有一些现在未被使用，但将来会被使用的字段。以下是它们的简要说明：</p>\\n<ul>\\n<li><code>bvdMpcThd</code> MPC 的资格临界值。</li>\\n<li><code>bvdHeavyDelThd</code> 重量级委派的临界值。</li>\\n<li><code>bvdUpdateVoteThd</code> 投赞成票和反对更新所需的股份份额。</li>\\n<li><code>bvdUpdateProposalThd</code> 所有股份的一个份额，要让区块拥有 <code>UpdateProposal</code>，权益所有人的投票份额必须大于这一份额。</li>\\n<li><code>bvdUpdateImplicit</code> 静默更新之后的 slot 数（除非它有更多的否定票数）。</li>\\n<li><code>bvdUpdateSoftforkThd</code> 所有股份的一个份额，如果某些区块权益所有人的总持股比例比该数值大，则采用该区块版本。</li>\\n</ul>\\n<h2>内存池结构</h2>\\n<p><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/MemState/Types.hs#L29\\\"><code>内存池</code></a> 由投票和提案组成。除此以外，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/MemState/Types.hs#L39\\\"><code>内存池</code></a> 还包含 tip，slot 以及 <code>MemPool</code> 对应的 <code>PollModifier</code>（当前 <code>GState</code>，即应用的 <code>MemPool</code> 对应 <code>GState</code>）。无论是来自网络/内存池提案状态改变，还是来自区块链加载的提案状态改变，<code>PollModifier</code> 都表示全局状态的改变，会被应用到内存池。</p>\\n<h3>更新内存池</h3>\\n<p>随着节点反序列化<a href=\\\"/technical/protocols/binary-protocols/#update-system\\\">更新系统消息的数据</a>，内存池会被更新，实现在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/MemState/Functions.hs#L35\\\">这里</a>。</p>\\n<p><code>MemPool</code> 在三种情况下会被更新：</p>\\n<ol>\\n<li>\\n<p><strong>当收到新的提案/表决时</strong>。在这种情况下，调用一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/763822c4fd906f36fa97b6b1f973d31d52342f3f/update/Pos/Update/Logic/Local.hs#L186\\\">处理函数</a>，然后调用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/dff5e00612c84af24964a98e5254602fa4f7fc17/update/Pos/Update/Poll/Logic/Apply.hs#L66\\\"><code>verifyAndApplyUSPayload</code></a> 并更新当前 <code>PollModifier</code> 和 <code>MemPool</code>。  </p>\\n</li>\\n<li>\\n<p><strong>当一个新 slot 开始时</strong>。在这种情况下，一些内存池的数据可能会失效。事实上，只有 epoch 发生变化时才会发生这种情况。这种情况可能会发生是因为稳定的股份分配发生了变化，有些投票可能没有足够的股份。这是 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/763822c4fd906f36fa97b6b1f973d31d52342f3f/update/Pos/Update/Logic/Local.hs#L283\\\"><code>processNewSlot</code></a> 方法实现的。</p>\\n</li>\\n<li>\\n<p><strong>当 <code>GState</code> 更新时</strong>。它被称为 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/763822c4fd906f36fa97b6b1f973d31d52342f3f/update/Pos/Update/Logic/Local.hs#L248\\\"><code>usNormalize</code></a>。有些数据可能由于区块应用程序或回滚而变得无效。例如，我们在内存中有个提案，将这个提案应用于区块，然后它变无效了（因为它已经在区块中）。我们应该放弃这个提案。或者我们从某个区块对提案进行投票，然后回滚这个区块，然后投票变得无效。它通过将所有本地数据应用于空状态来实现的，忽略所有不再有效的数据。</p>\\n</li>\\n</ol>\\n<h3>提案和投票累计</h3>\\n<p>要为提案投票，节点应该发送它们的<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/Core/Types.hs#L255\\\">投票</a>。提案和投票存储在内存池（即使没有足够的选票加入区块，这种方式也可以自动收集投票），或者从区块链收集，以确定哪个方案通过。</p>\\n<h2>与数据库的交互</h2>\\n<p>为了验证更新系统数据，我们必须从全局状态（数据库）获取这些数据。有一个文档详实的类型类 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/update/Pos/Update/Poll/Class.hs#L29\\\"><code>MonadPollRead</code></a> 提供这样的接口。这种类型不但用于数据库交互，还用于在处理从网络接收到的数据时将内存池写入账户。非常重要的一点是，它的实现依赖于 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/DB.hs\\\"><code>Pos.Update.DB</code></a> 模块中的函数。</p>\\n<h2>核心类型</h2>\\n<p>核心类型在<a href=\\\"/technical/protocols/binary-protocols/\\\">二进制协议</a>文档中提到。这些类型直接反映了研究章节的概念，有关更多信息，请参阅<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/Core/Types.hs\\\">核心类型模块</a>。</p>\\n<h2>更新提案批准</h2>\\n<p>更新机制实现的一个很重要的部分是创始块的部分。这个逻辑在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/6b5eda44e5942599a9781e5ad3f51eb820665b83/src/Pos/Update/Poll/Logic/Softfork.hs#L68\\\"><code>processGenesisBlock</code></a> 中。下面将解释与该过程有关的术语。</p>\\n<h3>阈值</h3>\\n<p>假设有一个区块版本 <code>X</code>。以及在 slots <code>S</code> 中创建的版本为 <code>X</code> 的区块（其中 <code>S</code> 是一组 slots）。如果所有 slot 的领导者的总相对资产 <code>S</code> ≥ <code>softforkResolutionThreshold</code> (在代码中被称为阈值)，则 <code>X</code> 被采纳。请参阅<a href=\\\"/cardano/update-mechanism/#soft-fork-updates\\\">研究概述</a>获取更详细说明。</p>\\n<h3>提案状态</h3>\\n<p>更新的提案状态可处于下面的状态之一。</p>\\n<h4>未定</h4>\\n<p>这意味着更新提案被包含在其中一个区块中，但是它没有 <code>50%</code> 的赞成/反对票（这里的 <code>50%</code> 的意义是赞成/反对提案选民总数相对于系统所有权益相关者的总股权），默认赞同规则还没有触发。</p>\\n<!-- TODO: **Important remark:** when we are talking about stake, we need to be clear about\\nwhich stake distribution we are talking about. For each epoch we know stable distribution\\nfor this epoch. It used in leaders selection (follow-the-satoshi) and also in many other\\ncases. Stable distribution is distribution as it was ﻿⁠⁠⁠⁠2k﻿⁠⁠⁠⁠ slots before the end of epoch.\\nTo calculate stake of votes for proposal ﻿⁠⁠⁠⁠p﻿⁠⁠⁠⁠ we use stake distribution as per epoch in\\nwhich ﻿⁠⁠⁠⁠p﻿⁠⁠⁠⁠ was added to blocks. I. e. distribution which was ﻿⁠⁠⁠⁠2k﻿⁠⁠⁠⁠ slots before the\\nend of that epoch. This ensures that nobody can transfer his funds to another address\\nand vote from that address to increase total stake of voters.\\n\\n**Another important remark:** when we are talking about stake, it's also important to be\\nclear whether we consider delegated stake. I. e. if Alice delegated to Bob, do we consider\\nthat Alice's funds belong to Bob or Alice? When we use stake for votes, we consider delegated\\nstake, i. e. we consider that Alice's funds belong to Bob. Note that here we consider\\nonly heavyweight delegation. I hope it's covered in documentation, but I am not sure. -->\\n<h4>批准</h4>\\n<p>这意味着这个提案有超过 <code>50%</code> 的投票或很久之前加入了区块（根据默认批准规则），赞同的票数比反对的票数更多（与股权比较）。</p>\\n<h4>拒绝</h4>\\n<p>如果反对该提案的投票超过 <code>50%</code>，或很久之前加入了区块（根据默认批准规则），反对的票数比赞同的票数更多（再次与股权比较）。</p>\\n<h4>确认</h4>\\n<p>如果至少 <code>k</code> 个区块提案通过，那么这个<strong>批准</strong>的提案被称为<strong>确认</strong>。这时候我们可以确定该提案不会被拒绝。因为深度超过 <code>k</code> 的回滚是不可能的。</p>\\n<h4>废弃</h4>\\n<p>如果至少 <code>k</code> 个区块提案未通过，那么这个<strong>拒绝</strong>的提案被<strong>废弃</strong>。这时候我们可以确定该提案不会被通过。因为深度超过 <code>k</code> 的回滚是不可能的。</p>\\n<h2>下载新版本</h2>\\n<p>在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/src/Pos/Update/Download.hs\\\"><code>Pos.Update.Download</code></a> 模块中，实现了以下算法。已下载的更新通过一个叫做 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/82ba83c3ffb670201b309ff47e3d0ab5f4a17455/src/launcher/Main.hs\\\"><code>cardano-launcher</code></a> 的工具操作。</p>\\n<h3>下载更新的版本</h3>\\n<p>要下载更新的版本，我们从 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/Poll/Types.hs#L114\\\"><code>ConfirmedProposalState</code></a> 提取更新的哈希值。如果更新哈希值成功提取了，则调用『下载更新哈希值』算法以下载保存更新的版本，这取决于我们是否在给定的平台使用安装程序。</p>\\n<h3>通过哈希值下载更新</h3>\\n<p>为了<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/daa8b81785f38038187c45385c9a94510a5c3780/src/Pos/Update/Download.hs#L108\\\">通过哈希值下载更新</a>，我们会使用 HTTP 中的 <code>httpLBS</code>，遍历已知的更新服务器，用给定的哈希值下载更新。很简单：最后，我们要么完成了更新的下载，要么遍历完服务器清单，上报错误信息。已知更新服务器的 URI 使用 <code>cardano-node</code> 可执行文件的 <code>--update-server</code> 参数定义。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/updater/\",\"doc_title\":\"卡尔达诺结算层更新器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-07-blocks.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺清算层的区块 这份指南介绍区块设计和区块处理的逻辑。 区块相关类型在  Pos.Block.Core.Main.Types  模块和  Pos.Block.Core.Genesis.Types  模块中定义。在\\n Pos.Block.Logic…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺清算层的区块</h1>\\n<p>这份指南介绍区块设计和区块处理的逻辑。</p>\\n<p>区块相关类型在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Types.hs\\\">Pos.Block.Core.Main.Types</a> 模块和 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Genesis/Types.hs\\\">Pos.Block.Core.Genesis.Types</a> 模块中定义。在\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/tree/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic\\\">Pos.Block.Logic.*</a> 模块中定义了使用区块的逻辑。</p>\\n<h2>设计</h2>\\n<p>区块是账本的基础部分。有两种类型的区块：<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Types.hs#L110\\\"><strong>主块</strong></a>和<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Genesis/Types.hs#L66\\\"><strong>生成块</strong></a>。</p>\\n<h3>主区块</h3>\\n<p>一个主区块由<em>头</em>和<em>主体</em>组成。<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/core/Pos/Core/Block.hs#L99\\\">区块头</a>包含块的元信息：</p>\\n<ol>\\n<li>指向前一个区块签名的头。</li>\\n<li>区块主体信息的验证。</li>\\n<li>验证共识算法的共识数据。</li>\\n<li>一些额外的数据。</li>\\n</ol>\\n<p>区块主体包含的有效载荷和一些额外的数据也是如此。有效载荷包括：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L66\\\">转账有效载荷</a>。这个有效载荷是最主要的。事务存储在 Merkle 树中。这个有效载荷也包括<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Txp/Core/Types.hs#L283\\\">见证名单</a>，请阅读<a href=\\\"/cardano/transactions/\\\">卡尔达诺结算层</a>的交易，了解交易和见证的更多信息。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L68\\\">SSC 有效载荷</a>。按照跟随<a href=\\\"/cardano/proof-of-stake/#follow-the-satoshi\\\">中本聪算法</a>使用 SSC（共享种子计算）。在每一个 epoch 中，必须选出下一个 epoch 的领导者。这些 slot 的领导者将能够生成主区块并加入到账本中。所以 SSC 被用作领导者选举过程的随机来源。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L70\\\">委派的有效载荷</a>。该有效载荷由<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Delegation/Types.hs#L49\\\">重量级代理签名密钥列表</a>组成。请阅读关于<a href=\\\"/technical/delegation/\\\">卡尔达诺结算层的股权委派</a>获取更多信息。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L72\\\">更新有效载荷</a>。它包含软件更新的<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/732a2c765a417ba0a5010df81061c4473f80a0dc/update/Pos/Update/Core/Types.hs#L300\\\">建议</a>和特定更新的选项列表。请阅读<a href=\\\"/cardano/update-mechanism/\\\">更新系统模型</a>获得更多信息。</li>\\n</ol>\\n<h3>创世块</h3>\\n<p>一个创始块不包含交易，每个 epoch 我们都只有一个创始块。创始块就像主区块一样，只有一个区块头和一个区块主体。该块的主题包括：</p>\\n<ol>\\n<li>与该区块相关的 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Genesis/Chain.hs#L33\\\">epoch 索引</a>。</li>\\n<li>这个 epoch 的 slot 领导者列表。该列表<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/b4b2c282b0e2a2e4415163e70dcb559396a2237c/core/Pos/Core/Types.hs#L272\\\">不能为空</a>。</li>\\n<li>链复杂度。他表示生成一个链的复杂度，它是链中主块的数量。</li>\\n</ol>\\n<h2>区块处理逻辑</h2>\\n<p>我们根据区块和区块头进行处理。基本上，我们可以：</p>\\n<ul>\\n<li>创建一个区块</li>\\n<li>验证一个区块</li>\\n<li>申请块</li>\\n<li>回滚一个块</li>\\n</ul>\\n<p>以及：</p>\\n<ul>\\n<li>按不同的标准获取块头</li>\\n<li>给区块头分类</li>\\n</ul>\\n<h2>创建区块</h2>\\n<p>如上所述，有两种区块：<strong>主</strong>区块和<strong>生成</strong>块。主区块由 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L156\\\"><code>createMainBlock</code></a> 函数创建，生成块由 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L92\\\"><code>createGenesisBlock</code></a> 创建。</p>\\n<h3>主区块创建</h3>\\n<p>如果可能的话，我们尝试在最佳链的顶部创建一个新的主区块。如果满足以下条件，可以创建一个新区块：</p>\\n<ul>\\n<li>我们知道 epoch 给定 slot ID 的主区块，</li>\\n<li>最后一个已知的区块不超过给定的 slot 的 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f571087e5b5af339767198141981c850227ca99c/core/Pos/Core/Constants.hs#L86\\\"><code>slotSecurityParam</code></a> 个区块。</li>\\n</ul>\\n<p><code>slotSecurityParam</code>（实际上是 slot 的数量）的值取决于可被回滚区块的最大数量。这个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/core/Pos/Core/Constants.hs#L81\\\">最大数量</a>来自<a href=\\\"/glossary/#paper\\\">论文</a>中的安全参数。</p>\\n<p>首先，我们必须检查我们的软件是否可以<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Update/Logic/Global.hs#L139\\\">根据当前的全局状态</a>创建一个区块，如果不能，我们会<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L172\\\">报告</a>。如果可以的话，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L206\\\">创建并应用区块</a>。</p>\\n<h3>创世纪块的创建</h3>\\n<p>当当前已知最佳链的头 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Types.hs#L112\\\"><code>MainBlock</code></a>  对应于 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/core/Pos/Core/Constants.hs#L81\\\"><code>slotSecurityParam</code></a> （i-1）个时期的最后一个 slot 之一时，为当前时期创建一个生成块。</p>\\n<p>首先，我们试图获得 slot 领导者，如果<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L99\\\">没有领导者</a>或 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L102\\\">LRC 没有足够的区块</a>，则会报告错误。否则，我们试图创建一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L115\\\">新的创始块</a>。然而有时候我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L106\\\">不应该创建</a>。例如，我们不应该在第 0 个 epoch 做这件事情，因为<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L108\\\">第 0 个 epoch</a> 的生成块是硬编码的。</p>\\n<h2>区块应用</h2>\\n<p>我们使用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/VAR.hs#L182\\\"><code>applyBlocks</code></a> 函数应用区块。区块的顺序应该是绝对有效的：我们必须验证关于块的所有谓词和数据检查。</p>\\n<p><strong>重要</strong>： 在这个序列中的所有区块都必须是相同的 epoch！</p>\\n<p>如果所有的条件都满足了，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L107\\\">真正应用区块</a>：</p>\\n<ul>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L141\\\">应用 US (更新系统)</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L142\\\">应用委派</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L143\\\">应用转账</a>。</li>\\n</ul>\\n<p>而且，我们可以在应用程序之前验证区块（即只有在区块有效时才应用区块）。我们使用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L99\\\"><code>verifyAndApplyBlocks</code></a> 函数的功能，如果在应用程序发生错误，有两个选项：</p>\\n<ol>\\n<li>在这个函数中应用的所有区块都将<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L137\\\">回滚</a>。</li>\\n<li>这个函数将尝试<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L126\\\">尽可能地多应用区块</a></li>\\n</ol>\\n<h2>区块回滚</h2>\\n<p>您可以把回滚视为应用程序的对立面：当执行回滚时，应用程序所做的所有修改都将被取消，为此，我们使用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L208\\\"><code>rollbackBlocks</code></a> 函数的功能。</p>\\n<p>get the tip？第一个区块将回滚。如果他们不匹配，则报告错误。如果他们匹配，我们实际上回滚区块的顺序为：</p>\\n<ul>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Internal.hs#L173\\\">回滚委派</a>，抹掉内存池中的认证。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Internal.hs#L174\\\">回滚 US</a></li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Internal.hs#L172\\\">回滚交易</a></li>\\n</ul>\\n<h2>区块头分类</h2>\\n<p>区块头部可以分为：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L51\\\">继续</a>。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L54\\\">可选</a>。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L59\\\">无效</a>。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L57\\\">无用</a>。</li>\\n</ol>\\n<p>如果<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L120\\\">验证成功</a>，则头部为<strong>继续</strong>：头部是主链的直接延续（即，其服务是我们的 tip）。</p>\\n<p>如果头部的父亲不是我们的 tip，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L124\\\">它不太可能是我们的主链</a>，头部为<strong>可选</strong>。</p>\\n<p>如果<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L170\\\">头部链中有任何错误</a>，或者<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L172\\\">没有对应链中最老元素（应该是检查点之一）</a>的父亲的块，那么头部被视为<strong>无效</strong>。</p>\\n<p>如果在不同的条件下（例如，头部的 slot <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L94\\\">小于或等于我们 tip 的 slot</a>，或者<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L129\\\">头部与主链不连续，复杂度更大</a>），头部为<strong>无用</strong>。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/blocks/\",\"doc_title\":\"卡尔达诺结算层区块\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-02-15-pvss.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层中 PVSS 的实现 卡尔达诺结算层使用公开验证密钥共享模式，它基于『SCRAPE：可扩展的随机性公共实体证明』这篇由 Ignacio Cascudo 和 Bernardo David 写的 论文 。接下来我们将引用论文中的页，比如  [6]  表示第…\",\"html\":\"<!-- Reviewed at 18852484704ff4a7ce3fcac2791499c340eb8e02 -->\\n<h1>卡尔达诺结算层中 PVSS 的实现</h1>\\n<p>卡尔达诺结算层使用公开验证密钥共享模式，它基于『SCRAPE：可扩展的随机性公共实体证明』这篇由 Ignacio Cascudo 和 Bernardo David 写的<a href=\\\"https://eprint.iacr.org/2017/216.pdf\\\">论文</a>。接下来我们将引用论文中的页，比如 <code>[6]</code> 表示第6页。</p>\\n<p>本指南介绍了<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/65e295599817ec1f52f225810264d856f882fbb7/core/Pos/Crypto/SecretSharing.hs#L1\\\">卡尔达诺结算层</a>中 <code>pvss-haskell</code> <a href=\\\"https://github.com/input-output-hk/pvss-haskell\\\">库</a>的实现细节。</p>\\n<h2>什么是 PVSS</h2>\\n<p>VSS 模式的核心思想是参与者验证自己的份额，成功构建密钥（之前由参与者中的经销商分发（TODO））的能力。而 PVSS 模式的核心思想是，参与者不仅可以验证其股权，而且任何人都可以验证参与者是否收到了正确的股权。因此（参考我们的重建协议），参与者不仅要发行他们的股权，还要为每个发行的股票提供一个正确地证明(<code>[9]</code>)。（TODO）</p>\\n<p>我们使用 <code>t-out-of-n</code> 重建方案(<code>[8]</code>)，其中 <code>n</code> 是参与者的数量，<code>t</code> 是一个阈值。所以任何 <code>t+1</code> 份额的子集可以用来成功恢复密钥。</p>\\n<p>所以，协议有四个基本阶段(<code>[8]</code>)组成：</p>\\n<ol>\\n<li>建立，</li>\\n<li>分配，</li>\\n<li>验证，</li>\\n<li>重建。</li>\\n</ol>\\n<h2>建立</h2>\\n<p>每个参与者 <code>Pi</code> 必须生成器私钥 <code>SKi</code> 并注册其公钥 <code>PKi</code>。</p>\\n<h2>分配</h2>\\n<p>首先，我们准备一个新的托管环境。要做到这一点，我们需要上面提到的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L76\\\">阈值</a>和参与者的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L175\\\">公钥清单</a>。该操作的结果是 <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L120\\\"><code>Escrow</code></a>，它包括：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L85\\\">额外的生成器</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/Polynomial.hs#L24\\\">多项式</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L89\\\">密钥</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L39\\\">证明</a>。</li>\\n</ol>\\n<p>额外的生成器基于一个<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L92\\\">点</a>（<a href=\\\"http://hackage.haskell.org/package/cryptonite-openssl-0.6/docs/Crypto-OpenSSL-ECC.html#t:EcPoint\\\">椭圆曲线点</a>）。我们使用 <code>prime256v1</code> 椭圆曲线，参见 <a href=\\\"https://www.ietf.org/rfc/rfc5480.txt\\\">RFC</a>。</p>\\n<p>多项式是一组从 smallest degree 开始的一组系数（这些系统是<a href=\\\"http://hackage.haskell.org/package/cryptonite-0.23/docs/Crypto-PubKey-ECC-P256.html#t:Scalar\\\">标</a>值）。</p>\\n<p>密钥也基于一个<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L92\\\">点</a>，实际上它是上面提到的多项式的第一个<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L140\\\">元素</a>。</p>\\n<p>证明从<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L142\\\">挑战</a>，<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L140\\\">原始密钥</a>，<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L143\\\">DEEQ-参数生成</a>中<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L62\\\">生成</a>。</p>\\n<p>挑战是基于<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L125\\\">加密哈希</a>。</p>\\n<p>之后，我们必须<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L168\\\">完成托管创建</a>。参与者的公共密钥列表被用于<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L202\\\">创建加密股份</a>和<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L202\\\">承诺</a>。加密的股份包括：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L82\\\">分享 ID</a>，</li>\\n<li>通过参与者公钥加密的 <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L99\\\">Value</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L99\\\">证明</a>这个股份是有效的 (<code>[8]</code>)。</li>\\n</ol>\\n<h2>验证</h2>\\n<p>现在可以在参与者之间发布承诺和加密的股份。由于 PVSS 模式的公共性质，任何知道公共密钥的人都可以通过散列匹配来<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L249\\\">验证加密的股份</a>。</p>\\n<h2>重建</h2>\\n<p>首先，参与者必须使用<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L84\\\">公钥</a>，<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L80\\\">私钥</a>密钥对<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L230\\\">解密加密的股份</a>。为了获得 DLEQ 的值，我们使用 <code>prime256v1</code> <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L156\\\">曲线生成器</a>。结果，我们得到 <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L109\\\"><code>DecryptedShare</code></a>，其结构与加密股份相同。</p>\\n<p>由于解密的股份包含一个证明，所以我们可以确定解密的股份和加密的股份是一样的，并且有<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L260\\\">验证功能</a>。要<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L74\\\">做到这一点</a>，我们使用 DLEQ 值和来自<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L263\\\">解密股份的证明</a>。实际的验证是 DLEQ 点的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L146\\\">散列</a>的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L77\\\">比较</a>。</p>\\n<p>现在，如果我们有 <code>t+1</code> 解密股份，我们可以<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L285\\\">恢复一个密钥</a>。</p>\\n<p>恢复的密钥也可以被<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L267\\\">验证</a>。所以我们可以确定恢复的密钥是相同的托管。要做到这一点，我们不仅需要一个证明和一个密钥，还需要<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L268\\\">承诺</a>（实际上是<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L278\\\">第一个</a>）。</p>\\n<h2>VSS 证书</h2>\\n<p>正如<a href=\\\"/cardano/differences/#coin-tossing-and-verifiable-secret-sharing\\\">前面所说的</a>，同时使用 PVSS 方案的挑战之一是相关联的用于与签名的公钥用于 VSS 方案。这是通过引入 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f0de5f1dd31cc4afb0c67a24deca713cf6304814/core/Pos/Core/Vss/Types.hs#L46\\\">VSS 证书</a>来解决的。</p>\\n<p>VSS 证书包括：</p>\\n<ol>\\n<li>用于 VSS 方案的公钥（例如 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/fefc39f058f5a053fc1e59bc3594bdadf7699ca0/core/Pos/Crypto/SecretSharing.hs#L57\\\">VSS 密钥</a>)。</li>\\n<li>用于签名的公钥（<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f0de5f1dd31cc4afb0c67a24deca713cf6304814/core/Pos/Core/Vss/Types.hs#L51\\\">例如签名密钥</a>）。</li>\\n<li>过期 epoch 的索引（例如，在 epoch 的最后，证书是有效的）。</li>\\n<li>签名对 <code>(A,B)</code>，其中 <code>A</code> 是一个 VSS 键，<code>B</code> 是一个 epoch 索引。</li>\\n</ol>\\n<p>最初，拥有足够股份参与随机生成的所有权益相关者（我们成为<a href=\\\"/glossary/#richman\\\">富人</a>）<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Workers.hs#L163\\\">拥有自己的证书</a>。当出现一个拥有足够多股权的新利益相关者时，或者现有证书过期时，应该生成一个新的证书并<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Workers.hs#L166\\\">提交给网络</a>。其他节点接受此证书，如果该证书有效并且该节点具有足够的股权。证书存储在区块中。</p>\\n<p>请注意 VSS 证书在使用前必须是稳定的。如果我们检索证书的 epoch 是第一个（即有索引 <code>0</code>)，稳定的证书是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Functions.hs#L139\\\">起始证书</a>，否则，稳定的证书是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Functions.hs#L141\\\">最后一个已知 slot 的未到期证书</a>。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/pvss/\",\"doc_title\":\"卡尔达诺结算层 PVSS\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-01-cli-options.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层命令行选项 这份文档描述了卡尔达诺结算层的所有可执行文件以及所有相应的命令行参数。 cardano-node cardano-keygen cardano-explorer-swagger cardano-node-simple cardano-launcher…\",\"html\":\"<!-- THIS IS AUTOGENERATED CHAPTER. DO NOT CHANGE IT MANUALLY! -->\\n<h2>卡尔达诺结算层命令行选项</h2>\\n<p>这份文档描述了卡尔达诺结算层的所有可执行文件以及所有相应的命令行参数。</p>\\n<h2>cardano-node</h2>\\n<pre><code>Cardano SL node.\\n\\nUsage: cardano-node [--version] [--db-path FILEPATH] [--rebuild-db]\\n                    [--genesis-secret INT] [--keyfile FILEPATH]\\n                    [--backup-phrase PHRASE] [--topology FILEPATH]\\n                    [--kademlia FILEPATH] [--node-id NODE_ID]\\n                    [--default-port PORT] [--policies FILEPATH]\\n                    [--address IP:PORT] [--listen IP:PORT] [--json-log FILEPATH]\\n                    [--log-config FILEPATH] [--logs-prefix FILEPATH]\\n                    [--report-server URI] [--update-server URI]\\n                    [--configuration-file FILEPATH] [--configuration-key TEXT]\\n                    [--system-start TIMESTAMP] [--configuration-seed INTEGER]\\n                    [--update-latest-path FILEPATH] [--update-with-package]\\n                    [--no-ntp] [--route53-health-check IP:PORT] [--metrics]\\n                    [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                    [--statsd-interval MILLISECONDS] [--statsd-debug BOOL]\\n                    [--statsd-prefix TEXT] [--statsd-suffix TEXT]\\n                    [--dump-genesis-data-to ARG] [--web] [--web-port PORT]\\n                    [--tlscert FILEPATH] [--tlskey FILEPATH] [--tlsca FILEPATH]\\n                    [--wallet-address IP:PORT] [--wallet-db-path ARG]\\n                    [--wallet-rebuild-db]\\n                    [--wallet-acid-cleanup-interval MINUTES] [--wallet-debug]\\n                    [--flush-wallet-db]\\n  Cardano SL main server node w/ wallet.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --web                    Activate web API (it’s not linked with a wallet web\\n                           API).\\n  --web-port PORT          Port for web API. (default: 8080)\\n  --tlscert FILEPATH       Path to file with TLS certificate\\n  --tlskey FILEPATH        Path to file with TLS key\\n  --tlsca FILEPATH         Path to file with TLS certificate authority\\n  --wallet-address IP:PORT IP and port for backend wallet\\n                           API. (default: (\\\"127.0.0.1\\\",8090))\\n  --wallet-db-path ARG     Path to the wallet's database.\\n  --wallet-rebuild-db      If wallet's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --wallet-acid-cleanup-interval MINUTES\\n                           Interval on which to execute wallet cleanup action\\n                           (create checkpoint and archive and cleanup archive\\n                           partially)\\n  --wallet-debug           Run wallet with debug params (e.g. include all the\\n                           genesis keys in the set of secret keys).\\n  --flush-wallet-db        Flushes all blockchain-recoverable data from DB\\n                           (everything excluding wallets/accounts/addresses,\\n                           metadata)\\n\\nCommand example:\\n\\n  stack exec -- cardano-node                                             \\\\\\n    --db-path node-db0                                                   \\\\\\n    --rebuild-db                                                         \\\\\\n    --keyfile secrets/secret-1.key                                       \\\\\\n    --kademlia-id a_P8zb6fNP7I2H54FtGuhqxaMDAwMDAwMDAwMDAwMDA=           \\\\\\n    --address 127.0.0.1:3000                                             \\\\\\n    --listen 127.0.0.1:3000                                              \\\\\\n    --kademlia-address 127.0.0.1:3000                                    \\\\\\n    --json-log=/tmp/logs/2017-05-22_181224/node0.json                    \\\\\\n    --logs-prefix /tmp/logs/2017-05-22_181224                            \\\\\\n    --log-config /tmp/logs/2017-05-22_181224/conf/node0.log.yaml         \\\\\\n    --kademlia-dump-path /tmp/logs/2017-05-22_181224/dump/kademlia0.dump \\\\\\n    --system-start 1495462345\\n</code></pre>\\n<h2>cardano-keygen</h2>\\n<pre><code>Tool to generate keyfiles-related data\\n\\nUsage: cardano-keygen [--version] COMMAND [--configuration-file FILEPATH]\\n                      [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                      [--configuration-seed INTEGER]\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n\\nAvailable commands:\\n  rearrange                Rearrange keyfiles.\\n  generate-key             Generate keyfile.\\n  generate-vss             Generate VSS certificate.\\n  read-key                 Dump keyfile contents.\\n  generate-avvm-seeds      Generate avvm seeds with public keys.\\n  generate-keys-by-spec    Generate secret keys and avvm seed by\\n                           genesis-spec.yaml\\n  dump-genesis-data        Dump genesis data (as per configuration) in json\\n                           format\\n</code></pre>\\n<h2>cardano-explorer-swagger</h2>\\n<pre><code>Cardano SL Explorer web API docs generator.\\n\\nUsage: cardano-explorer-swagger [--version]\\n  Generate Swagger specification for Explorer web API.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n\\nThis program runs during 'cardano-sl' building on Travis CI. Generated file\\n'explorer-web-api-swagger.json' will be used to produce HTML documentation. This\\ndocumentation will be published at cardanodocs.com using\\n'update-explorer-web-api-docs.sh'.\\n</code></pre>\\n<h2>cardano-node-simple</h2>\\n<pre><code>Cardano SL node.\\n\\nUsage: cardano-node-simple [--version] [--db-path FILEPATH] [--rebuild-db]\\n                           [--genesis-secret INT] [--keyfile FILEPATH]\\n                           [--backup-phrase PHRASE] [--topology FILEPATH]\\n                           [--kademlia FILEPATH] [--node-id NODE_ID]\\n                           [--default-port PORT] [--policies FILEPATH]\\n                           [--address IP:PORT] [--listen IP:PORT]\\n                           [--json-log FILEPATH] [--log-config FILEPATH]\\n                           [--logs-prefix FILEPATH] [--report-server URI]\\n                           [--update-server URI] [--configuration-file FILEPATH]\\n                           [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                           [--configuration-seed INTEGER]\\n                           [--update-latest-path FILEPATH]\\n                           [--update-with-package] [--no-ntp]\\n                           [--route53-health-check IP:PORT] [--metrics]\\n                           [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                           [--statsd-interval MILLISECONDS]\\n                           [--statsd-debug BOOL] [--statsd-prefix TEXT]\\n                           [--statsd-suffix TEXT] [--dump-genesis-data-to ARG]\\n                           [--behavior FILE]\\n  Cardano SL main server node.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --behavior FILE          Path to the behavior config\\n\\nCommand example:\\n\\n  stack exec -- cardano-node                                             \\\\\\n    --db-path node-db0                                                   \\\\\\n    --rebuild-db                                                         \\\\\\n    --keyfile secrets/secret-1.key                                       \\\\\\n    --kademlia-id a_P8zb6fNP7I2H54FtGuhqxaMDAwMDAwMDAwMDAwMDA=           \\\\\\n    --address 127.0.0.1:3000                                             \\\\\\n    --listen 127.0.0.1:3000                                              \\\\\\n    --kademlia-address 127.0.0.1:3000                                    \\\\\\n    --json-log=/tmp/logs/2017-05-22_181224/node0.json                    \\\\\\n    --logs-prefix /tmp/logs/2017-05-22_181224                            \\\\\\n    --log-config /tmp/logs/2017-05-22_181224/conf/node0.log.yaml         \\\\\\n    --kademlia-dump-path /tmp/logs/2017-05-22_181224/dump/kademlia0.dump \\\\\\n    --system-start 1495462345\\n</code></pre>\\n<h2>cardano-launcher</h2>\\n<pre><code>Tool to launch Cardano SL.\\n\\nUsage: cardano-launcher [--version] --node PATH [-n ARG]\\n                        [--node-log-config PATH] [--node-log-path PATH]\\n                        [--wallet PATH] [-w ARG] --updater PATH [-u ARG]\\n                        [--update-archive PATH] [--updater-windows-runner PATH]\\n                        --node-timeout SEC [--report-server URL]\\n                        [--configuration-file FILEPATH]\\n                        [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                        [--configuration-seed INTEGER]\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --node PATH              Path to the node executable.\\n  -n ARG                   An argument to be passed to the node.\\n  --node-log-config PATH   Path to log config that will be used by the node.\\n  --node-log-path PATH     File where node stdout/err will be redirected (def:\\n                           temp file).\\n  --wallet PATH            Path to the wallet executable.\\n  -w ARG                   An argument to be passed to the wallet.\\n  --updater PATH           Path to the updater executable.\\n  -u ARG                   An argument to be passed to the updater.\\n  --update-archive PATH    Path to the update archive, it will be passed to the\\n                           updater.\\n  --updater-windows-runner PATH\\n                           Path to write the Windows batch file executing\\n                           updater\\n  --node-timeout SEC       How much to wait for the node to exit before killing\\n                           it.\\n  --report-server URL      Where to send logs in case of failure.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n\\nCommand example:\\n\\n  stack exec -- cardano-launcher                                   \\\\\\n    --node binaries_v000/cardano-node                              \\\\\\n    --node-log-config scripts/log-templates/update-log-config.yaml \\\\\\n    -n \\\"--update-server\\\"                                           \\\\\\n    -n \\\"http://localhost:3001\\\"                                     \\\\\\n    -n \\\"--update-latest-path\\\"                                      \\\\\\n    -n \\\"updateDownloaded.tar\\\"                                      \\\\\\n    -n \\\"--listen\\\"                                                  \\\\\\n    -n \\\"127.0.0.1:3004\\\"                                            \\\\\\n    -n \\\"--kademlia-id\\\"                                             \\\\\\n    -n \\\"a_P8zb6fNP7I2H54FtGuhqxaMDAwMDAwMDAwMDAwMDA=\\\"              \\\\\\n    -n \\\"--flat-distr\\\"                                              \\\\\\n    -n \\\"(3,100000)\\\"                                                \\\\\\n    -n \\\"--rebuild-db\\\"                                              \\\\\\n    -n \\\"--wallet\\\"                                                  \\\\\\n    -n \\\"--web-port\\\"                                                \\\\\\n    -n 8080                                                        \\\\\\n    -n \\\"--wallet-rebuild-db\\\"                                       \\\\\\n    --updater cardano-updater                                      \\\\\\n    -u \\\"dir\\\"                                                       \\\\\\n    -u \\\"binaries_v000\\\"                                             \\\\\\n    --node-timeout 5                                               \\\\\\n    --update-archive updateDownloaded.tar\\n</code></pre>\\n<h2>cardano-block-gen</h2>\\n<pre><code>Cardano SL blockchain generator\\n\\nUsage: cardano-block-gen [--version] --blocks INT --nodes INT\\n                         [--generated-db FILEPATH] [--append] [--seed INT]\\n                         [--tx-count (INT,INT)] [--tx-max-outs INT]\\n  It generates database of node, corresponding to some correct blockchain\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --blocks INT             Length of blockchain.\\n  --nodes INT              Number of nodes.\\n  --generated-db FILEPATH  Location of generated database.\\n  --append                 If database already exists, append to it.\\n  --seed INT               Custom seed to generate blocks.\\n  --tx-count (INT,INT)     Tx count range.\\n  --tx-max-outs INT        Max number of outputs in tx\\n\\nCommand example:\\n\\n  stack exec -- cardano-block-gen           \\\\\\n    --blocks 5000                           \\\\\\n    --nodes 3                               \\\\\\n    --coins 100                             \\\\\\n    --generated-db /path/to/existed/db      \\\\\\n    --seed 123                              \\\\\\n    --append\\n</code></pre>\\n<h2>cardano-report-server</h2>\\n<pre><code>CardanoSL report server\\n\\nUsage: cardano-report-server [-p|--port INTEGER] [--logsdir FILEPATH]\\n                             [--severity SEVERITY] [--size-limit BYTES]\\n                             [--version]\\n  CardanoSL reporting server daemon\\n\\nAvailable options:\\n  -p,--port INTEGER        Port server is running on\\n  --logsdir FILEPATH       Directory server will be saving logs in\\n  --severity SEVERITY      Logging severity\\n  --size-limit BYTES       Maximum body size allowed (will send 413 responses if\\n                           bigger)\\n  -h,--help                Show this help text\\n  --version                Show version\\n</code></pre>\\n<h2>cardano-dht-keygen</h2>\\n<pre><code>Generator of random key for Kademlia DHT.\\n\\nUsage: cardano-dht-keygen [--version] (-n|--nonce STRING)\\n  Generated key will be print to stdout.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  -n,--nonce STRING        14-characters string.\\n</code></pre>\\n<h2>cardano-explorer-mock</h2>\\n<pre><code>Cardano SL Explorer web mock.\\n\\nUsage: cardano-explorer-mock [--version]\\n  Run mock for Explorer web API.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n\\nThis program returns just the mocked data. It doesn't call any CSL functions and\\ndoesn't interact with it. It just implements the API and returns simeple test\\ndata.\\n</code></pre>\\n<h2>cardano-addr-convert</h2>\\n<pre><code>Tool to convert vending addresses into testnet addresses.\\n\\nUsage: cardano-addr-convert [--version] [-a|--address STRING]\\n  Produce public key and write it in stdout.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  -a,--address STRING      Address to convert. It must be in base64(url) format.\\n\\nCommand example:\\n\\n  stack exec -- cardano-addr-convert -a 2HF83bvYCTzoCbVta6t64W8rFEnvnkJbIUFoT5tOyoU=\\n\\nOutput example:\\n\\n  3mhNKjfhaCT13DjcQ9eMK4VHfZrFxmyXq8SjVPRtz7SWfP\\n\\nYou can also run it without arguments to switch to interactive mode.\\nIn this case each entered vending address is echoed with a testnet address.\\n</code></pre>\\n<h2>cardano-blockchain-analyser</h2>\\n<pre><code>Cardano SL blockchain generator\\n\\nUsage: cardano-blockchain-analyser --db FILEPATH ([-k] | [-m] | [-g] | [-a] |\\n                                   [-b]) [--print-mode [human|csv|table]]\\n                                   [-i|--incremental] [--log-config FILEPATH]\\n                                   [--logs-prefix FILEPATH]\\n                                   [--report-server URI] [--update-server URI]\\n                                   [--configuration-file FILEPATH]\\n                                   [--configuration-key TEXT]\\n                                   [--system-start TIMESTAMP]\\n                                   [--configuration-seed INTEGER]\\n  Analyse a blockchain and spit out useful metrics.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --db FILEPATH            Location of the database where the blockchain is\\n                           stored.\\n  -k                       Display block counts in kilobytes (KB).\\n  -m                       Display block counts in megabytes (MB).\\n  -g                       Display block counts in gigabytes (GB).\\n  -a                       Display block counts using an adaptive multiplier.\\n  -b                       Display block counts in bytes (B).\\n  --print-mode [human|csv|table]\\n                           Select the desidered rendering mode, one between\\n                           'human', 'csv' or 'table'.\\n  -i,--incremental         Run in incremental mode. In this mode, table output\\n                           will be disabled and rendered as a .csv, as is not\\n                           possible to generate nice-looking tables whilst\\n                           reading the blockchain one block at time. You almost\\n                           always want to be using this mode for huge\\n                           blockchains, as it's much more memory efficient.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n\\nCommand example:\\n\\n  cardano-blockchain-analyser --db /path/to/existing/db\\n</code></pre>\\n<h2>cardano-auxx</h2>\\n<pre><code>CLI-based utilities (auxx).\\n\\nUsage: cardano-auxx [--version] COMMAND [--db-path FILEPATH] [--rebuild-db]\\n                    [--genesis-secret INT] [--keyfile FILEPATH]\\n                    [--backup-phrase PHRASE] [--topology FILEPATH]\\n                    [--kademlia FILEPATH] [--node-id NODE_ID]\\n                    [--default-port PORT] [--policies FILEPATH]\\n                    [--address IP:PORT] [--listen IP:PORT] [--json-log FILEPATH]\\n                    [--log-config FILEPATH] [--logs-prefix FILEPATH]\\n                    [--report-server URI] [--update-server URI]\\n                    [--configuration-file FILEPATH] [--configuration-key TEXT]\\n                    [--system-start TIMESTAMP] [--configuration-seed INTEGER]\\n                    [--update-latest-path FILEPATH] [--update-with-package]\\n                    [--no-ntp] [--route53-health-check IP:PORT] [--metrics]\\n                    [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                    [--statsd-interval MILLISECONDS] [--statsd-debug BOOL]\\n                    [--statsd-prefix TEXT] [--statsd-suffix TEXT]\\n                    [--dump-genesis-data-to ARG] [--peer HOST:PORT]\\n                    [--node-enabled]\\n  Cardano SL CLI utilities.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --peer HOST:PORT         Address of a peer.\\n  --node-enabled           Run auxx as a plugin for the node, as opposed to\\n                           running it standalone (default: standalone).\\n\\nAvailable commands:\\n  repl                     Run REPL in console to evaluate the commands.\\n  cmd                      Execute a list of predefined commands.\\n\\nCommand example:\\n\\n  stack exec -- cardano-auxx                                     \\\\\\n    --db-path run/auxx-db                                        \\\\\\n    --rebuild-db                                                 \\\\\\n    --json-log=/tmp/logs/2017-05-22_181224/node0.json            \\\\\\n    --logs-prefix /tmp/logs/2017-05-22_181224                    \\\\\\n    --log-config /tmp/logs/2017-05-22_181224/conf/node0.log.yaml \\\\\\n    --system-start 1495462345                                    \\\\\\n    --peer 127.0.0.1:3001                                        \\\\\\n    repl\\n</code></pre>\\n<h2>cardano-cli-docs</h2>\\n<pre><code>Tool to generate CLI-docs for Cardano SL executable files.\\n\\nUsage: cardano-cli-docs [--version] --bin-dir PATH\\n  Generate Markdown chapter for cardanodocs.com.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --bin-dir PATH           Path to the directory with Cardano SL executable\\n                           files.\\n\\nAssumed that this program will run on Travis CI. Produced file\\n'cardano-cli-docs.md' will be renamed in a chapter and pushed in cardanodocs.com\\nrepository.\\n</code></pre>\\n<h2>cardano-genupdate</h2>\\n<pre><code>Cardano SL updates generator.\\n\\nUsage: cardano-genupdate [--version] --old PATH --new PATH (-o|--output PATH)\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --old PATH               Path to directory with old program.\\n  --new PATH               Path to directory with new program.\\n  -o,--output PATH         Path to output .tar-file with diff.\\n\\nCommand example:\\n\\n  stack exec -- cardano-genupdate --old /tmp/app-v000 --new /tmp/app-v001 -o /tmp/app-update.tar\\n\\nBoth directories must have equal file structure (e.g. they must contain the same\\nfiles in the same subdirectories correspondingly), otherwise 'cardano-genupdate' will fail.\\n\\nPlease note that 'cardano-genupdate' uses 'bsdiff' program, so make sure 'bsdiff' is available in the PATH.\\n</code></pre>\\n<h2>cardano-explorer</h2>\\n<pre><code>Cardano SL explorer.\\n\\nUsage: cardano-explorer [--version] [--db-path FILEPATH] [--rebuild-db]\\n                        [--genesis-secret INT] [--keyfile FILEPATH]\\n                        [--backup-phrase PHRASE] [--topology FILEPATH]\\n                        [--kademlia FILEPATH] [--node-id NODE_ID]\\n                        [--default-port PORT] [--policies FILEPATH]\\n                        [--address IP:PORT] [--listen IP:PORT]\\n                        [--json-log FILEPATH] [--log-config FILEPATH]\\n                        [--logs-prefix FILEPATH] [--report-server URI]\\n                        [--update-server URI] [--configuration-file FILEPATH]\\n                        [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                        [--configuration-seed INTEGER]\\n                        [--update-latest-path FILEPATH] [--update-with-package]\\n                        [--no-ntp] [--route53-health-check IP:PORT] [--metrics]\\n                        [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                        [--statsd-interval MILLISECONDS] [--statsd-debug BOOL]\\n                        [--statsd-prefix TEXT] [--statsd-suffix TEXT]\\n                        [--dump-genesis-data-to ARG] [--web-port PORT]\\n                        [--notifier-port PORT]\\n  Cardano SL main server node w/ explorer.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --web-port PORT          Port for web API. (default: 8100)\\n  --notifier-port PORT     Port for update notifier, the socket.io\\n                           backend. (default: 8110)\\n</code></pre>\\n<h2>cardano-swagger</h2>\\n<pre><code>Cardano SL Wallet web API docs generator.\\n\\nUsage: cardano-swagger [--version]\\n  Generate Swagger specification for Wallet web API.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n\\nThis program runs during 'cardano-sl' building on Travis CI. Generated file\\n'wallet-web-api-swagger.json' will be used to produce HTML documentation. This\\ndocumentation will be published at cardanodocs.com using\\n'update_wallet_web_api_docs.sh'.\\n</code></pre>\\n<h2>cardano-post-mortem</h2>\\n<pre><code>cardano-post-mortem\\n\\nUsage: cardano-post-mortem COMMAND\\n  analyzes the json logs from several directories or focusses on a single\\n  transaction\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n\\nAvailable commands:\\n  overview                 analyzes the json logs from LOGDIRS...\\n  focus                    analyzes transaction FOCUS in log folder LOGDIR\\n  txrelay                  analyzes transaction relays in the json logs from\\n                           LOGDIRS...\\n  throughput               analyzes transaction throughput and waiting time per\\n                           time windows TXWINDOW and WAITWINDOW in the json logs\\n                           from LOGDIRS...\\n</code></pre>\",\"frontmatter\":{\"path\":\"/cn/technical/cli-options/\",\"doc_title\":\"卡尔达诺结算层命令行选项\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}}]}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---cn-dcceafd7ff4dc364fce1.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/content/welcome-text.en.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读论文和实现的差异，然后再阅读协议和实现的文档。 本文档目标读者是 IOHK…\",\"html\":\"<p>亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读论文和实现的差异，然后再阅读协议和实现的文档。</p>\\n<p>本文档目标读者是 IOHK 的开发人员，第三方软件开发人员，审计和致力于实现卡尔达诺结算层或使用卡尔达诺结算层参考实现的咨询人员。</p>\",\"frontmatter\":{\"path\":\"/cn/welcome-text/\",\"doc_title\":null,\"author\":null,\"date\":null,\"language\":\"cn\",\"label\":\"content\",\"keywords\":\"welcome\",\"group\":null}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/en/content/intro.en.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Cardano SL (或卡尔达诺运算层）是由 IOHK 联合爱丁堡大学，雅典大学和康涅狄格大学共同设计开发的一种加密货币。卡尔达诺运算层是基于 Aggelos Kiayias，Alexander Russell，Bernardo David 和 Roman Oliynykov…\",\"html\":\"<h3>Cardano SL</h3>\\n<p>(或卡尔达诺运算层）是由 IOHK 联合爱丁堡大学，雅典大学和康涅狄格大学共同设计开发的一种加密货币。卡尔达诺运算层是基于 Aggelos Kiayias，Alexander Russell，Bernardo David 和 Roman Oliynykov 的白皮书 『乌洛波罗斯：可证明安全的权益证明协议』的 Haskell 实现。</p>\\n<p>您可以将卡尔达诺结算层视为基于比特币重新设计的针对比特币缺陷的自由修复。 有关卡尔达诺结算层和比特币之间的相似之处和差异的更多信息，请阅读『卡尔达诺结算层为什么特别?』。</p>\\n<h3>加密货币基础</h3>\\n<p>在给出加密货币的定义之前，我们先来谈谈为什么我们在意数字货币，特别是加密货币。</p>\\n<h3>我们为什么在意?</h3>\\n<ul>\\n<li>\\n<h4>速度</h4>\\n<p>与传统（也称为法定）中心银行货币，与日元或美元相反，电子货币不需要一个银行系统来转移价值。这一限制的解除，使用数字货币的速度要快于银行业务，尤其是在全球范围内。使用数字货币从大阪转移10美元到丹佛不再需要数天的时间。无论距离如何，所有交易都能迅速完成。</p>\\n</li>\\n<li>\\n<h4>你掌控你自己的钱</h4>\\n<p>所有的商业银行账户所有者在收到支付请求后在合理的时间内只能支付一定的金额。银行体系对任何价值量都有限制，使个人无法迅速撤出或转移大量资金。有加密货币的情况下，持有一种称为密钥这一特殊信息的人就可以随意花钱。没有其他实体有权操纵用户拥有的价值。</p>\\n</li>\\n<li>\\n<h4>匿名</h4>\\n<p>人们可以根据需要，拥有任意多的加密货币地址，从不同的地址接收，消费资产。经营电子商务商店的商家可以拥有一组收款和退款的地址，以及一个用于他们自身需要的单独的个人『钱包』。通过统一的接口控制所有这些钱包，并且不需要登录到多个支付平台，这使得该过程非常节省时间。</p>\\n</li>\\n<li>\\n<h4>安全</h4>\\n<p>你的钱就像可用于消费的密钥一样安全。这意味着将密钥存储在保险箱中的 USB 闪存上相当于让纸币处于安全状态。即使进行了成功的网络攻击，也绝对没有人能够窃取这笔钱。</p>\\n</li>\\n<li>\\n<h4>扩展性</h4>\\n<p>使用一种称为侧链的方法，以及通用加密货币，如卡尔达诺结算层和比特币，就可以启用特定领域的加密货币，例如以太经典。这样一来，通过特定领域的加密货币开发的任何创新产品都可以让参与者在通用的加密货币中保持价值。这样的应用程序的例子有身份管理，游戏和赌博，以及可验证计算。</p>\\n</li>\\n</ul>\\n<h3>什么是加密货币?</h3>\\n<p>加密货币是一种数字货币形式，使用密码来控制价值。密码学提供了一种生成任何类型信息的真实真实性证据的方法。这就是所谓的数字签名。在加密货币中，我们通过签署和发送交易到网络并接收已确认的交易块，生成一个总账（一个提供每个地址有多少钱的信息的数据库）。加密货币通常是分散的，这意味着来自全球各地的许多人通过运行加密货币节点参与总账的生成。因此，必须达成关于总账状况的共识。下一节讨论实现这种共识的两个最重要的方法。</p>\\n<h3>卡尔达诺结算层为什么特别</h3>\\n<p>虽然比特币和卡尔达诺结算层之间有相似之处，但这两个加密货币之间也有很多不同之处。最显着的区别是，比特币是工作量证明类型的加密货币，而卡尔达诺结算层使用权益证明的方法达成共识。这鼓励诚信和长期的参与。</p>\\n<h3>共识算法的目的</h3>\\n<p>共识算法被用来产生新的交易区块，使账本更新状态。每当有人发布一个交易区块时，他们（或者说他们的运行加密货币协议的节点）就必须附上他们已经证明的证据。下面讨论两种类型的证明。</p>\\n<h3>工作量证明和挖矿</h3>\\n<p>工作量证明是加密货币最普遍的共识算法类型。它起源于比特币，加密货币就是这么工作的。为了生成工作证明，计算机必须解决一个挑战。这是难以解决的计算繁重的问题，但解决方案很容易验证。当一台基于网络的工作量证明的计算机找到一个解决方案时，它会将交易发布于同它一起计算的其他计算机。这台计算机会因为产生区块得到交易费和奖励。整个过程被称为挖矿。挖矿是非常耗能的，所需的能源数量在不断增加，这可能导致不健康的竞争。</p>\\n<h3>权益证明和铸币</h3>\\n<p>权益证明是一种生成区块的新方法。由 Aggelos Kiayias 教授领导的 IOHK 科学家们设计了第一个可证明的，称为乌洛波罗斯的权益证明算法。乌洛波罗斯是卡尔达诺结算层的核心。研究小组已经发表了一篇白皮书 ，这封白皮书对于那些拥有加密货币理论背景的人来说是值得一读的。权益证明的核心思想是，不要浪费电力来解决计算繁重的问题，而是选择一个节点来铸造一个新的区块，其概率与这个节点的硬币数量成正相关。如果一个节点有整数个(> 0)的 slot，它被称为 slot 所有人。如果一个节点最终被选中来铸造一个区块，那么这个节点被称为 slot 领导者。您可以在卡尔达诺结算层的股权证明中了解更多关于该流程的信息。</p>\\n<h3>卡尔达诺结算层之上</h3>\\n<p>卡尔达诺结算层被称为『层』是有原因的。这是卡尔达诺平台的第一个组件。最终，它将被扩展到一个控制层，作为一个可信的计算框架来评估一种特殊的证明，以确保一定的计算正确执行。在游戏和赌博中，这样的系统被用于验证随机数生成和游戏结果的真实性。伴随着侧链，它将有可能完成诸如在游戏中公平分配奖金的任务。但是控制层的应用远远超出了游戏和赌博。身份管理，信用系统等将成为卡尔达诺平台的一部分。我们将迭代卡尔达诺钱包应用程序 Daedalus，使其变成一个具有自动加密货币交易功能和合法加密货币交易功能的通用加密货币钱包。</p>\",\"frontmatter\":{\"path\":\"/cn/intro-text/\",\"doc_title\":null,\"author\":null,\"date\":null,\"language\":\"cn\",\"label\":\"content\",\"keywords\":\"intro\",\"group\":null}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-01-index.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读 论文和实现的差异 ，然后再阅读 协议和实现的文档 。 本文档目标读者是 IOHK…\",\"html\":\"<!-- Reviewed at d0868afac50ba6ffcbd95054e65cbf77fa513082 -->\\n<p>亲爱的读者，本文档的目的是让您对于 Cardano 平台技术栈第一层即结算层有所了解。如果您理解了结算层是什么，我们建议您先阅读<a href=\\\"/cardano/differences/\\\">论文和实现的差异</a>，然后再阅读<a href=\\\"/technical/protocols/csl-application-level/\\\">协议和实现的文档</a>。</p>\\n<p>本文档目标读者是 IOHK 的开发人员，第三方软件开发人员，审计和致力于实现卡尔达诺结算层或使用卡尔达诺结算层参考实现的咨询人员。</p>\\n<!-- CARDANO_SL_README_BEGIN_1 -->\\n<h2>什么是卡尔达诺结算层?</h2>\\n<p>Cardano SL（或卡尔达诺运算层）是由 <a href=\\\"https://iohk.io/team\\\">IOHK</a> 联合爱丁堡大学，雅典大学和康涅狄格大学共同设计开发的一种加密货币。卡尔达诺运算层是基于 Aggelos Kiayias，Alexander Russell，Bernardo David 和 Roman Oliynykov 的白皮书 <a href=\\\"https://iohk.io/research/papers/#9BKRHCSI\\\">『乌洛波罗斯：可证明安全的权益证明协议』</a>的 Haskell 实现。</p>\\n<p>您可以将卡尔达诺结算层视为基于比特币重新设计的针对比特币缺陷的自由修复。 有关卡尔达诺结算层和比特币之间的相似之处和差异的更多信息，请阅读<a href=\\\"http://cardanodocs.com/introduction/cn/#%E5%8D%A1%E5%B0%94%E8%BE%BE%E8%AF%BA%E8%BF%90%E7%AE%97%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB\\\">『卡尔达诺结算层为什么特别?』</a>。</p>\\n<!-- CARDANO_SL_README_END_1 -->\\n<h2>加密货币基础</h2>\\n<p>在给出加密货币的定义之前，我们先来谈谈为什么我们在意数字货币，特别是加密货币。</p>\\n<h3>我们为什么在意?</h3>\\n<h4>速度</h4>\\n<p>与传统（也称为法定）中心银行货币，与日元或美元相反，电子货币不需要一个银行系统来转移价值。这一限制的解除，使用数字货币的速度要快于银行业务，尤其是在全球范围内。使用数字货币从大阪转移10美元到丹佛不再需要数天的时间。无论距离如何，所有交易都能迅速完成。</p>\\n<h4>你掌控你自己的钱</h4>\\n<p>所有的商业银行账户所有者在收到支付请求后在合理的时间内只能支付一定的金额。银行体系对任何价值量都有限制，使个人无法迅速撤出或转移大量资金。有加密货币的情况下，持有一种称为<strong>密钥</strong>这一特殊信息的人就可以随意花钱。没有其他实体有权操纵用户拥有的价值。</p>\\n<h4>匿名</h4>\\n<p>人们可以根据需要，拥有任意多的加密货币地址，从不同的地址接收，消费资产。经营电子商务商店的商家可以拥有一组收款和退款的地址，以及一个用于他们自身需要的单独的个人『钱包』。通过统一的接口控制所有这些钱包，并且不需要登录到多个支付平台，这使得该过程非常节省时间。</p>\\n<h4>安全</h4>\\n<p>你的钱就像可用于消费的<strong>密钥</strong>一样安全。这意味着将密钥存储在保险箱中的 USB 闪存上相当于让纸币处于安全状态。即使进行了成功的网络攻击，也绝对没有人能够窃取这笔钱。</p>\\n<h4>扩展性</h4>\\n<p>使用一种称为<a href=\\\"https://www.blockstream.com/sidechains.pdf\\\">侧链</a>的方法，以及通用加密货币，如卡尔达诺结算层和比特币，就可以启用特定领域的加密货币，例如以太经典。这样一来，通过特定领域的加密货币开发的任何创新产品都可以让参与者在通用的加密货币中保持价值。这样的应用程序的例子有身份管理，游戏和赌博，以及可验证计算。</p>\\n<h3>什么是加密货币?</h3>\\n<p>加密货币是一种数字货币形式，使用密码来控制价值。密码学提供了一种生成任何类型信息的真实真实性证据的方法。这就是所谓的<em>数字签名</em>。在加密货币中，我们通过签署和发送交易到网络并接收已确认的交易块，生成一个总账（一个提供每个地址有多少钱的信息的数据库）。加密货币通常是分散的，这意味着来自全球各地的许多人通过运行加密货币节点参与总账的生成。因此，必须达成关于总账状况的共识。下一节讨论实现这种共识的两个最重要的方法。</p>\\n<h2>卡尔达诺结算层为什么特别</h2>\\n<!-- v0.1.0.0 -->\\n<p>虽然比特币和卡尔达诺结算层之间有相似之处，但这两个加密货币之间也有很多不同之处。最显着的区别是，比特币是工作量证明类型的加密货币，而卡尔达诺结算层使用权益证明的方法达成共识。这鼓励诚信和长期的参与。</p>\\n<h3>共识算法的目的</h3>\\n<p>共识算法被用来产生新的交易区块，使账本更新状态。每当有人发布一个交易区块时，他们（或者说他们的运行加密货币协议的节点）就必须附上他们已经证明的证据。下面讨论两种类型的证明。</p>\\n<h3>工作量证明和挖矿</h3>\\n<p>工作量证明是加密货币最普遍的共识算法类型。它起源于比特币，加密货币就是这么工作的。为了生成工作证明，计算机必须解决一个挑战。这是难以解决的计算繁重的问题，但解决方案很容易验证。当一台基于网络的工作量证明的计算机找到一个解决方案时，它会将交易发布于同它一起计算的其他计算机。这台计算机会因为产生区块得到交易费和奖励。整个过程被称为<em>挖矿</em>。挖矿是非常耗能的，所需的能源数量在不断增加，这可能导致不健康的竞争。</p>\\n<h3>权益证明和铸币</h3>\\n<p>权益证明是一种生成区块的新方法。由 <a href=\\\"https://iohk.io/team/aggelos-kiayias/\\\">Aggelos Kiayias 教授</a>领导的 IOHK 科学家们设计了第一个可证明的，称为乌洛波罗斯的权益证明算法。乌洛波罗斯是卡尔达诺结算层的核心。研究小组已经发表了一篇<a href=\\\"https://iohk.io/research/papers/a-provably-secure-proof-of-stake-blockchain-protocol/\\\">白皮书</a> ，这封白皮书对于那些拥有加密货币理论背景的人来说是值得一读的。权益证明的核心思想是，不要浪费电力来解决计算繁重的问题，而是选择一个节点来铸造一个新的区块，其概率与这个节点的硬币数量成正相关。如果一个节点有整数个(> 0)的 <a href=\\\"/cardano/proof-of-stake/#stake\\\">slot</a>，它被称为 slot 所有人。如果一个节点最终被选中来铸造一个区块，那么这个节点被称为 slot 领导者。您可以在<a href=\\\"/cardano/proof-of-stake/\\\">卡尔达诺结算层的股权证明</a>中了解更多关于该流程的信息。</p>\\n<!-- CARDANO_SL_README_BEGIN_2 -->\\n<h2>卡尔达诺结算层之上</h2>\\n<p>卡尔达诺结算层被称为『层』是有原因的。这是卡尔达诺平台的第一个组件。最终，它将被扩展到一个控制层，作为一个可信的计算框架来评估一种特殊的证明，以确保一定的计算正确执行。在游戏和赌博中，这样的系统被用于验证随机数生成和游戏结果的真实性。伴随着侧链，它将有可能完成诸如在游戏中公平分配奖金的任务。但是控制层的应用远远超出了游戏和赌博。身份管理，信用系统等将成为卡尔达诺平台的一部分。我们将迭代卡尔达诺<a href=\\\"https://github.com/input-output-hk/daedalus\\\">钱包应用程序 Daedalus</a>，使其变成一个具有自动加密货币交易功能和合法加密货币交易功能的通用加密货币钱包。</p>\\n<!-- CARDANO_SL_README_END_2 -->\",\"frontmatter\":{\"path\":\"/cn/introduction/\",\"doc_title\":\"介绍\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-04-installation.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"安装 支持的平台 支持的平台包括 Windows, macOS 和 Linux。这是 代达罗斯钱包 的  Windows 和 macOS 平台安装器 。 Linux 平台的安装器将在不久发布。目前来说，有两种方式在 Linux…\",\"html\":\"<!-- Reviewed at d0868afac50ba6ffcbd95054e65cbf77fa513082 -->\\n<h1>安装</h1>\\n<!-- CARDANO_SL_README_BEGIN_3 -->\\n<h2>支持的平台</h2>\\n<p>支持的平台包括 Windows, macOS 和 Linux。这是<a href=\\\"https://github.com/input-output-hk/daedalus\\\">代达罗斯钱包</a>的 <a href=\\\"https://daedaluswallet.io/#download\\\">Windows 和 macOS 平台安装器</a>。</p>\\n<p>Linux 平台的安装器将在不久发布。目前来说，有两种方式在 Linux 上运行卡尔达诺结算层：</p>\\n<ol>\\n<li>从源码构建（推荐方式）。请参考<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/develop/docs/how-to/build-cardano-sl-and-daedalus-from-source-code.md\\\">如何通过源代码构建卡尔达诺结算层以及代达罗斯钱包</a>文档。</li>\\n<li>\\n<p>使用<strong>非官方</strong> Arch Linux 安装包：</p>\\n<ul>\\n<li><a href=\\\"https://aur.archlinux.org/packages/cardano-sl/\\\">cardano-sl</a></li>\\n<li><a href=\\\"https://aur.archlinux.org/packages/daedalus-bridge/\\\">daedalus-bridge</a></li>\\n<li><a href=\\\"https://aur.archlinux.org/packages/daedalus/\\\">daedalus</a></li>\\n</ul>\\n</li>\\n</ol>\\n<!-- CARDANO_SL_README_END_3 -->\",\"frontmatter\":{\"path\":\"/cn/installation\",\"doc_title\":\"安装\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-10-technical.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at d0868afac50ba6ffcbd95054e65cbf77fa513082 -->\\n<h1>卡尔达诺结算层技术细节</h1>\\n<p>对于想要贡献原始客户端，以及想基于卡尔达诺结算层创建自己的客户端的开发人员来说，这一章节是一个起点。尽管如此，这一节将主要覆盖原始客户端，并有所扩展，在一段时间内可以把它当做最初的参考文档</p>\\n<h2>高层次概述</h2>\\n<p>一个卡尔达诺结算层节点是一个区块链节点。运行时，他会找到其他节点(通过 <a href=\\\"http://ast-deim.urv.cat/cpairot/dhts.html\\\">DHT</a>)，然后开始执行区块链的相关任务。</p>\\n<p>卡尔达诺结算层中的时间会以 epochs 划分。epochs 又会以 slots 划分。 Epochs 和 slots 会被编号。 因此，slot <code>(3,5)</code> 被读作『第3个 epochs 的第5个 slot』 (第0个 slot 以及第0个 epoch 也是可以的).</p>\\n<p>卡尔达诺结算层会使用一些常量集, 特殊值定义在\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/bf5dd592b7bf77a68bf71314718dc7a8d5cc8877/core/constants.yaml\\\"><code>constants.yaml</code> 配置文件中</a>。\\n主要有两种：生产模式和开发模式。 在本指南中，我们将参考生产常量。</p>\\n<p>假设卡尔达诺结算层的值是：:</p>\\n<ul>\\n<li>slot 持续时间: 120秒,</li>\\n<li>安全参数 <em>k</em>: 60.</li>\\n</ul>\\n<p>换句话说，<strong>一个 slot 可以持续120秒</strong>, 而一个 epochs有 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/9ee12d3cc9ca0c8ad95f3031518a4a7acdcffc56/core/Pos/Core/Constants/Raw.hs#L161\\\"><code>10×k</code></a>\\n个 slot, 所以它可以持续<strong>1200分钟</strong>或<strong>20个小时</strong>.</p>\\n<p>每个 slot 上有一个节点被称作 slot 领导者。只有这个 slot 有权在这些 slot 中生成一个新区块；这个区块会被加入到区块链中。然而我们并不能确保这个区块一定会被生成(比如 slot 领导者在响应的过程中可能会离线)。</p>\\n<p>此外，slot 领导者可以将其权利委托给另一个节点 <code>N</code>；在这种情况下，节点 <code>N</code> 而非 slot 领导者将有权生成一个新的块。请注意，<code>N</code> 具有委托权的节点不能被称为 slot 领导者，它只是一个委托。</p>\\n<p>理论上可以将 slot 领导者的权力委托给多个节点，但是不推荐，之后会解释原因。此外，使用相同的密钥（即一台计算机上）我们可以运行中多个节点，假设有节点 <code>A</code>, <code>B</code>, <code>C</code>，如果节点 <code>A</code> 被选为 slot 领导者，不仅 <code>A</code> 本身，节点 <code>B</code> 和 <code>C</code> 都能够生成一个新区块。在这种情况下，每一个节点都将发出一个不同的块，网络将分叉 - 每个其他节点将只接受这些并发区块块中的一个。之后，这个分叉将被淘汰。</p>\\n<p>在 epoch 中，节点之间相互发送 MPC 消息，以达成共识，谁将被允许在下一个时期生成区块。Data 消息中的有效载荷 （以及事务）会被包含在块中。</p>\\n<p>一个地址持有的货币（或『股份』）越多，被选择生成一个区块的可能性就越大。请阅读<a href=\\\"/cardano/proof-of-stake/\\\">乌洛波罗斯权益证明算法</a>获取更多细节。</p>\\n<p>简而言之:</p>\\n<ol>\\n<li>发送信息，</li>\\n<li>接收信息/交易/等等，</li>\\n<li>形成一个区块 (如果你是 slot 领导者的话)，</li>\\n<li>重复。</li>\\n</ol>\\n<h2>商业逻辑</h2>\\n<h3>接收者</h3>\\n<p>接收者处理传入的消息并对其作出响应。各种补充的听众不会被覆盖，而是集中在一个接收者上。</p>\\n<p>接收者大多使用<a href=\\\"/technical/protocols/csl-application-level/#invreqdata-and-messagepart\\\">中继框架</a>，其中包括三种类型的消息：</p>\\n<ul>\\n<li><code>Inventory</code> 消息：节点在获取新数据时向网络发布消息。  </li>\\n<li><code>Request</code> 消息：如果某个新数据没有被这个节点获取的话，节点会向其他节点获取在 <code>Inventory</code> 消息中的新数据。  </li>\\n<li><code>Data</code> 消息：节点对 <code>Request</code> 消息回复的数据。<code>Data</code>消息包含具体的数据。</li>\\n</ul>\\n<p>例如，当用户创建新的交易时，钱包将具有交易 ID 的 <code>Inventory</code> 消息发送到网络。如果收到 <code>Inventory</code> 的节点没有该 ID 相关的交易记录，那么它会回复 <code>Request</code> 消息，然后钱包会在 <code>Data</code> 消息中发送该交易信息。节点收到 <code>Data</code> 消息后，将 <code>Inventory</code> 消息发送给 DHT 网络中的邻居，并重复之前的操作。</p>\\n<p>另一个例子 - 区块接收者：<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/src/Pos/Block/Network/Listeners.hs#L30\\\"><code>handleGetHeaders</code></a>，\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/src/Pos/Block/Network/Listeners.hs#L50\\\"><code>handleGetBlocks</code></a>，\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/src/Pos/Block/Network/Listeners.hs#L77\\\"><code>handleBlockHeaders</code></a>。</p>\\n<h3>Worker</h3>\\n<p>一个 Worker 会在一个时间区间内进行重复性的工作. 比如：</p>\\n<ul>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/69e896143cb02612514352e286403852264f0ba3/infra/Pos/Communication/Protocol.hs#L218\\\"><code>onNewSlotWorker</code></a>：在每个插槽的开始时运行。做一些清理，然后运行其他功能。这个 Worker 在这个 epoch 的开始时也会创造了一个 『起始块』。有两种类型的块：『生成块』和『主块』。主块储存在区块链中; 在 epoch 之间，每个节点都会间断性地生成块。主块不会被告知其他节点。但是，如果节点离线一段时间，并且需要同步区块链，节点可以请求其他人的创世区块。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/d01d392d49db8a25e17749173ec9bce057911191/src/Pos/Block/Worker.hs#L69\\\"><code>blkOnNewSlot</code></a>: 创建一个新块（当轮到节点创建一个新块时），并将其发给其他节点。</li>\\n</ul>\\n<h2>权益证明</h2>\\n<p>卡尔达诺结算层的核心基于 乌洛波罗斯 权益证明算法。正如同名的<a href=\\\"https://eprint.iacr.org/2016/889\\\">白皮书</a>所描述的那样。</p>\\n<h2>分叉</h2>\\n<p>通常，一个链（主链）由一个节点维护，但最终可能会出现分叉链。回想一下，只有区块 <code>k</code> 和更多 slot 被认为是稳定的。这样一来，如果接收一个区块，它既不是区块链的一部分也不是 blockchain 的延续，我们首先检查其复杂程度（复杂性是链的长度）是否比我们的大，TODO</p>\\n<p>然后我们开始随后请求来自先前块提供替代链头的节点。如果我们来得深入k插槽前，替代链被拒绝。否则，一旦我们到达我们连锁店中​​存在的区块，替代链就会被添加到存储区。从国家的角度来看，我们存储和维护所有可行的替代链。如果看起来一个替代链比主链更长，那么它们被替换，使替代链成为新的主链。</p>\\n<h2>补充部分</h2>\\n<h3>Slotting</h3>\\n<p>我们使用的共识方案依赖于正确的 slot。更具体地说，它依赖于系统中的节点可以访问的当前时间（小的偏差是可接受的），然后用于确定何时开始和结束任何特定的 slot，并且在该 slot 执行特定的动作。</p>\\n<p>系统开始时间是 <code>(0,0)</code> slot 的时间戳（即，第0 epoch 的第0slot）。</p>\\n<h2>P2P 网络</h2>\\n<h3>Peer 发现</h3>\\n<p>我们使用 Kademlia DHT 进行对等节点的发现。这是基于 <a href=\\\"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf\\\">Kademlia: 基于 XOR 度量的 P2P 信息系统</a> 的哈希表的通用解决方案。</p>\\n<p>简言之，在 Kademlia 网络的每个节点都被提供一个 <code>160</code> 字节的随机生成的 id。节点之间的距离由 <code>XOR</code> 确定。网络以这样的方式组织：节点对于每个相对距离：<code>2^i &#x3C; d &#x3C;= 2^(i+1)</code> 只知道 <code>K</code> (在最初的客户端实现中 <code>K=7</code>)。</p>\\n<p>初始对等节点通过<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia/Implementation.hs#L194\\\">发送</a> Kademlia 的 <code>FIND_NODE</code> 信息完成，它带有以自己节点 ID 作为<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/src/Pos/Constants.hs#L89\\\">预先配置的一组节点</a>以及通过用户命令行输入的节点的参数。我们的实现中会一次<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/infra/Pos/DHT/Real/Real.hs#L228\\\">发送</a>这个请求给所有已知的对等节点，然后等待第一个回复。</p>\\n<p>客户端运行时，每个 Kademlia 协议收集对等节点。已知对等节点在后续启动之间保存，<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia.hs#L197\\\">恢复</a>。对于每个对等体，我们保存其<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia/Types.hs#L42\\\">主机和端口号</a>，以及它们的<a href=\\\"https://github.com/serokell/kademlia/blob/bbdca50c263c6dae251e67eb36a7d4e1ba7c1cb6/src/Network/Kademlia/Types.hs#L70\\\">节点 id</a>。</p>\\n<h3>Messaging</h3>\\n<p>Kademlia 已经提供了已知节点的概念。这样的节点可以被称为<em>邻居</em>。要将消息发送到网络上的所有节点，你可以发送给邻居，它们会将其发送给它们的邻居，依次类推。但有时候我们可能不需要在整个网络上传播消息，而是只将消息发送给邻居。因此我们有三种类型的发送消息：</p>\\n<ul>\\n<li>发送给一个节点，</li>\\n<li>发送给邻居，</li>\\n<li>发送给网络。</li>\\n</ul>\\n<h4>消息类型</h4>\\n<p>为了处理这个，使用三种消息头，并且有两种消息：</p>\\n<ul>\\n<li>简单：发送给一个同伴。</li>\\n<li>广播：试图发送到整个网络，迭代地发送消息到邻居。</li>\\n</ul>\\n<p>广播消息在检索（在处理之前）重新发送给邻居。而且，它们会通过 LRU 缓存检查，已经收到的消息会被忽略。</p>\\n<h3>领导者和富人计算（LRC）</h3>\\n<p>『Slot 领导者』和『富人』是乌洛波罗斯权益证明算法的重要概念。</p>\\n<ul>\\n<li>\\n<p>Slot 领导者：当前 epoch（当前 epoch 的每个 slot） 的 slot 领导者是在而当前 epoch 开始时通过<a href=\\\"/cardano/proof-of-stake/#%E8%BF%BD%E9%9A%8F%E4%B8%AD%E6%9C%AC%E8%81%AA\\\">追随中本聪</a>（FTS）计算的。FTS 使用 <code>shared seed</code>，它是前一个 epoch <a href=\\\"/cardano/proof-of-stake/#%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97\\\">多方计算</a>（MPC）算法的结果：MPC 结果中，一些节点揭露它们的 种子，这些种子的 <code>xor</code> 称为 <code>shared seed</code>。</p>\\n</li>\\n<li>\\n<p>富人：只有已经发送 VSS 证书并且有足够权益的节点才能参与 MPC 算法。在 epoch 的开始，节点必须知道所有潜在的参与者以在这个 epoch 中验证 MPC 消息。富人也是在当前 epoch 的开始计算的。</p>\\n</li>\\n</ul>\\n<p>富人对于其他组件也很重要；例如，更新系统使用富人判断节点是否可以发布更新协议和投票。</p>\\n<p>有两种计算富人的方法：</p>\\n<ul>\\n<li>考虑共同权益 </li>\\n<li>考虑委派权益（乌洛波洛斯提供委派自己权益给其他节点的机会，更多信息请参阅<a href=\\\"/cardano/differences/#%E6%9D%83%E7%9B%8A%E5%A7%94%E6%B4%BE\\\">委派章节</a>。</li>\\n</ul>\\n<p>MPC 和更新系统组件需要具有委派权益的富人，但不需要拥有共同权益的委派组成。</p>\\n<h2>常量</h2>\\n<p>卡尔达诺结算层使用一些基础常量。他们的值经过了协议原作者和独立安全评论员的讨论，因此强烈推荐可选客户端使用这些常量。 </p>\\n<p>这些常量在\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/bf5dd592b7bf77a68bf71314718dc7a8d5cc8877/core/constants.yaml\\\"><code>constants.yaml</code> 配置文件</a>\\n中定义，分为生产环境和开发环境。</p>\",\"frontmatter\":{\"path\":\"/cn/technical\",\"doc_title\":\"技术细节\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-13-for-contributors.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Redirecting...\",\"html\":\"<h1>Redirecting...</h1>\\n<script>\\n    //window.location.replace(\\\"https://github.com/input-output-hk/cardano-sl/blob/develop/CONTRIBUTING.md\\\");\\n</script>\",\"frontmatter\":{\"path\":\"/cn/for-contributors/\",\"doc_title\":\"对于贡献者\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/2017-01-19-glossary.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"术语表 Ada 我们的货币的名字，为纪念  Ada\\nLovelace…\",\"html\":\"<!-- Reviewed at d0d6c2fedefb642744a24b4b0a6d8d7ad11532f6 -->\\n<h1>术语表</h1>\\n<h2>Ada</h2>\\n<p>我们的货币的名字，为纪念 <a href=\\\"https://en.wikipedia.org/wiki/Ada_Lovelace\\\">Ada\\nLovelace</a> 而命名。</p>\\n<h2>地址</h2>\\n<p><a href=\\\"#%E8%8A%82%E7%82%B9\\\">节点</a>的唯一标示符。请阅读<a href=\\\"/cardano/addresses/\\\">卡尔达诺结算层的地址</a>获得更多信息。</p>\\n<h2>余额</h2>\\n<p>请阅读<a href=\\\"/cardano/balance-and-stake/\\\">卡尔达诺结算层的余额和权益</a> 获得解释。</p>\\n<h2>区块</h2>\\n<p><a href=\\\"#%E8%B4%A6%E6%9C%AC\\\">账本</a>的基础元素。请阅读<a href=\\\"/technical/blocks/\\\">卡尔达诺区块</a>获取技术细节。</p>\\n<h2>区块链</h2>\\n<p>请阅读<a href=\\\"#%E8%B4%A6%E6%9C%AC\\\">账本</a>。</p>\\n<h2>卡尔达诺结算层</h2>\\n<p>卡尔达诺 SL (或者说卡尔达诺结算层) 是由 <a href=\\\"https://iohk.io/team\\\">IOHK</a> 设计和开发的去中心化加密货币。为纪念 <a href=\\\"https://en.wikipedia.org/wiki/Gerolamo_Cardano\\\">Gerolamo Cardano</a> 而命名。</p>\\n<h2>掷币</h2>\\n<p>掷币协议是允许两方或多方获得均匀随机值的协议。我们使用掷币协议作为 <a href=\\\"#ssc\\\">SSC</a> 的基础。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>（第36页）以了解掷币协议的更多详情。</p>\\n<h2>一致性算法</h2>\\n<p>分布式系统对于共享数据集合达成一致观点的一种方式。卡尔达诺结算层使用<a href=\\\"/cardano/proof-of-stake/\\\">乌洛波罗斯一致性算法</a>，这是一个基于<a href=\\\"#%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E\\\">权益证明</a>的算法。</p>\\n<h2>加密货币</h2>\\n<p>使用加密协议来生成账本的计算机系统，请阅读<a href=\\\"/introduction/#cryptocurrency-basics\\\">加密货币基础</a>了解更多信息。</p>\\n<h2>代达罗斯</h2>\\n<p>卡尔达诺结算层钱包应用。 它为用户提供一个用户界面, 用户可以管理，发送，收取资金等等。请阅读<a href=\\\"/technical/wallet-frontend/\\\">卡尔达诺结算层钱包应用前端</a>获取更多信息。</p>\\n<h2>去中心化</h2>\\n<p>通过独立节点进行交互操作的计算机系统的概念。在维护共享数据集合，如账本的情况下，需要对数据的一致性和可靠性达成共识。</p>\\n<h2>Epoch</h2>\\n<p>我们将知道谁有权利在每个 slot 中生成一个区块的更长的时间段。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>（第3页）了解技术细节。</p>\\n<h2>追随中本聪</h2>\\n<p>一种随机选择权益所有者在区块链中建立一个新区块的机制，根据协议中的股份数量，按比例获得选举机会。</p>\\n<h2>保证输出交付</h2>\\n<p>保证输出交付是一种机制，能证明诚实方能保证成功完成多方计算（MPC）。我们在 <a href=\\\"#ssc\\\">SSC</a> 中使用 G.O.D.</p>\\n<h2>诚实的大多数</h2>\\n<p>诚实的大多数是指诚实的参与者数量严格大于攻击者数量的情况，即至少 50% + 1 是诚实的大多数。</p>\\n<h2>Kademlia</h2>\\n<p>请阅读<a href=\\\"#%E5%AF%B9%E7%AD%89%E7%82%B9%E5%8F%91%E7%8E%B0\\\">对等点发现</a>。</p>\\n<h2>领导者选举</h2>\\n<p>挑选谁将在下一个 epoch 生成区块的过程。将依据领导者的股权比例选出（参见<a href=\\\"#%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E\\\">权益证明</a>, <a href=\\\"#%E8%BF%BD%E9%9A%8F%E4%B8%AD%E6%9C%AC%E8%81%AA%E7%AE%97%E6%B3%95\\\">追随中本聪算法</a>)。</p>\\n<h2>账本</h2>\\n<p>个人所拥有的价值的数据集合。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>了解技术细节。</p>\\n<h2>Lovelace</h2>\\n<p>我们的货币的最小单位的名称。为纪念 <a href=\\\"https://en.wikipedia.org/wiki/Ada_Lovelace\\\">Ada\\nLovelace</a> 而命名。</p>\\n<h2>铸币</h2>\\n<p>在<a href=\\\"/introduction/#%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E%E5%92%8C%E9%93%B8%E5%B8%81\\\">权益证明和铸币</a>系统中生成新区块的过程。</p>\\n<h2>节点</h2>\\n<p>参与分布式协议系统的计算机程序。请阅读<a href=\\\"/technical/#%E9%AB%98%E5%B1%82%E6%AC%A1%E6%A6%82%E8%BF%B0\\\">高层次概述</a>获取更多细节。</p>\\n<h2>论文</h2>\\n<p>官方协议论文：<a href=\\\"https://eprint.iacr.org/2016/889\\\">乌洛波罗斯：一个可证安全的权益证明区块链协议</a>。请注意，卡尔达诺结算层的实现与论文的实现不同，<a href=\\\"/cardano/differences/\\\">请阅读差异</a>以了解详情。</p>\\n<h2>节点发现</h2>\\n<p>节点运行后找到其他节点的方法。我们使用的节点发现基于 Kademlia DHT。请阅读 <a href=\\\"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf\\\"> Kademlia\\n论文</a>获得技术细节。</p>\\n<h2>Plutus</h2>\\n<p>在卡尔达诺中定义智能协议的强类型纯函数式语言。请阅读 <a href=\\\"/technical/plutus/introduction/\\\">Plutus</a> 获取更多细节。</p>\\n<h2>权益证明</h2>\\n<p>乌洛波罗斯权益证明算法是<a href=\\\"#%E8%AE%BA%E6%96%87\\\">协议</a>中最重要的部分。它定义了<a href=\\\"#%E8%8A%82%E7%82%B9\\\">节点</a>对<a href=\\\"#%E8%B4%A6%E6%9C%AC\\\">账本</a>状态达成共识的方式。请阅读<a href=\\\"/cardano/proof-of-stake/\\\">乌洛波罗斯权益证明算法</a>获取更多细节。</p>\\n<h2>PVSS</h2>\\n<p>公开验证密钥共享模式 (Publicly Verifiable Secret Sharing)是我们在 <a href=\\\"#ssc\\\">SSC</a> 中使用的密码方案。请阅读<a href=\\\"/technical/pvss/\\\">卡尔达诺结算层 PVSS</a> 获取更多细节。</p>\\n<h2>富人</h2>\\n<p>有足够股权参与一些行动的权益所有人。具体来说，有三种类型的动作：随机性生成（<a href=\\\"/technical/leader-selection/\\\">slot 领导者选举过程</a>），<a href=\\\"/technical/delegation/#%E9%87%8D%E9%87%8F%E7%BA%A7%E6%9D%83%E7%9B%8A%E5%A7%94%E6%B4%BE\\\">重量级权益委派</a>，<a href=\\\"/cardano/update-mechanism/#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9B%B4%E6%96%B0%EF%BC%9A%E7%AD%BE%E7%BD%B2%E5%92%8C%E5%AE%A3%E5%B8%83\\\">更新提案的投票</a>。</p>\\n<h2>签名</h2>\\n<p>一种用来生成我们在<a href=\\\"#%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81\\\">加密货币</a>中使用的保证任何类型信息真实性证据的方法。</p>\\n<h2>Slot</h2>\\n<p>在不同节点上显著大于预期的不同时钟数的一小段物理时间。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>(第4页)获取更多技术细节。</p>\\n<h2>Slot 领导者</h2>\\n<p>slot 领导者是一个被选举为有权在当前 slot 创建区块的节点。请阅读<a href=\\\"#%E8%AE%BA%E6%96%87\\\">论文</a>(第7页)获取更多技术细节。</p>\\n<h2>SSC</h2>\\n<p>SSC (Shared Seed Computation) 是 <a href=\\\"#%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE\\\">Slot 领导者选举</a>的一部分。这部分被实现为<a href=\\\"#%E4%BF%9D%E8%AF%81%E8%BE%93%E5%87%BA%E4%BA%A4%E4%BB%98\\\">保证输出交付</a>的<a href=\\\"#%E6%8E%B7%E5%B8%81\\\">掷币</a>协议。作为 SSC 的结果，我们得到一个将用于<a href=\\\"#%E8%BF%BD%E9%9A%8F%E4%B8%AD%E6%9C%AC%E8%81%AA\\\">追随中本聪</a>机制的随机算法。</p>\\n<h2>权益</h2>\\n<p>请阅读 <a href=\\\"/cardano/balance-and-stake/\\\">卡尔达诺结算层的余额和权益</a> 章节获取解释。</p>\\n<h2>权益所有人</h2>\\n<p>一个拥有正数股权的节点。</p>\\n<h2>转账</h2>\\n<p>表示价值转移的数据。请阅读<a href=\\\"/cardano/transactions/\\\">卡尔达诺结算层的转账</a>获取更多细节。</p>\\n<h2>转账费用</h2>\\n<p>请阅读<a href=\\\"/cardano/transaction-fees/\\\">卡尔达诺结算层转账费用</a>章节获取解释。</p>\",\"frontmatter\":{\"path\":\"/cn/glossary\",\"doc_title\":\"术语表\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"base\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-01-proof-of-stake.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"乌洛波罗斯权益证明算法 乌洛波罗斯权益证明算法是协议中最重要的部分。它定义了节点达到 账本 一致性的方式。 乌洛波罗斯算法是唯一一个基于科学证明的安全的区块链权益证明协议。 为什么要有权益证明？ 不选择被比特币采用的 PoW（工作量证明）而选择 PoS…\",\"html\":\"<!-- Reviewed at c4c45ce9a7a8f4aa6d88a32829755196a017f6a1 -->\\n<h1>乌洛波罗斯权益证明算法</h1>\\n<p>乌洛波罗斯权益证明算法是协议中最重要的部分。它定义了节点达到<a href=\\\"/glossary/#ledger\\\">账本</a>一致性的方式。</p>\\n<p>乌洛波罗斯算法是唯一一个基于科学证明的安全的区块链权益证明协议。</p>\\n<h2>为什么要有权益证明？</h2>\\n<p>不选择被比特币采用的 PoW（工作量证明）而选择 PoS (权益证明) 最重要的原因是考虑了能源消耗。运行比特币协议非常消耗资源，据估计，一个比特币的转账所需要的能源是3.8个美国家庭一天消耗的能源。随着越来越多的比特币矿工将资金投入矿业，运行比特币协议的能源要求只会越来越高，他们挖矿的难度也会越来越大。这也是为什么研究人员尽力研究达成共识的替代算法，比如使用所谓的 BFT（Byzantine Fault Tolerant）一致性算法和 PoS 算法。</p>\\n<h2>什么是权益证明算法</h2>\\n<p>权益证明是生成区块的新方法。权益证明的核心思想是，不要浪费电力来解决计算量大的问题，而是选择一个节点来产生（或『铸造』）一个新的区块，其概率与这个节点所拥有的币数量成正比。如果一个节点具有正数（>0）的股权，则被称为权益所有人。如果一个节点最终被选中来铸造新的区块，它被称为『slot 领导者』。</p>\\n<h3>证明</h3>\\n<p>『权益证明』的『证明』部分是指证明交易块是合法的。</p>\\n<h3>权益</h3>\\n<p>『权益』指的是节点上的地址所拥有的相对价值。『相对价值』指的是『卡尔达诺结算层系统中某个节点钱包上的价值除以总价值』。请阅读<a href=\\\"/cardano/balance-and-stake/\\\">卡尔达诺结算层的平衡和权益</a> 章节获取更多信息。</p>\\n<h2>关于 Slot 领导者</h2>\\n<p>有正资产的节点称作权益所有人，只有权益所有人能参与运行协议。权益所有人必须被选举为 slot 领导者才让区块链生成区块。Slot 领导者可能监听到其他节点的交易信息，然后通过密钥生成一个交易区块发给全网。</p>\\n<p>你可以认为 slot 领导者是比特币中的矿工，但上述的一致性协议会确定谁，什么时候能挖矿，能挖到多少矿。</p>\\n<h2>Epochs 和 Slots</h2>\\n<p>乌洛波罗斯协议将物理的时间划分为 <strong>epochs</strong>, 每一个 epoch 又划分为 <strong>slots</strong>:</p>\\n<pre><code>+----------+----------+-------+----------+--------------------> t\\n|  slot 0  |  slot 1  |  ...  |  slot N  |\\n\\n \\\\                                      / \\\\\\n  -------------- epoch M ---------------   -- epoch M+1 -- ...\\n</code></pre>\\n<p>请注意 slot 是相对较短的一段时间（比如20秒）。</p>\\n<p>每个 slot 有且只有一个领导者（slot leader，SL）：</p>\\n<pre><code>+----------+----------+-------+----------+----> t\\n|  slot 0  |  slot 1  |  ...  |  slot N  |\\n\\n    SL 0       SL 1               SL N\\n</code></pre>\\n<p>slot 领导者有权在他的 slot 内生成一个区块。</p>\\n<pre><code>  +------+   +------+           +------+\\n  | Bl 0 |&#x3C;--| Bl 1 |&#x3C;-- ... &#x3C;--| Bl N |\\n  +------+   +------+           +------+\\n+----------+----------+-------+----------+----> t\\n|  slot 0  |  slot 1  |  ...  |  slot N  |\\n\\n    SL 0       SL 1               SL N\\n</code></pre>\\n<p>这意味着 slot 领导者的数量一定等于一个 epoch 内 slots 的数量（不妨设为 <code>N</code>)，因此不可能在一个 epoch 里面生成超过 <code>N</code> 个区块。</p>\\n<p>如果 slot 领导者错过了它的 slot（比如，在那个阶段它离线了），在下一次被选举为领导者之前，它没有权利再生成区块。</p>\\n<p><strong>请注意：</strong> 可以有一个或多个 slots 是空的（即，不生成区块），但在一个 epoch 期间，它必须生成大部分块（至少50%+1）。</p>\\n<h2>Slot 领导者选举是怎么工作的</h2>\\n<p>Slot 领导者从所有的权益所有人中选举。请注意并不是所有的权益所有人能参与这次选举，只有有足够多的权益（比如，总量的2%)才有资格。我们称这些权益所有人为『候选人』</p>\\n<p>在 epoch 的选举中会选举一个 slot 领导者参与下一次 epoch。因此，在 epoch <code>N</code> 结束的时候，我们就能知道 epoch <code>N+1</code> 的 slot 领导者是谁，并且这是不可更改的。</p>\\n<p>你可以把这样的选举当做 『公平抽签』：权益所有人中的任何一个都能成为 slot 领导者。但 PoS 中一个很重要的的思想是，权益所有人拥有的股份越多，它被选举为 slot 领导者的可能性也就越大。</p>\\n<p><strong>请注意：</strong>同一个 epoch，一个权益所有人可以被多次选做 slot 领导者。</p>\\n<h3>多方计算</h3>\\n<p>选举过程的根本问题之一是无偏性。我们需要一些随机性作为选举的基础，这样的话，选举的结果是随机的，公平的，问题是，这个随机性从哪来？</p>\\n<p>多方计算（multiparty computation (MPC) ）方法用来实现这个随机性，每个参选人独立进行一次『投硬币』的行为，然后与其他参选人分享结果。这个想法就是：结果由每个参选人随机产生，但最终它们在相同的最终价值上达成一致。</p>\\n<h4>提交阶段</h4>\\n<p>首先，参选人会产生一个密钥（特殊的随机值）。接着，参选人会形成一个『提交』，这是一个包含加密份额（见下面的解释）以及密码的证明的消息。</p>\\n<p>然后参选人会用密钥来签署这个提交，指定 epoch 编号，附上它的公钥。在这种情况下，每个人都可以知道谁创建了这个提交，以及这个提交属于哪个 epoch。</p>\\n<p>随后，参选人会将其提交交给其他参选人，最终每个参选人都会拿到其他参选人的提交。</p>\\n<p>注意：这些提交将被放入区块中，也就是说它们将成为区块链的一部分。</p>\\n<h4>开启阶段</h4>\\n<p>在这个阶段参选人发送一个『开启』状态，这是一个打开提交的特殊值。一个提交就像一个锁着的盒子（里面有一个密钥），我们需要一个开启的钥匙来打开这个盒子，获取里面的密钥。</p>\\n<p><strong>注意：</strong>所有的开启都将放入区块中，它们会变成区块链的一部分。</p>\\n<h4>恢复阶段</h4>\\n<p>这是最后的阶段。</p>\\n<p>最终，参选者既有提交，也有开启。从理论上来说，一些选民可以是对手。它可以公布它的提交，但<strong>不</strong>公开它的开启。</p>\\n<p>在这种情况下，诚实的选民可以张贴（上面有提到）来重建密钥，这个想法很简单：即使某些选民是对手，选举也能成功结束。</p>\\n<p>随后，参选者验证提交，开启匹配，如果成功，从提交中提取密钥，并从这些密钥中形成种子（随机生成的字符串）。所以所有的选民都会得到相同的种子，并且会被用于追随中本聪算法。</p>\\n<h3>追随中本聪</h3>\\n<p>在参选者获取种子之后（我们需要随机性），他们必须为下一个 epoch 选择特定的 slot 领导者。这时候就引入了追随中本聪算法。它类似于这样：</p>\\n<pre><code>         +-----+\\nSEED --->| FTS |---> ELECTED_SLOT_LEADERS\\n         +-----+\\n</code></pre>\\n<p>我们解释一下 slot 领导者是怎么被选中的。我们将最小的，原子级的币叫做 『<a href=\\\"/glossary/#lovelace\\\">Lovelace</a>』。基本上，因为 slot 领导者只能从权益所有者中选择，账本会生成币的分发。FTS 是一个挑选币的可证算法，当权益所有人 <code>S</code> 的币被选中时，<code>S</code> 就成为一个 slot 领导者。很明显，<code>S</code> 的币越多，他的币被选中的几率也就越大。</p>\\n<p>为什么它被称为『追随中本聪算法』是因为在比特币中，货币的最小单位被称为『聪』，这是为了表彰比特币的发明人中本聪（Satoshi Nakamoto）</p>\\n<h2>大多数都是诚实的</h2>\\n<p>协议的基本假设前提是<strong>大多数都是诚实的</strong>。这意味着至少有 50%+1 的权益所有人是诚实的。在这种情况下，我们可以<strong>证明</strong>攻击者无法打破区块链的<em>持久化</em>和<em>活跃度</em>。欲了解更多信息，请参阅<a href=\\\"/glossary/#paper\\\">论文</a> (2到3页)。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/proof-of-stake/\",\"doc_title\":\"乌洛波罗斯权益证明算法\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-04-differences.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at c4c45ce9a7a8f4aa6d88a32829755196a017f6a1 -->\\n<h1>乌洛波罗斯协议论文与实现的区别</h1>\\n<p>本文档的目标是概述卡尔达诺结算层实现方式与<a href=\\\"/glossary/#%E8%AE%BA%E6%96%87\\\">论文</a>中提供的乌洛波罗斯算法协议规范的不同，并阐明论文中的典型问题。</p>\\n<p>本文档分为四个部分：</p>\\n<ol>\\n<li><em>说明</em> - 阐述在论文中没有提到但实际实现中非常重要的细节。  </li>\\n<li><em>修改</em> - 列出哪些在论文中有说明，但在卡尔达诺结算层中以不同的方式实现。  </li>\\n<li><em>新增功能</em> - 简要概述了在论文中没有介绍但在卡尔达诺结算层中实现的新功能。  </li>\\n<li><em>遗漏</em> - 列出了论文中有描述，但尚未在卡尔达诺结算层中实现的特性。</li>\\n</ol>\\n<h1>说明</h1>\\n<p>这一章节概述需要阐明的任何话题。</p>\\n<h2>时间, Slots, 和同步</h2>\\n<p>在协议的基本模型中，时间被分成称为 slot 的离散单位。但是，没有安全获得足够精度的当前时间的详细方法。</p>\\n<p>在卡尔达诺结算层中，当前时间值从用户的计算机系统时间值获取。</p>\\n<p>我们还有一个功能来通知用户他们的系统时间是否不正确（我们将它与 NTP 服务器的时间进行比较）。这个功能计划将来发布。</p>\\n<h2>投币和可验证的密钥共享</h2>\\n<p>论文中由 Schoenmakers 为卡尔达诺结算层提供 PVSS(Publicly Verifiable Secret Sharing) 方案。但是，卡尔达诺结算层目前使用 <a href=\\\"https://eprint.iacr.org/2017/216.pdf\\\">\\\"SCRAPE: Scalable Randomness Attested by\\nPublic Entities\\\"</a> PVSS 方案 </p>\\n<p>使用 VSS（可验证的密钥分享，Verifiable Secret Sharing）方案时的一个挑战是将用于签名的公钥与用于 VSS 方案的公钥相关联（<code>VssPublicKey</code>）。这是通过引入 <code>VssCertificate</code> 来解决的。这个证书是一个由签名密钥给出的签名，它由一个对 <code>VssPublicKey</code> 以及这个证书的有效时间组成。最初，所有参与随机生成的权益所有者都拥有证书。当出现一个拥有足够股份的新权益所有人时，或现有证书到期时，应该生成一个新的证书并提交给网络。<code>VssCertificate</code> 被存储在区块中。</p>\\n<p>PVSS 方案使用共享验证信息，这也包括了对密钥的提交。它也被用做协议中的提交。PVSS 提交已经在 elliptic curve (TODO)\\nsecp256r1 实现，请参考 <a href=\\\"/technical/pvss/\\\">PVSS 在卡尔达诺结算层的实现</a>获取更多细节。</p>\\n<h2>区块生成时间</h2>\\n<p>在论文中，他们没有明确说明何时 slot 领导者应该生成一个新的区块发送给网络：它可以在 slot 的开始，slot 的结尾，slot 的中间等等。在卡尔达诺结算层中有一个特殊的常量，叫做『网络直径』（network diameter），它接近于将区块广播到网络中所有节点所需的最大时间。例如，如果网络直径值为3，则在 slot 结束前，区块会被生成，并且广播3秒。</p>\\n<h2>权益委派</h2>\\n<p>权益委派，如论文中描述的，不明确规定代理签名证书是否应存储在区块链中（尽管建议存储区块链中的撤销列表）。在区块链没有存储代理签名证书的情况下，几乎没有可能考虑检查委派的股份的阈值合格性。另一方面，如果所有的证书都存储在区块链中，当大部分区块被代理证书占用时，可能会导致区块链膨胀。提交证书是免费的，所以攻击者可以根据需要生成尽可能多的证书。</p>\\n<p>卡尔达诺结算层有两种委派：重量级和轻量级。加入重量级委派有一个门槛。来自重量级代理的代理签名证书存储在区块链中。相反，每个人都可以使用轻量级委派，但证书不会存储在区块链中，在检查资格限制时不会考虑证书，正如论文所建议的，使用委派代理方案。</p>\\n<p>请阅读<a href=\\\"(/technical/delegation/)\\\">卡尔达诺结算层权益委派</a> 获取实现细节。</p>\\n<h1>修改</h1>\\n<h2>领导者选举过程</h2>\\n<p>在论文中，领导者选举过程被描述为翻转币的有偏估计量 <code>(1 - p₁) … (1 - pⱼ₋₁) pⱼ</code>，以判断第 j 个权益所有人是否为给定 slot 的领导者。这里 <code>pⱼ</code> 为选择第 j 个权益所有人的可能性。</p>\\n<p>在卡尔达诺结算层中，它以稍微不同的方式实现。生成 R 个范围为 <code>[0 .. totalCoins]</code> 的随机数，这里 <code>R</code> 为一个 epoch 里面的 slot 数量。权益所有人在这个范围内占据不同的部分，这与他们的股权成正比。这样一来，每个随机数据对应权益所有人。另外，正如论文所建议的，使用一个短的（32位）的种子来初始化 PRG，而不是使用 <code>n ⌈log λ⌉</code> 随机位数。</p>\\n<p>请阅读<a href=\\\"/technical/leader-selection/\\\">卡尔达诺结算层领导者选举</a>获得实现细节。</p>\\n<h2>提交，开放，股权发送</h2>\\n<p>发送时间是在一个很小的时间间隔内随机分配的。这样做是为了避免所有投币者同时发送数据时的网络过载。这个时间间隔必须足够小，以保证协议安全。如果这个数据发送得太晚，则可能会发生数据不包含在区块中的情况。</p>\\n<h2>多个权益所有人</h2>\\n<p>在论文中，每个权益所有人都是基本 VSS 模型的参与者。然而，拥有更多股份的权益所有人比秘密共享股份的权益所有人更重要。例如，如果3个诚实的权益所有人控制了总共60%的股份（每个控制20%），并且有40个敌对权益所有人各持有1%的股份，那么对手就完全控制了秘密股份。</p>\\n<p>为了解决这个问题，卡尔达诺结算层为每个利益相关者分配了一定比例的股份。</p>\\n<h2>随机生成失败</h2>\\n<p>论文没有涵盖提交无法恢复的情况。但是，一个现实的实现应该考虑这种情况。如果没有可以收回的提交，卡尔达诺结算层的实现使用由全零组成的种子。</p>\\n<h1>增加的特性</h1>\\n<h2>更新系统</h2>\\n<p>请查阅这篇文章：<a href=\\\"/cardano/update-mechanism/\\\">更新系统</a>.</p>\\n<h2>P2P 的安全性</h2>\\n<p>请查阅这篇文章：<a href=\\\"/technical/protocols/p2p/\\\">P2P 的实现和强化</a>.</p>\\n<h1>遗漏</h1>\\n<p><em>输入背书人</em>和<em>激励结构</em>还没有实现。这些部分将与侧链悬而未决的研究一起实现，并随侧链的发布一起发布。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/differences/\",\"doc_title\":\"论文与实现的区别\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-07-addresses.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层的地址 要发送和接收价值，基本所有加密货币都使用地址。卡尔达诺结算层支持3种类型的地址： 公钥地址 脚本地址 兑换地址 公钥地址在就像其他的加密货币一样，是个正常的，经过哈希的公钥。 脚本地址被用在一个称为『支付脚本 Hash』（P2SH…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<h1>卡尔达诺结算层的地址</h1>\\n<p>要发送和接收价值，基本所有加密货币都使用地址。卡尔达诺结算层支持3种类型的地址：</p>\\n<ol>\\n<li>公钥地址</li>\\n<li>脚本地址</li>\\n<li>兑换地址</li>\\n</ol>\\n<p>公钥地址在就像其他的加密货币一样，是个正常的，经过哈希的公钥。</p>\\n<p>脚本地址被用在一个称为『支付脚本 Hash』（P2SH）的交易中。它会自动运作，就像银行里的存款一样：你可以向它汇款，但为了兑换这笔钱你必须满足一些特定的条件，条件由于地址相关的脚本决定。地址本身包含着序列化脚本的哈希值。请阅读下面的 <a href=\\\"#pay-to-script-hash\\\">P2SH</a> 获取更多信息。</p>\\n<p>赎回地址是 ADA 赎回的一种特殊地址类型。</p>\\n<p>不仅如此，卡尔达诺结算层还支持 <code>Unknown</code> 地址类型。这种类型可以允许我们在未来使用自定义的地址类型。</p>\\n<h2>地址看起来像什么？</h2>\\n<p>地址是 <code>base58</code> 编码的字符串，例如：</p>\\n<pre><code>Ae2tdPwUPEZKmwoy3AU3cXb5Chnasj6mvVNxV1H11997q3VW5ihbSfQwGpm\\n</code></pre>\\n<h3>编码</h3>\\n<p><code>base58</code> 编码也是比特币中使用的编码。它使用58个符号的字母表来对数据进行编码，这也是它名字的由来。下面就是我们使用的字母表：</p>\\n<pre><code>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\n</code></pre>\\n<p>它去除了非字母数字字符和显示时看起来模棱两可的字母（<code>0</code>, <code>O</code>, <code>I</code>, <code>l</code>）；因此它适用于手动输入数据，从可视化的源代码复制数据的普通用户，并且允许通过双击来简单的拷贝和粘贴，不过双击通常会选择整个字符串。</p>\\n<h2>公钥地址</h2>\\n<p>就像<a href=\\\"/introduction/#you-own-your-money\\\">介绍</a>章节提到的，在用户界面你看到钱包就代表着在这个特定的钱包中你拥有可以花费这笔钱的私钥。但是这样的花销是如何被网络验证，你又如何接收到别人支付给你的钱呢？答案就是跟控制你钱包价值的私钥一起产生的一个公钥。这个公共的部分即指可以被任何人知道，因此叫做『公钥』。</p>\\n<p>一个公钥的地址包含了公钥的哈希值。</p>\\n<p>公钥同时用来在你创建一个交易或其他辅助用途的时候验证你的身份。</p>\\n<h2>P2SH</h2>\\n<p>P2SH 的思想是为花费制定复杂的规则提供很大的灵活性。与发送一笔交易到公钥地址不同，我们创建一个验证脚本，该脚本使用赎回脚本当做参数。为了赎回里面的资金，我们发送一个赎回请求给验证器，然后开始计算。如果计算结果是 <code>success</code>, 钱就会被汇到指定的赎回者那里，否则的话什么都不会发生。</p>\\n<p>引用一下比特币 WiKi：</p>\\n<blockquote>\\n<p>使用 P2SH，你可以将比特币打给一个用多种不常见的方法保护着的地址，不用知道关于该地址安全设置的任何详细信息。接收者可能需要多个人的签名，或一个密码，或一个非常独特的要求才能使用这些比特币。</p>\\n</blockquote>\\n<h2>赎回地址</h2>\\n<p>赎回地址就是 P2PKH。这样的地址包含了赎回公钥的哈希值，并且这个钥匙是 <a href=\\\"http://ed25519.cr.yp.to/\\\">Ed25519</a> 公钥。</p>\\n<h2>其他地址类型</h2>\\n<p>在未来，我们可能会用升级的系统来引入其他地址类型。请阅读<a href=\\\"/cardano/update-mechanism/#soft-fork-updates\\\">查看更多</a> 来了解以无缝升级的方式来扩展系统的相关信息。</p>\\n<h2>地址结构</h2>\\n<p>地址由三部分组成</p>\\n<ul>\\n<li>地址根</li>\\n<li>地址属性</li>\\n<li>地址类型</li>\\n</ul>\\n<p>我们可以把地址想象成类似 JSON 的结构，例如：</p>\\n<pre><code>Address {\\n    addrRoot = AbstractHash e63175c654dfd93a9290342a067158dc0f57a1108ddbd8cace3839bd,\\n    addrAttributes = Attributes {\\n        data: AddrAttributes {\\n            aaPkDerivationPath = Nothing,\\n            aaStakeDistribution = BootstrapEraDistr\\n        } \\n    },\\n    addrType = ATPubKey\\n}\\n</code></pre>\\n<p><code>addrRoot</code> 是由 <code>addrType</code>、<code>addrSpendingData</code>、<code>addrAttributes</code> 组成数组的 BLAKE2b-224 哈希值。</p>\\n<p>addrSpendingData 是一个与地址绑定的特殊值，消费在这个地址的币必须是被公开的。例如，对于公钥来说，这个值就包含着公钥。这样一来，在不知道公钥的时候不可能改变地址属性，因为如果属性改变了，整个地址就变成无效的了。</p>\\n<p><code>addrAttributes</code> 包含了每个地址重要的属性：衍生的路径和权益的分配。</p>\\n<p>想要了解更多关于衍生路径的内容请阅读<a href=\\\"https://cardanodocs.com/technical/hd-wallets/\\\">卡尔达诺结算层的 HD 钱包</a>章节。</p>\\n<p>想要了解更多关于权益分配的内容请阅读<a href=\\\"https://cardanodocs.com/cardano/transactions/#stake-distribution\\\">卡尔达诺结算层的转账</a>章节。</p>\\n<p><code>addrType</code> 的值与上面提到的地址类型相对应，在上面的例子中它是一个公钥地址。</p>\\n<h3>长度</h3>\\n<p>地址的长度可能是不同的，地址长度与地址类型和附加数据有关。</p>\\n<p>例如这个地址：</p>\\n<pre><code>Ae2tdPwUPEZKmwoy3AU3cXb5Chnasj6mvVNxV1H11997q3VW5ihbSfQwGpm\\n</code></pre>\\n<p>以及这个地址：</p>\\n<pre><code>4swhHtxKapQbj3TZEipgtp7NQzcRWDYqCxXYoPQWjGyHmhxS1w1TjUEszCQT1sQucGwmPQMYdv1FYs3d51KgoubviPBf\\n</code></pre>\\n<p>都是公钥地址。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/addresses/\",\"doc_title\":\"地址\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-13-balance-and-stake.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层的余额和权益是怎么运行的 卡尔达诺结算层中有两个重要的概念：余额和权益。这一章将解释着两个概念的差异。 余额 余额是用户真实拥有的币数。当你在计算机上安装了代达罗斯钱包，执行  Ada 兑换 流程时，您会收到一定数量的 Ada 币。这个 Ada…\",\"html\":\"<!-- Reviewed at e070e675764738b5190b2f93424de403f1937216 -->\\n<h1>卡尔达诺结算层的余额和权益是怎么运行的</h1>\\n<p>卡尔达诺结算层中有两个重要的概念：余额和权益。这一章将解释着两个概念的差异。</p>\\n<h3>余额</h3>\\n<p>余额是用户真实拥有的币数。当你在计算机上安装了代达罗斯钱包，执行 <a href=\\\"/timeline/bootstrap/\\\">Ada 兑换</a>流程时，您会收到一定数量的 Ada 币。这个 Ada 币的数量称为你的余额，您可以向其他用户发送一定数量的 Ada 币（在此余额内），也可以从其他用户接收任意数量的 Ada 币。</p>\\n<p>因此，当我们谈到余额时，我们讨论的是用户的实际资金。</p>\\n<h3>权益</h3>\\n<p>与余额（拥有的实际数额）不同，权益是卡尔达诺结算层整个金融系统的关键因素。权益让用户能够控制各种卡尔达诺结算层的算法，比如：成为 slot 领导者，在更新系统中投票，参加 MPC/ SSC，这就是为什么卡尔达诺结算层协议中的所有阈值都以权益，而不是余额来表示。</p>\\n<p>因此，当我们谈到权益时，我们正在讨论用户实际控制卡尔达诺结算层的能力。有关权益的更多信息，请参阅<a href=\\\"/glossary/#%E8%AE%BA%E6%96%87\\\">论文</a></p>\\n<h3>余额和权益的关系</h3>\\n<p>卡尔达诺结算层的每一枚币都与余额和权益相关。我们使用<a href=\\\"/cardano/transactions/#design\\\">交易输出</a>将币 <code>C</code> 与用户余额相关联，并且我们使用股权分配将币 <code>C</code> 与用户权益相关联。</p>\\n<p>注意：可以使用权益委派来更改币和股权之间的关联。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/balance-and-stake/\",\"doc_title\":\"余额和权益\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-10-transactions.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层的转账 概要 一个交易（ tx ) 是一组特殊的数据，代表着节点间价值转移的 行为 （从用户的角度来看就是钱包之间价值的转移）。因此，当用户 Alice 汇款给用户 Bob 时，新的交易就产生了。\\n让我们称该交易为  Tx1 ，Alice 钱包下的节点称为  N…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<h1>卡尔达诺结算层的转账</h1>\\n<h2>概要</h2>\\n<p>一个交易（<strong>tx</strong>) 是一组特殊的数据，代表着节点间价值转移的<em>行为</em>（从用户的角度来看就是钱包之间价值的转移）。因此，当用户 Alice 汇款给用户 Bob 时，新的交易就产生了。\\n让我们称该交易为 <code>Tx1</code>，Alice 钱包下的节点称为 <code>N1</code>，Bob 钱包下的节点称为 <code>N2</code>。</p>\\n<p>节点 <code>N1</code> 会执行下面的步骤：</p>\\n<ul>\\n<li>创建一个 <code>Tx1</code> 交易然后用自己的私钥给交易签名。</li>\\n<li>将交易发送给所有节点（也就是相邻节点）。</li>\\n<li>将该交易保存到本地的数据中。</li>\\n</ul>\\n<p><code>N1</code> 的每个相邻节点也会将 <code>Tx1</code> 发送给自己相邻的节点，依次类推。然后某个领导者会将该笔交易放入到账本中的某个区块里面。请注意，如果网络处于高负荷状态，可能需要很长的时间才能让交易真正地加入到某个区块中。</p>\\n<h2>设计</h2>\\n<p>每个交易都包含了一系列的<em>输入</em>和一系列的<em>输出</em>；交易 <code>Tx0</code> 的输出可以被当用来当做其他如 <code>Tx1</code> 交易的输入，以此类推：</p>\\n<pre><code>            Tx0                           Tx1\\n  +----------------------+      +----------------------+\\n  |                      |      |                      |\\n  |  Inputs     Outputs  |      |  Inputs     Outputs  |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | In0  |   | Out0  + |      | | In0  |   | Out0  | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | In1  |   | Out1  | |      | | In1  |   | Out1  | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | ...  |   | ...   | |      | | ..   |   | ...   | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  | | InN  |   | OutM  | |      | | InN  |   | OutM  | |\\n  | +------+   +-------+ |      | +------+   +-------+ |\\n  |                      |      |                      |\\n  +----------------------+      +----------------------+     ...\\n</code></pre>\\n<p>输入和输出携带着金钱走向的信息：输入告知金钱是从哪里来的，输出告知金钱往哪里去。请注意上面有 N 和 M，是因为实际的情况输入和输出的个数可能并不相同。</p>\\n<p>每个输入包括：</p>\\n<ul>\\n<li>交易 <code>TxN</code> 的 ID，<code>TxN</code> 的输出就是该输入（每笔交易的输出就是另一笔交易的输入）。交易 ID 是一个 BLAKE2b-256 哈希值，就像这样：<code>f9bcbe752aee4512457f1fd350200cf870906b7e6e836688c9a3779645c86c01</code>。  </li>\\n<li>在 <code>TxN</code> 的输出中使用的输出的索引。  </li>\\n</ul>\\n<p>每个输出包括：</p>\\n<ul>\\n<li>节点 <code>N</code> 的地址，该节点就是我们想要发送价值给它的节点。一个地址就是节点 <code>N</code> 的公钥的 BLAKE2b-224 哈希值，大概像这样：<code>1fsAhhf4E1LQDB8agSds8teuD4E7U8JsRESngEX52kinBhi</code>。请阅读<a href=\\\"/cardano/addresses/\\\">卡尔达诺结算层的地址</a>来获取更多信息。</li>\\n<li>我们想要汇款的金额。这是一个64位，无符号的整形数字，最大值为 <code>45000000000000000</code>。</li>\\n</ul>\\n<p>例如：</p>\\n<pre><code>  Tx 891971a4cc31e32..                           Tx f9bcbe752aee4512..\\n------------------------+           +----------------------------------------------+\\n\\\\                       |           |                                              |\\n/        Outputs        |           |       Inputs                  Outputs        |\\n\\\\  +------------------+ |           | +-----------------+     +------------------+ |\\n/  | Out0             | |           | | In0             |     | Out0             | |\\n\\\\  | +--------------+ | |           | | +-------------+ |     | +--------------+ | |\\n/  | | Value        | | |           | | | Tx id       | |     | | Value        | | |\\n\\\\  | | 100 ADA      | | |           | | | 891971a4c.. | |     | | 100 ADA      | | |\\n/  | +--------------+------->>  ------>>+-------------+ |     | +--------------+------->>\\n\\\\  | | Node address | | |           | | | Out index   | |     | | Node address | | |\\n/  | | a00e4bb2..   | | |           | | | 0           | |     | | 88ca7f79..   | | |\\n\\\\  | +--------------+ | |           | | +-------------+ |     | +--------------+ | |\\n/  | ...              | |           | | ...             |     | ...              | |\\n\\\\  +------------------+ |           | +-----------------+     +------------------+ |\\n/                       |           |                                              |\\n------------------------+           +----------------------------------------------+\\n</code></pre>\\n<p>节点 <code>a00e4bb2..</code> 生成交易 <code>f9bcbe752aee4512..</code>，这笔交易告诉我们：</p>\\n<ol>\\n<li>我们想要从地址为 <code>a00e4bb2..</code> 的当前节点发送100 ADA 到地址 <code>88ca7f79..</code> 节点。  </li>\\n<li>这笔钱对应上笔 ID 为 <code>891971a4c..</code> 的交易的第0个输出。</li>\\n</ol>\\n<h2>验证</h2>\\n<p>如上所述，一笔交易的输出会变成另一笔交易的输入。在这种情况下，我们把交易输出称为<em>成交的交易输出</em>。因为它已经是交易 <code>f9bcbe752aee4512..</code> 的输入。</p>\\n<p>但这种成交不会立刻发生，一个<em>还未</em>成为其他交易输入的输出称为<em>未成交的交易输出</em>。为了防止<a href=\\\"https://en.bitcoin.it/wiki/Double-spending\\\">双重支付</a>，只有未成交的输出才能被用来当做其他交易的输入。</p>\\n<p>因此在网络中的每个节点不仅仅接收交易，还会验证它们。为了验证交易，每个节点都必须保持对未成交输出的跟踪，这样就可以验证发布的交易中的输入是未成交的输出。所有未成交的输出叫做 <em>utxo</em>，它也是一个被称为<em>全球状态</em>的特殊键值数据库的一部分。</p>\\n<h2>交易合法性的证明</h2>\\n<p>在卡尔达诺结算层中的每笔交易都有一个证明（也叫做见证）来表明这笔交易是合法的。即使一个输出是一个未成交的输出，我们也应该有权来让它成交。由于一个 <code>TxN</code> 交易可以有多个输入，那么它的见证就包含了 <code>TxN</code> 中所有输入的见证，如果所有的输入都是合法的，<code>TxN</code> 就是合法的。如果某个交易不是合法的，那么网络就会拒绝这笔交易。</p>\\n<p>因为有<a href=\\\"/cardano/addresses/#what-does-an-address-look-like\\\">两种可用的节点地址类型</a>，所以我们使用两种对应版本进行验证：基于公钥的和基于脚本的。</p>\\n<p>例如，基于公钥的验证使用公钥 <code>PK</code> 和交易签名：合法的输入必须使用与 <code>PK</code> 相对应的私钥进行签名。以此来检查这个签名是被接收了还是被拒绝了。</p>\\n<p>验证被存储在区块链中，每个人都可以看见，可以查看，单独验证。但经过一段时间后，节点为了节省空间可能会删除老的证明。分开存储交易和证明被称为『隔离见证』（你可能听到过它，最近在<a href=\\\"https://bitcoincore.org/en/2016/01/26/segwit-benefits/\\\">比特币中实现</a>了）。在这种策略下，交易和证明被存储在两个不同的地方，并且可以独立地进行处理。</p>\\n<h2>权益分配</h2>\\n<p>权益分配是卡尔达诺结算层另一个组成部分，虽然和委派没有直接关系，但都可以通过它来获取相应的利润分红。</p>\\n<p>有些地址有多个拥有者，这也产生了一个权益计算的问题。因为追随中本聪算法的每个币对于每个股东的总权益而言只能计数一次。与余额（余额中的真实币数）不同，权益赋予用户控制算法不同部分的权利：成为领导者、投票更新系统、参加 MPC/SSC。</p>\\n<p>权益分配关联了每个地址的值。技术上来说该值是地址属性的一部分，该值对应于下面三种情况的某一种：</p>\\n<ol>\\n<li>Bootstrap 时代分配。这是一个特殊的值，它是 Bootstrap 时代里的受托者，但是它在 Bootstrap 时代之后还可以使用。 </li>\\n<li>单密钥分配，这是指所有的权益会被分配给一个指定的股东。在这种分配情况下会包含股东的身份。\\n3。 多个密钥分配，这是指权益会被分配给多个股东（至少两个）。在这种分配情况下包含了一对『股东身份-输出部分』的信息。交易的输出有一个值，该值的一部分就是权益。</li>\\n</ol>\\n<p><a href=\\\"http://cardanodocs.com/technical/leader-selection/cn\\\">领导者选举过程</a>和富人计算两者都考虑了权益分配。</p>\\n<p>这个特性可以以类似的方式用在<a href=\\\"http://cardanodocs.com/technical/delegation/cn\\\">委派</a>中，但是有点区别：</p>\\n<ol>\\n<li>没有凭证。要撤销委派 <code>A</code> 必须移动资金，提供不同的权益分配。  </li>\\n<li><code>A</code> 的部分权益可以通过分配来委托。相反的是，委托需要你同时委托全部地址的资金。</li>\\n</ol>\",\"frontmatter\":{\"path\":\"/cn/cardano/transactions/\",\"doc_title\":\"转账\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-16-updating.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"更新研究概览 在更新机制研究中，我们设法提出了一个更新系统，它能够进行不影响生产环境的，几乎无缝的软件更新，并为权益所有人提供投票选择硬分叉（向后不兼容的协议更新）的选项，无需引入任何非协议级别的工具。 我们建议使用权益来对软硬分叉进行投票。 更新系统模型 对于 CSL…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<!-- Updated at 6b5eda44e5942599a9781e5ad3f51eb820665b83 -->\\n<h1>更新研究概览</h1>\\n<p>在更新机制研究中，我们设法提出了一个更新系统，它能够进行不影响生产环境的，几乎无缝的软件更新，并为权益所有人提供投票选择硬分叉（向后不兼容的协议更新）的选项，无需引入任何非协议级别的工具。</p>\\n<p>我们建议使用权益来对软硬分叉进行投票。</p>\\n<h2>更新系统模型</h2>\\n<p>对于 CSL，我们决定在协议层本身增加对协议更新的支持。它给区块链处理带来了一些开销，但有几个重要的好处：</p>\\n<ol>\\n<li>对于每个实现该协议的用户，其最新版本的区块链是已知的。</li>\\n<li>没有中央实体负责维护或分发更新，任何此类更新都是在大多数权益的默认或明确同意下提出的，然后以分布式的方式分发。</li>\\n<li>我们不依赖客户及时更新 PC 上的软件；这是自动完成的，更新通过区块链直接发布。</li>\\n<li>如果在某些版本的 CSL 协议或某些特定实现中检查到任何安全漏洞，将会有一种机制来快速分发更新（仍然在大多数权益的同意下）</li>\\n</ol>\\n<h2>应用程序更新：签署和宣布</h2>\\n<p>这里，我们考虑如何安全地更新应用。协议更新是本文档相关部分涵盖的一个独立问题。</p>\\n<p>要进行更新，首先需要批准其提案。至少有一个协议达成，更新提案才能通过。</p>\\n<ol>\\n<li><strong>明确通过</strong>：它拥有权益的大部分肯定投票（即严格大于 50%）。</li>\\n<li><strong>隐式通过</strong>：权益的肯定投票大于否定投票，并且至少在 <code>U</code> 个 slot 的区块链中。</li>\\n</ol>\\n<p>这个方法似乎自然地适用于 CSL 模型，就像 PoS 加密货币一样。每个权益相关者都负责按照他们股权的相对比例维护系统，区块链则通过权益所有人之间的共识来维持。</p>\\n<p>软件更新也是这个维护过程的一部分，所以权益相关者应该考虑这个可信更新。</p>\\n<h3>隐式通过</h3>\\n<p>权益所有人负责系统更新的事实并不会限制我们每个更新都需要大部分股权签名的系统。我们可以介绍一个<strong>隐式通过</strong>的概念。</p>\\n<p>更新必须至少有在区块链发布的权益签名的最小限度（<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/e26ad11397c87ce8b00f2a26d5e237f54d6ea90a/lib/configuration.yaml\\\">configuration.yaml</a> 中的 <code>updateProposalThd</code>）。权益所有人签署更新是不够的，他们应该赞成或反对。</p>\\n<h3>接入第三方客户</h3>\\n<p>IOHK 将维护一个唯一的官方客户端。但社区维护的第三方客户端也有生存空间。人们需要从权益所有人收集足够多签名来发布他们的系统更新，当然也有可能不是一个『更新』，而是一个从头开始的不同的客户端，或者是官方客户端的一个分支。只要这个更新有足够多的权益所有人的签名，网络就认为它是可信的，可以通过与官方客户端相同的机制进行更新。</p>\\n<h2>应用更新：分发和应用</h2>\\n<p>IOHK 维护的一系列 HTTP 的镜像足够作为开始。</p>\\n<p>在这个过程中，我们计划维护一个基于 Bittorrent 的，或类似 Bittorrent 的解决方案来分发更新。总的来说，基于法律上的考虑，P2P 分发更新是一个至关重要的业务需求。这决定我们将使用哪种类似于 Bittorrent 的解决方案。</p>\\n<p>此外，有趣的是，更新本身并不需要安全且可信的通道来分发，因为它已经预先知道了一些已知的可信密钥（或一组密钥）。</p>\\n<p>应用更新通过 <a href=\\\"https://github.com/mendsley/bsdiff\\\">bsdiff</a> 准备，可以直接或通过安装程序更新。我们正在考虑将来转移到 <a href=\\\"http://dev.chromium.org/developers/design-documents/software-updates-courgette\\\">courgette</a>。</p>\\n<h2>协议更新</h2>\\n<p>首先，我们需要区分软硬协议更新。</p>\\n<p>软分叉会修改区块链共识规则，以便新版本仍然与旧版本客户端兼容，硬分叉则不会与旧版本保持向前兼容。</p>\\n<p><a href=\\\"https://github.com/bitcoin/bips/blob/ed283b05b332b85b6fd683be3a5d73fab6c15554/bip-0099.mediawiki\\\">BIP-99</a> 提供了很好的标准来区分这两种分叉。</p>\\n<ul>\\n<li>一个<strong>软分叉</strong>引入新的规则，对区块进行限制。这样一来，之前无效的仍然无效，而之前有效的一些区块也会变成无效。 </li>\\n<li>硬分叉是一个让之前无效区块变成有效的分叉。</li>\\n</ul>\\n<p>软分叉具有向后兼容等部署优势，不需要大家的共识，因为大多数用户可以添加新的规则。相比之下，硬分叉需要所有用户升级。</p>\\n<p>理论上，硬分叉可能会导致网络分裂为两个部分的情况，每部分都维护一个单独的链：一个来自采用最新系统更新的节点，另一个则来自拒绝这样做的节点。这意味着第一部分的一些区块被另一部分认为是无效的，反之亦然。</p>\\n<p>我们将<strong>协议版本定义为一个元组 <code>(Maj, Min, Alt)</code></strong>：</p>\\n<ul>\\n<li>主版本号（2字节）：很少修改，改变不是向后兼容的，会产生一个硬分叉。</li>\\n<li>\\n<p>次版本号（2字节）：每个更新需要调整的整数</p>\\n<ul>\\n<li>更新应该是向后兼容的，因为新版本生成的区块应该被旧版本以某种方式接受。</li>\\n<li>一个特定的区块可能包含未知类型的地址。对于这种情况，应该找到一个简洁的解决方法，以免影响系统的稳定性和正确性。</li>\\n</ul>\\n</li>\\n<li>替代版本（1字节）：管理多个同时存在的协议更新版本。</li>\\n</ul>\\n<p>协议版本将在应用程序更新中公布，稍后将放入到由更新的软件创建的每个区块中。</p>\\n<p>主版本号的改变会在将来触发硬分叉的问题。</p>\\n<p>次版本的版本更新通知网络后续应用程序更新修改了软分叉的协议。</p>\\n<p>替代版本是新功能的标志。它允许独立开发人员向协议引入多个更改。例如，如果一个供应商决定经由软分叉引入特性 X，另一个引入特性 Y（经过软分叉），他们的软件将以版本 <code>a.b.X</code> 和版本 <code>a.b.Y</code> 生成区块，其可以在区块链上共存，但是，最终只有一个会被采纳。</p>\\n<h2>软分叉更新</h2>\\n<p>在软分叉中，我们可以做什么，不可以做什么，有一条细线：</p>\\n<ol>\\n<li>老版本的客户端应该总是能找到最近的有效区块。（这是 <a href=\\\"https://github.com/bitcoin/bips/blob/ed283b05b332b85b6fd683be3a5d73fab6c15554/bip-0099.mediawiki\\\">BIP-99</a> 所说的『一些无效仍然无效』）</li>\\n<li>较旧版本的客户端发出的某些模块可能会被认为是无效的。</li>\\n</ol>\\n<p>显然，强行推行规则2可能会导致网络分为两部分：一个权益所有人的股份足够大，可以更新，维护自己的链，拒绝其他链，但其他权益所有人还是能够维持链，拒绝这个权益所有人的区块（因为他没有占多数的股份，因此不能追上其他人，所以他的链更短）。一个简单的解决方案规则可能是这样的：如果最新的2016个区块有95%具有较新的区块版本，则旧版本会被拒绝。</p>\\n<p><strong>注意</strong>：此处和之后的<strong>区块版本</strong>和协议版本具有相同的含义。</p>\\n<p>为什么我们想在某个时刻想让某个块版本无效这一点可能不是很清楚。这里关键的一点是，一个新的功能实际上是对我们之前所做的一个限制。例如，目前我们可能有基于公钥或基于脚本的普通旧提交。然后在某个时候，我们决定包含第三种地址类型（不管目的是什么）。我们使用哪种策略来验证具有未知类型地址的提交的区块？显然唯一的选择是不验证这个地址。</p>\\n<p>想象有人提出一个交易到这个地址，可能这么做是带着满足一些条件之前保障资金的意图，一旦条件满足，它们在版本1上的区块花费了其他交易，这是关键的一点。如果网络没有假定旧版本被启用了（因为我们只能在启用旧版本时开始拒绝区块），我们就不能使用限制。（TODO)</p>\\n<p>我们也不能接受所有高于目前所采用的区块的区块，因为在我们的实现中，每个区块都有一个专门用于存储辅助信息的字段。攻击者可以生成她使用了更高版本的协议，并生成一个 <code>attributes</code> 被无意义密钥污染的区块。如果我们接受它，它会使我们的区块链变得臃肿。</p>\\n<p>这是下面要描述的逻辑的动机。</p>\\n<p>在我们实现中，区块版本可以以下面的状态存在：</p>\\n<ul>\\n<li><strong>已采用</strong>，确认区块版本的软分叉规则被触发了（见下文）</li>\\n<li><strong>已确认</strong>，当有包含软件的确认版本和此区块版本的更新提案时。注意，『软件的确认版本』是<a href=\\\"/cardano/update-mechanism/#soft-fork-updates\\\">其他地方</a>的技术术语。如果有多个区块版本，相应的软件被确认，但这些版本不被采用，我们称之为竞争。举例来说，有可能有版本 <code>2.0.0</code>, <code>2.0.1</code>, <code>1.2.0</code>, <code>1.2.1</code>, <code>1.1.1</code> 和 <code>1.1.2</code>，最后通过的版本是 <code>1.1.3</code>。在这种情况，那些竞争的版本是 <code>2.0.0</code>, <code>2.0.1</code>, <code>1.2.0</code> 和 <code>1.2.1</code>。旧版本 <code>1.1.1</code> 和 <code>1.1.2</code> 没有竞争，因为 <code>1.1.3</code> 已经被采纳。</li>\\n<li>其他情况。举例来说，提出一个新的区块版本，但软件版本没有确认。这种状态没有特殊的名字。</li>\\n</ul>\\n<p>软分叉的工作原理如下：</p>\\n<ul>\\n<li>非正式的，当一个确定比例的权益以版本 <code>X</code> 创建区块，区块版本变成<em>已采用</em>。</li>\\n<li>正式的，我们做以下事情。首先回顾一下，我们的系统在设计上，不允许回滚超过某个固定的全局阈值 <code>k</code>，这样可以为每个权益所有者确定稳定的股权。当我们处理创始块 <code>e</code> 时，我们从网络的一开始就计算所有 slot 的所有领导者的稳定股权。对于版本 <code>X</code> 的区块当前竞争的版本，我们取所有版本 <code>X</code> 的稳定版本，收集这些领导者的区块，统计他们的股权。如果其中一个版本大于 75%，则被采纳。如果多于一个版本大于 75%，我们采用其中一个（TODO）。</li>\\n</ul>\\n<p>请注意，采用的区块版本在 epoch 期间（只在 epoch 之间）是不可变的，因此在一个 epoch 中的所有区块都根据相同的规则进行验证（因为规则是由采用的区块版本定义的）。但假设一个 epoch 中的所有区块都具有相同的区块版本是错误的。在采用区块版本之后，另一个区块版本可以竞争，并且一些节点可以使用这个新版本创建区块。</p>\\n<p>所以，总结一下：</p>\\n<ol>\\n<li>一旦确认了更新，协议的版本（比如说 <code>0.5.0</code>）就可以使用了。</li>\\n<li>\\n<p>该节点的行为<em>已</em>被更新（即可以发出，验证新版本的区块）：</p>\\n<ol>\\n<li>在软分叉解决之前（即在解析规则被出发之前），使用新版本 <code>0.5.0</code> 发布区块，但不包括任何新的 <code>attributes</code>（如果有的话）。同区块版本 <code>0.4.0</code> 一样验证 <code>0.5.0</code>。</li>\\n<li>一旦软分叉解决，发布和验证每个版本为 <code>0.5.0</code> 的区块，包括新的 <code>attributes</code></li>\\n</ol>\\n</li>\\n<li>\\n<p>该节点的行为<em>还没有</em>被更新（即不能发出并使用新版本验证模块）：</p>\\n<ol>\\n<li>软分叉解决之前，发行并验证每个版本为 <code>0.4.0</code> 的区块。除此之外，任何包含未知 <code>attributes</code> 的区块都不会被接受</li>\\n<li>一旦软分叉解决，开始接收所有版本为 <code>0.5.0</code> 的区块，包括有未知 <code>attributes</code> 的区块。同时也验证 <code>0.4.0</code> 的版本。</li>\\n</ol>\\n</li>\\n</ol>\\n<h2>硬分叉更新</h2>\\n<p>硬分叉通过修改后的 PoB（proof of burn）来解决。由于尚未实现，我们从本文中省略本节，并将其作为单独的文档发布。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/update-mechanism/\",\"doc_title\":\"更新机制\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-02-transaction-fees.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<h1>卡尔达诺结算层的转账费用</h1>\\n<h2>驱动力</h2>\\n<p>卡尔达诺结算层需要交易费主要因为两个原因：</p>\\n<ol>\\n<li>\\n<p>人们运行卡尔达诺结算层完整节点，需要花费时间、金钱和经历来运行协议，为此他们应得到补偿和奖励。在卡尔达诺结算层中与比特币不同的是，当新货币在每个区块被挖出时，交易费用是协议参与者的唯一收入来源。</p>\\n</li>\\n<li>\\n<p>第二个原因是为了防 DDoS（分布式拒绝服务攻击）。在 DDoS 攻击者，攻击者尝试用虚假交易来冲击网络，如果他必须为每个虚假交易支付足够高的费用，这种攻击形式对于他来说就过于昂贵了。</p>\\n</li>\\n</ol>\\n<h2>交易费用如何运作</h2>\\n<p>每当有人想要转移一定数量的 Ada，这笔转账就会有一个最低的转账费。如果想让这个交易有效，必须包含这笔很小的费用，尽管发送者可以选择支付更高的费用。</p>\\n<p>请阅读<a href=\\\"#transaction-fees-distribution\\\">下面</a>的交易分配方式。</p>\\n<h2>最低转账费</h2>\\n<p>一笔转账的最低费用通过下面的公式计算：</p>\\n<pre><code>a + b × size\\n</code></pre>\\n<p>其中:</p>\\n<ul>\\n<li><code>a</code> 是一个特殊常量，目前是 0.155381 ADA;</li>\\n<li><code>b</code> 是一个特殊常量，目前是 0.000043946 ADA/byte;</li>\\n<li><code>size</code> 是以字节为单位的转账数据大小</li>\\n</ul>\\n<p>这意味着每笔交易至少需要 0.155381 ADA, 每字节的交易需要额外的 0.000043946 ADA。例如，大小为200字节（相当典型的大小）的转账费用是：</p>\\n<pre><code>0.155381 ADA + 0.000043946 ADA/byte × 200 byte = 0.1641702 ADA.\\n</code></pre>\\n<p>有参数 <code>a</code> 的原因是为了防止上面提到的 DDoS 攻击：即使是非常小的虚假交易也要花费足够的代价，以此来防止试图产生成千上万交易的攻击者。</p>\\n<p>引入参数 <code>b</code> 用来反映实际成本：存储更大的交易比存储更小的交易需要更多计算机内存，因此数据量更大的交易应该比数据量小的交易收费更贵。</p>\\n<p>虽然是通过特定参数 <code>a</code> 和 <code>b</code> 计算的，这些值可能会在未来进行调整，以更好地反映实际成本。</p>\\n<h2>交易分配方式</h2>\\n<p>在一个特定 <a href=\\\"http://cardanodocs.com/glossary/cn/#epoch\\\">epoch</a> 中产生的交易费用会被收集到一个虚拟池里，然后将这个池里的资金重新分配给由 PoS 算法选举的那些 <a href=\\\"https://cardanodocs.com/glossary/cn/#slot-leader\\\">slot 领导者</a>。</p>\\n<p>在卡尔达诺结算层这个阶段，所有的区块都是有 IOHK 以及我们的合作伙伴运行的节点创建的，收集了费用（为了防止 DDoS 攻击），但它们不会被重新分配，而是被销毁。</p>\\n<p>不久，卡尔达诺结算层进入下一个阶段，<a href=\\\"https://cardanoroadmap.com/\\\">完全分布式阶段</a>后，费用会按如上所述分配。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/transaction-fees/\",\"doc_title\":\"转账费用\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-01-19-topology.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层网络拓扑 这一篇是卡尔达诺结算层网络拓扑的概述 节点组 虽然卡尔达诺结算层被设计，实现为一个分布式网络，为了防 DDoS…\",\"html\":\"<!-- Reviewed at ba744590c89d8ffa6d6f0919ec11f52202a6d8f2 -->\\n<h1>卡尔达诺结算层网络拓扑</h1>\\n<p>这一篇是卡尔达诺结算层网络拓扑的概述</p>\\n<h2>节点组</h2>\\n<p>虽然卡尔达诺结算层被设计，实现为一个分布式网络，为了防 DDoS，卡尔达诺结算层的实现和拓扑加入了一些额外的功能。当前所有的节点被分为三组：</p>\\n<ul>\\n<li>核心组</li>\\n<li>中继组</li>\\n<li>边缘组</li>\\n</ul>\\n<p>让我们分别讲解一下每组的节点。</p>\\n<h3>核心节点</h3>\\n<p>核心节点是最重要的。</p>\\n<p>就像<a href=\\\"/timeline/bootstrap/#stake-locking\\\">这里</a>描述的, 在 Byron 版本中，我们将会把权益高效地锁定在核心节点联盟上。只有很少的节点能够成为<a href=\\\"/glossary/#slot-leader\\\">领导者</a>，所以只有这些节点能够在这个时期生成新区块。这是网络核心节点能够很好的运行和维护区块链的精髓所在。我们还为核心节点提供了更高的安全级别：我们把它们放在中介节点的中间，因此核心节点与公有网络隔离，并且只允许中继节点和核心节点进行同学。这就是我们减少核心节点被攻击的方法。</p>\\n<p>请注意核心节点永远不会创建货币交易（只有边缘节点可以创建，请看下文）。</p>\\n<h3>中继节点</h3>\\n<p>你可以将中继节点想象为核心节点和公有网络的代理。</p>\\n<p>因为中继节点是不隔离的，所以它们可以被攻击，原则上它们没有状态而且没有权益，所以它们可以被移除，也可以增加数量。如果中继节点崩溃了，会导致拒绝服务，但核心节点（和区块链）的完整性不会受影响。</p>\\n<p>由于中继节点没有任何权益，所以它们不能成为领导者。不仅如此，它们也不能创建货币交易。</p>\\n<p>中继节点是完全被初始股东联合会控制的。</p>\\n<h3>边缘节点</h3>\\n<p>边缘节点是最简单的节点，每个人都可以在自己的电脑上运行边缘节点，只有这些节点可以创建货币交易。</p>\\n<p>由于边缘节点没有任何的权益，它们同中继节点一样不能成为领导者，此外，边缘节点不能直接与核心节点通信，只能与中继节点以及其他边缘节点进行通信。</p>\",\"frontmatter\":{\"path\":\"/cn/cardano/topology/\",\"doc_title\":\"拓扑\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-01-monetary-policy.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺货币政策 ADA 币在卡尔达诺协议发布时发行 启动期间的销售，卖出了 25,927,070,538 个 Ada 币。5,185,414,108 个 ADA 币，相当于所售 ADA 数量的 20%，生成并分发给组成卡尔达诺技术和业务生态系统的三个实体： IOHK…\",\"html\":\"<!-- Reviewed at 1bd2a2f5979233f4f50a7e66ab4e1819ac486400 -->\\n<h1>卡尔达诺货币政策</h1>\\n<div style=\\\"border-radius:5px;padding:5px 10px;background: #cdeffc;\\\" markdown=\\\"1\\\">\\n<h3>ADA 币在卡尔达诺协议发布时发行</h3>\\n<p>启动期间的销售，卖出了 25,927,070,538 个 Ada 币。5,185,414,108 个 ADA 币，相当于所售 ADA 数量的 20%，生成并分发给组成卡尔达诺技术和业务生态系统的三个实体：<a href=\\\"https://iohk.io\\\">IOHK</a>, <a href=\\\"http://emurgo.io/\\\">Emurgo</a> 以及 <a href=\\\"https://cardanofoundation.org/\\\">卡尔达诺基金会</a>。因此 ADA 发布时的总量是 31,112,484,646 个。</p>\\n<h3>ADA 供给量</h3>\\n<p>Ada 币以 45,000,000,000 或者说 450 亿封顶。</p>\\n<h3>卡尔达诺协议运行期间发行的 ADA 币</h3>\\n<p>剩余的 13,887,515,354 个 ADA 币，将在铸币的过程中发行。</p>\\n<p>注意：ADA 的数量永远不会超过 45,000,000,000</p>\\n</div>\\n<h2>财政和费用</h2>\\n<div style=\\\"border-radius:5px;padding:5px 10px;background: #cdeffc;\\\" markdown=\\\"1\\\">\\n这一章将概述财政政策和相关费用。\\n<h3>启动阶段 (发行)</h3>\\n<p>卡尔达诺正处于启动阶段。在这个阶段，交易费没有被收集起来，没有 ADA 被铸造。这一时期的费用会在未来被收集然后他们就会被销毁。</p>\\n<h3>国库</h3>\\n<p>卡尔达诺将有一个国库。这个国库由部分（还没决定）新铸造的 ADA 币以及转账费用捐赠。国库为 ADA 持有者所有。</p>\\n<h3>最小费用 (当前计算方式)</h3>\\n<p>最小费用 = 0.155381 ADA + 0.000043946 (ADA/字节) x 转账数据大小</p>\\n<p>费用计算和激励措施仍在研究中。</p>\\n<h3>面额</h3>\\n<ul>\\n<li>1 ADA = 1,000,000 Lovelaces</li>\\n<li>1 Lovelace = 1/1,000,000 Ada</li>\\n<li>Ada 有6个小数点</li>\\n<li>1.000000 = 1 ADA</li>\\n<li>0.000001 = 1 Lovelace</li>\\n</ul>\\n<p>在货币单位方面有两点考虑。首先在日本，日元面额要大得多，10000 日元相当于 100美元，相当于250亿 ADA 对应 两亿五千万。第二点，与比特币的8位小数不同，ADA 有6位小数，一个 ADA 有100万个 Lovelaces（最小单位）。Adjusting for this takes you to 2.5 million. (TODO)</p>\\n</div>\",\"frontmatter\":{\"path\":\"/cn/cardano/monetary-policy/\",\"doc_title\":\"货币政策\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-05-explorer.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺运算层浏览器 这是卡尔达诺浏览器服务的概述 (下文称作『浏览器』). 浏览器是一个搜索卡尔达诺网络中的地址，转账，epochs，slots 信息的 在线服务 地址 找到一个用户的地址信息是有可能的。在得到一个 hash…\",\"html\":\"<!-- Reviewed at dec0d911d6c4beb8e708ed4076f832ff871f6125 -->\\n<h1>卡尔达诺运算层浏览器</h1>\\n<p>这是卡尔达诺浏览器服务的概述 (下文称作『浏览器』).</p>\\n<p>浏览器是一个搜索卡尔达诺网络中的地址，转账，epochs，slots 信息的<a href=\\\"https://cardanoexplorer.com/\\\">在线服务</a></p>\\n<h2>地址</h2>\\n<p>找到一个用户的地址信息是有可能的。在得到一个 hash 地址后，我们将看到：</p>\\n<ol>\\n<li>与这个地址有关的交易数量</li>\\n<li>这个地址的最终余额</li>\\n<li>这个地址的 QR 码</li>\\n</ol>\\n<p>Hash 地址的例子: <code>1fhXcTriF8i8FFSdCTaU9d3yp3oCLFQhon5KBkevT8rQDPP</code>.</p>\\n<h2>转账</h2>\\n<p>我们可以找到转账的相关信息。在得到一个交易 ID 后，我们将看到：</p>\\n<ol>\\n<li>交易日期和时间</li>\\n<li>交易的来源地址</li>\\n<li>交易的目标地址</li>\\n<li>这次交易转移的 ADA 金额</li>\\n<li>手续费</li>\\n</ol>\\n<p>交易 ID 的例子:</p>\\n<p><code>fe0681c7fe20c27071befc329caac059bb183afaf68b9595744c52125c61cf68</code>.</p>\\n<h2>时间</h2>\\n<p>我们能找到某个时间点的交易信息。目前只能指定 <a href=\\\"/glossary/#epoch\\\">epoch</a> 和 <a href=\\\"/glossary/#slot\\\">slot</a>，在得到 epoch 和 slot 的索引后，我们将看到：</p>\\n<ol>\\n<li>这个 slot 的交易数</li>\\n<li>在这次 slot 中的转移的 ADA 金额</li>\\n<li>在这个 slot 中产生的区块的大小</li>\\n</ol>\\n<h3>Slot</h3>\\n<p>我们可以找到特定 slot 的相关信息。在得到 slot 的 hash 值之后，我们可以看到：</p>\\n<ol>\\n<li>这个 slot 的交易次数</li>\\n<li>总产值</li>\\n<li>这个 slot 的预计 ADA 数量</li>\\n<li>费用</li>\\n<li>slot 的 ID</li>\\n</ol>\\n<p>此外，我们还能得到散列的信息：</p>\\n<ol>\\n<li>slot 的散列</li>\\n<li>前一个 slot 的散列（如果存在的话）</li>\\n<li>下一个 slot 的散列（如果存在的话）</li>\\n<li>The Merkle root. (TODO)</li>\\n</ol>\",\"frontmatter\":{\"path\":\"/cn/cardano/explorer/\",\"doc_title\":\"浏览器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/cardano/2017-02-03-transaction-assurance.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"交易确认层级 下面的表格基于颜色表示确认层级，以确保交易不会被某些分叉取消。 举个例子，在正常的安全级别，如果攻击者的份额是10％（或600万美元，卡尔达诺市值6000万美元），则用户交易的确认级别是： 最低确认（用红色编码） - 当用户的转账确认数小于…\",\"html\":\"<!-- Reviewed at a6a1cdf72c7e167a13f500c0679c01fe4cfa0ca8 -->\\n<style>\\n.full-width {\\n    width: 100%;\\n}\\n\\n.r {\\n    color: white;\\n    background-color: #ef4e4e;\\n    text-align: right;\\n    font-weight: 400;\\n}\\n\\n.y {\\n    color: white;\\n    background-color: #c09e0f;\\n    text-align: right;\\n    font-weight: 400;\\n}\\n\\n.g {\\n    color: white;\\n    background-color: green;\\n    text-align: right;\\n    font-weight: 400;\\n}\\n\\n.gr {\\n    color: white;\\n    background-color: #aaa;\\n    font-weight: 700;\\n}\\n\\n.rd {\\n    background-color: #fca8a8;\\n    text-align: right;\\n    font-weight: 700;\\n}\\n\\n.yd {\\n    background-color: #eccd4a;\\n    text-align: right;\\n    font-weight: 700;\\n}\\n\\n.gd {\\n    background-color: #53d153;\\n    text-align: right;\\n    font-weight: 700;\\n}\\n\\n.center {\\n    text-align: center;\\n}\\n\\n.pct25 {\\n    width: 25%;\\n}\\n</style>\\n<h1>交易确认层级</h1>\\n<p>下面的表格基于颜色表示确认层级，以确保交易不会被某些分叉取消。</p>\\n<p>举个例子，在正常的安全级别，如果攻击者的份额是10％（或600万美元，卡尔达诺市值6000万美元），则用户交易的确认级别是：</p>\\n<ol>\\n<li>最低确认（用红色编码） - 当用户的转账确认数小于<strong>3</strong>个区块时。</li>\\n<li>中等确认（用黄色编码） - 用用户的转账确认数为<strong>3</strong>到<strong>7</strong>块。</li>\\n<li>高度确认（用绿色编码） - 当用户的转账具有<strong>9</strong>个或更多区块的确认时。</li>\\n</ol>\\n<h2>正常安全层级</h2>\\n<p>正常级别可以防攻击（这个模型将包含在最新版本的乌洛波罗斯算法中），表中的数值对应6亿美元的卡尔达诺市值。</p>\\n<table class=\\\"full-width\\\">\\n<tr>\\n    <th class=\\\"center\\\">             攻击者的份额，%</th>\\n    <th class=\\\"center pct25\\\">       攻击者的份额，$ mln </th> \\n    <th colspan=\\\"6\\\" class=\\\"center\\\"> 确认水平         </th>\\n</tr>\\n<tr class=\\\"center\\\">\\n    <td></td>\\n    <td></td>\\n    <td> Low    </td>\\n    <td> 0.950  </td>\\n    <td> 0.990  </td>\\n    <td> 0.995  </td>\\n    <td> 0.999  </td>\\n    <td> High   </td>\\n</tr>\\n<tr>\\n    <td class=\\\"gr\\\"> 10          </td>\\n    <td class=\\\"gr\\\"> 6           </td>\\n    <td class=\\\"rd\\\"> &lt; 3      </td>\\n    <td class=\\\"yd\\\"> 3           </td>\\n    <td class=\\\"yd\\\"> 5           </td>\\n    <td class=\\\"yd\\\"> 7           </td>\\n    <td class=\\\"gd\\\"> 9           </td>\\n    <td class=\\\"gd\\\"> 9 &lt;      </td>\\n</tr>\\n<tr>\\n    <td>            15          </td>\\n    <td>            9           </td>\\n    <td class=\\\"r\\\">  &lt; 5      </td>\\n    <td class=\\\"y\\\">  5           </td>\\n    <td class=\\\"y\\\">  9           </td>\\n    <td class=\\\"y\\\">  11          </td>\\n    <td class=\\\"g\\\">  15          </td>\\n    <td class=\\\"g\\\">  15 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            20          </td>\\n    <td>            12          </td>\\n    <td class=\\\"r\\\">  &lt; 7      </td>\\n    <td class=\\\"y\\\">  7           </td>\\n    <td class=\\\"y\\\">  13          </td>\\n    <td class=\\\"y\\\">  15          </td>\\n    <td class=\\\"g\\\">  21          </td>\\n    <td class=\\\"g\\\">  21 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            25          </td>\\n    <td>            15          </td>\\n    <td class=\\\"r\\\">  &lt; 9      </td>\\n    <td class=\\\"y\\\">  9           </td>\\n    <td class=\\\"y\\\">  19          </td>\\n    <td class=\\\"y\\\">  23          </td>\\n    <td class=\\\"g\\\">  33          </td>\\n    <td class=\\\"g\\\">  33 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            30          </td>\\n    <td>            18          </td>\\n    <td class=\\\"r\\\">  &lt; 17     </td>\\n    <td class=\\\"y\\\">  17          </td>\\n    <td class=\\\"y\\\">  31          </td>\\n    <td class=\\\"y\\\">  39          </td>\\n    <td class=\\\"g\\\">  55          </td>\\n    <td class=\\\"g\\\">  55 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            35          </td>\\n    <td>            21          </td>\\n    <td class=\\\"r\\\">  &lt; 29     </td>\\n    <td class=\\\"y\\\">  29          </td>\\n    <td class=\\\"y\\\">  57          </td>\\n    <td class=\\\"y\\\">  71          </td>\\n    <td class=\\\"g\\\">  101         </td>\\n    <td class=\\\"g\\\">  101 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            40          </td>\\n    <td>            24          </td>\\n    <td class=\\\"r\\\">  &lt; 67     </td>\\n    <td class=\\\"y\\\">  67          </td>\\n    <td class=\\\"y\\\">  133         </td>\\n    <td class=\\\"y\\\">  163         </td>\\n    <td class=\\\"g\\\">  235         </td>\\n    <td class=\\\"g\\\">  235 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            45          </td>\\n    <td>            27          </td>\\n    <td class=\\\"r\\\">  &lt; 269    </td>\\n    <td class=\\\"y\\\">  269         </td>\\n    <td class=\\\"y\\\">  539         </td>\\n    <td class=\\\"y\\\">  661         </td>\\n    <td class=\\\"g\\\">  951         </td>\\n    <td class=\\\"g\\\">  951 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            46          </td>\\n    <td>            27.6        </td>\\n    <td class=\\\"r\\\">  &lt; 421    </td>\\n    <td class=\\\"y\\\">  421         </td>\\n    <td class=\\\"y\\\">  843         </td>\\n    <td class=\\\"y\\\">  1033        </td>\\n    <td class=\\\"g\\\">  1487        </td>\\n    <td class=\\\"g\\\">  1487 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            47          </td>\\n    <td>            28.2        </td>\\n    <td class=\\\"r\\\">  &lt; 751    </td>\\n    <td class=\\\"y\\\">  751         </td>\\n    <td class=\\\"y\\\">  1501        </td>\\n    <td class=\\\"y\\\">  1841        </td>\\n    <td class=\\\"g\\\">  2649        </td>\\n    <td class=\\\"g\\\">  2649 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            48          </td>\\n    <td>            28.8        </td>\\n    <td class=\\\"r\\\">  &lt; 1691   </td>\\n    <td class=\\\"y\\\">  1691        </td>\\n    <td class=\\\"y\\\">  3381        </td>\\n    <td class=\\\"y\\\">  4143        </td>\\n    <td class=\\\"g\\\">  5965        </td>\\n    <td class=\\\"g\\\">  5965 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            49          </td>\\n    <td>            29.4        </td>\\n    <td class=\\\"r\\\">  &lt; 6763   </td>\\n    <td class=\\\"y\\\">  6763        </td>\\n    <td class=\\\"y\\\">  13527       </td>\\n    <td class=\\\"y\\\">  16585       </td>\\n    <td class=\\\"g\\\">  23869       </td>\\n    <td class=\\\"g\\\">  23869 &lt;  </td>\\n</tr>\\n</table>\\n## 严格安全层级\\n<p>严格的安全层级可以防止所有的攻击（它需要更多的块确认）。表中的数值对应6亿美元的卡尔达诺市值。</p>\\n<table class=\\\"full-width\\\">\\n<tr>\\n    <th class=\\\"center\\\">             攻击者的份额，%</th>\\n    <th class=\\\"center pct25\\\">       攻击者的份额，$ mln </th> \\n    <th colspan=\\\"6\\\" class=\\\"center\\\"> 确认水平         </th>\\n</tr>\\n<tr class=\\\"center\\\">\\n    <td></td>\\n    <td></td>\\n    <td> Low    </td>\\n    <td> 0.950  </td>\\n    <td> 0.990  </td>\\n    <td> 0.995  </td>\\n    <td> 0.999  </td>\\n    <td> High   </td>\\n</tr>\\n<tr>\\n    <td class=\\\"gr\\\"> 10          </td>\\n    <td class=\\\"gr\\\"> 6           </td>\\n    <td class=\\\"rd\\\"> &lt; 5      </td>\\n    <td class=\\\"yd\\\"> 5           </td>\\n    <td class=\\\"yd\\\"> 9           </td>\\n    <td class=\\\"yd\\\"> 11          </td>\\n    <td class=\\\"gd\\\"> 15          </td>\\n    <td class=\\\"gd\\\"> 15 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            15          </td>\\n    <td>            9           </td>\\n    <td class=\\\"r\\\">  &lt; 7      </td>\\n    <td class=\\\"y\\\">  7           </td>\\n    <td class=\\\"y\\\">  14          </td>\\n    <td class=\\\"y\\\">  16          </td>\\n    <td class=\\\"g\\\">  23          </td>\\n    <td class=\\\"g\\\">  23 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            20          </td>\\n    <td>            12          </td>\\n    <td class=\\\"r\\\">  &lt; 12     </td>\\n    <td class=\\\"y\\\">  12          </td>\\n    <td class=\\\"y\\\">  21          </td>\\n    <td class=\\\"y\\\">  25          </td>\\n    <td class=\\\"g\\\">  35          </td>\\n    <td class=\\\"g\\\">  35 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            25          </td>\\n    <td>            15          </td>\\n    <td class=\\\"r\\\">  &lt; 19     </td>\\n    <td class=\\\"y\\\">  19          </td>\\n    <td class=\\\"y\\\">  34          </td>\\n    <td class=\\\"y\\\">  40          </td>\\n    <td class=\\\"g\\\">  55          </td>\\n    <td class=\\\"g\\\">  55 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            30          </td>\\n    <td>            18          </td>\\n    <td class=\\\"r\\\">  &lt; 32     </td>\\n    <td class=\\\"y\\\">  32          </td>\\n    <td class=\\\"y\\\">  57          </td>\\n    <td class=\\\"y\\\">  68          </td>\\n    <td class=\\\"g\\\">  94          </td>\\n    <td class=\\\"g\\\">  94 &lt;     </td>\\n</tr>\\n<tr>\\n    <td>            35          </td>\\n    <td>            21          </td>\\n    <td class=\\\"r\\\">  &lt; 63     </td>\\n    <td class=\\\"y\\\">  63          </td>\\n    <td class=\\\"y\\\">  111         </td>\\n    <td class=\\\"y\\\">  132         </td>\\n    <td class=\\\"g\\\">  181         </td>\\n    <td class=\\\"g\\\">  181 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            40          </td>\\n    <td>            24          </td>\\n    <td class=\\\"r\\\">  &lt; 157    </td>\\n    <td class=\\\"y\\\">  157         </td>\\n    <td class=\\\"y\\\">  274         </td>\\n    <td class=\\\"y\\\">  325         </td>\\n    <td class=\\\"g\\\">  443         </td>\\n    <td class=\\\"g\\\">  443 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            45          </td>\\n    <td>            27          </td>\\n    <td class=\\\"r\\\">  &lt; 729    </td>\\n    <td class=\\\"y\\\">  729         </td>\\n    <td class=\\\"y\\\">  1246         </td>\\n    <td class=\\\"y\\\">  1470         </td>\\n    <td class=\\\"g\\\">  1990         </td>\\n    <td class=\\\"g\\\">  1990 &lt;    </td>\\n</tr>\\n<tr>\\n    <td>            46          </td>\\n    <td>            27.6        </td>\\n    <td class=\\\"r\\\">  &lt; 1190   </td>\\n    <td class=\\\"y\\\">  1190        </td>\\n    <td class=\\\"y\\\">  2020        </td>\\n    <td class=\\\"y\\\">  2379        </td>\\n    <td class=\\\"g\\\">  3214        </td>\\n    <td class=\\\"g\\\">  3214 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            47          </td>\\n    <td>            28.2        </td>\\n    <td class=\\\"r\\\">  &lt; 2230   </td>\\n    <td class=\\\"y\\\">  2230        </td>\\n    <td class=\\\"y\\\">  3758        </td>\\n    <td class=\\\"y\\\">  4418        </td>\\n    <td class=\\\"g\\\">  5953        </td>\\n    <td class=\\\"g\\\">  5953 &lt;   </td>\\n</tr>\\n<tr>\\n    <td>            48          </td>\\n    <td>            28.8        </td>\\n    <td class=\\\"r\\\">  &lt; 5382   </td>\\n    <td class=\\\"y\\\">  5382        </td>\\n    <td class=\\\"y\\\">  8986        </td>\\n    <td class=\\\"y\\\">  10542       </td>\\n    <td class=\\\"g\\\">  14157       </td>\\n    <td class=\\\"g\\\">  14157 &lt;  </td>\\n</tr>\\n<tr>\\n    <td>            49          </td>\\n    <td>            29.4        </td>\\n    <td class=\\\"r\\\">  &lt; 24029  </td>\\n    <td class=\\\"y\\\">  24029       </td>\\n    <td class=\\\"y\\\">  39603       </td>\\n    <td class=\\\"y\\\">  46320       </td>\\n    <td class=\\\"g\\\">  61922       </td>\\n    <td class=\\\"g\\\">  61922 &lt;  </td>\\n</tr>\\n</table>\",\"frontmatter\":{\"path\":\"/cn/cardano/transaction-assurance/\",\"doc_title\":\"交易确认层级\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"cardano\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/timeline/2017-01-01-testnet.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at 357ac1f7b4a9f1d98ee7f7bee46e874d7356958f -->\\n<h1>测试网阶段</h1>\\n<p>让社区掌握加密货币，打磨实现，消除可能的缺陷和不稳定性，卡尔达诺测试网络（测试网）是必须的。</p>\\n<p>在测试网阶段，包括奖励机制在内的所有功能都将被激活，任何人都可以从卡尔达诺测试网接口兑换密钥，拿到币。</p>\\n<p>我们鼓励大家下载对应平台的卡尔达诺结算层客户端，从接口获取一些币（我们称它们为 <a href=\\\"/cn/glossary/#lovelace\\\">Lovelace</a>），邀请其他人参与 beta 版本的测试。</p>\\n<p>测试网的结束是卡尔达诺结算层的<a href=\\\"/timeline/bootstrap\\\">发布</a>。</p>\",\"frontmatter\":{\"path\":\"/cn/timeline/testnet/\",\"doc_title\":\"测试网阶段\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"timeline\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/timeline/2017-01-02-bootstrap.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"引导阶段 在卡尔达诺测试网阶段和卡尔达诺结算层发布之后，该网络会在『引导模式』下运行一段时期，称为引导阶段。当购买 Ada…\",\"html\":\"<!-- Reviewed at c23493d7a33a82d559d5bd9d289486795cf6592f -->\\n<h1>引导阶段</h1>\\n<p>在卡尔达诺测试网阶段和卡尔达诺结算层发布之后，该网络会在『引导模式』下运行一段时期，称为引导阶段。当购买 Ada 的人兑换他们的币时，股权将自动被委派给维护网络的可信节点池。在此期间，不会发放任何区块奖励 - 我们将保持网络在线。这是必要的，因为为了协议功能正常，拥有大部分期权的一些权益所有人必须在线，而在网络运行的头几个月，情况并非如此。</p>\\n<p>引导阶段将慢慢进入<a href=\\\"/timeline/reward\\\">奖励阶段</a>，在这期间更新协议将被发布，将为大宗权益所有人提供在云服务器运行的方便选项。</p>\\n<h2>股权锁定</h2>\\n<p>引导阶段存在于卡尔达诺结算层存在的时期，它只允许固定的预定义用户对系统进行控制。这些用户集（引导阶段权益所有人）以及他们各自控制的总权益的比例，在创始区块中定义。</p>\\n<p>引导阶段的目的是为了解决在主网开始的时候，大部分股权可能会脱机（开始时违反协议）的担忧。引导阶段将在网络稳定，并且大部分股权在线时结束。</p>\\n<p>引导阶段之后的下一个阶段被称为<a href=\\\"https://cardanodocs.com/timeline/reward/cn/\\\">奖励阶段</a>，奖励阶段实际上是卡尔达诺结算层作为 PoS 加密货币的『正常』运行模式。</p>\\n<h3>要求</h3>\\n<ol>\\n<li>在引导阶段，卡尔达诺的股权应当被有效地委派给一组固定的密钥 <code>S</code>。</li>\\n<li><code>S</code> = 7</li>\\n<li>股权应该在 <code>s</code> ∈  <code>S</code></li>\\n<li>\\n<p>在引导阶段结束时应该解开股权</p>\\n<ol>\\n<li>Ada 买家能够自己参与协议（或将其权利委派给某个代表 <code>S</code>)。</li>\\n<li>\\n<p>每个 Ada 买方都应该明确声明自己想要控制的股份。</p>\\n<ul>\\n<li>否则，一旦奖励阶段开始，很容易导致在少于大多数股权在线的情况。</li>\\n</ul>\\n</li>\\n<li>在撤销股权行动之前，股权应该仍然由 <code>S</code> 节点控制。</li>\\n</ol>\\n</li>\\n</ol>\\n<h3>提案</h3>\\n<p>现在让我们来看看引导阶段的解决方案：</p>\\n<ol>\\n<li>初始 <code>utxo</code> 包含引导阶段股权所有人的所有股权。初始 <code>utxo</code> 由 <code>(txIn, txOut)</code> 组成，并且每个 <code>txOut</code> 都有一个存有股权分发的地址。所以我们只是以一种将所有币发送给所有股权所有的方式设置分配。</li>\\n<li>引导阶段开始时，用户可以发送更改初始 <code>utxo</code> 的请求。我们为每个交易输出设定股权分配，以将权益分配给引导阶段权益相关者。这有效得使得利益分配是系统不变的。</li>\\n<li>\\n<p>重量级代表团有成因状态。它包含对 <code>(Issuer, ProxySK)</code>，其中 <code>Issuer</code> 是被委托的利益相关者的标识符，<code>ProxySK</code> 是委派的代理密钥。请注意：</p>\\n<ul>\\n<li>代表必须与发行人不同，即不允许撤销；</li>\\n<li>委派人不能成为发行人，即不支持过渡性委派。</li>\\n</ul>\\n</li>\\n<li>当引导阶段结束后，我们禁用股权分配的限制。股权所有人将投票让引导阶段结束：将形成特殊的更新提案，其中一个特定的常量将被适当设置，以触发引导阶段结束的更新提案获得通过。系统的运行方式与引导阶段相同，但用户需要明确说明自己的股份所有权，能承担处理节点的责任。为了获取他的股权，用户应该发送一个交易，指定股权分配的代理密钥（s）。它可能是用户自己拥有的密钥，也可能是某个关键代表（可能是引导阶段股权所有人中的一个或几个）。</li>\\n</ol>\",\"frontmatter\":{\"path\":\"/cn/timeline/bootstrap/\",\"doc_title\":\"引导阶段\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"timeline\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/timeline/2017-01-03-reward.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"奖励阶段 在 引导阶段 之后，奖励阶段将开始。在这个阶段，网络将是完全去中心化，非可信模式。我们预计在这个阶段权益池将会出现，让股权比较少的股民也能获得奖励，因为大股东会让节点时刻保持在线来维护去中心化协议。 系统将会定期收到软件更新，并在不久的将来发布大量新功能。\",\"html\":\"<!-- Reviewed at 357ac1f7b4a9f1d98ee7f7bee46e874d7356958f -->\\n<h1>奖励阶段</h1>\\n<p>在<a href=\\\"/timeline/bootstrap\\\">引导阶段</a>之后，奖励阶段将开始。在这个阶段，网络将是完全去中心化，非可信模式。我们预计在这个阶段权益池将会出现，让股权比较少的股民也能获得奖励，因为大股东会让节点时刻保持在线来维护去中心化协议。</p>\\n<p>系统将会定期收到软件更新，并在不久的将来发布大量新功能。</p>\",\"frontmatter\":{\"path\":\"/cn/timeline/reward/\",\"doc_title\":\"奖励阶段\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"timeline\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-02-launcher.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层启动器 概述 可执行文件  cardano-launcher  是启动卡尔达诺结算层的工具。它实际运行整个卡尔达诺结算层系统（即一个节点，一个钱包）并处理更新。要做到这一点， cardano-launcher  使用两个独立的工具： cardano-node…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺结算层启动器</h1>\\n<h2>概述</h2>\\n<p>可执行文件 <a href=\\\"/technical/cli-options/#cardano-launcher\\\"><code>cardano-launcher</code></a> 是启动卡尔达诺结算层的工具。它实际运行整个卡尔达诺结算层系统（即一个节点，一个钱包）并处理更新。要做到这一点，<a href=\\\"/technical/cli-options/#cardano-launcher\\\"><code>cardano-launcher</code></a> 使用两个独立的工具：<a href=\\\"/technical/cli-options/#cardano-node\\\"><code>cardano-node</code></a> 和 <a href=\\\"https://github.com/input-output-hk/cardano-updater\\\"><code>cardano-updater</code></a>。</p>\\n<p>有关可选项的详细信息，请查阅 <a href=\\\"/technical/cli-options/#cardano-launcher\\\"><code>cardano-launcher</code> 的说明</a>。</p>\\n<h2>场景</h2>\\n<p><code>cardano-launcher</code> 有两种工作场景：客户端场景和服务端场景。如果你在启动过程中用 <code>--wallet</code> 参数提供一个钱包（例如代达罗斯）路径，<code>cardano-node</code> 将在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L178\\\">客户端</a>场景下运行，\\n否则将在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L171\\\">服务端</a>场景下运行。</p>\\n<h3>服务端场景</h3>\\n<p>开始时，有两个步骤：</p>\\n<ol>\\n<li>运行更新程序。</li>\\n<li>运行一个节点。</li>\\n</ol>\\n<p>更新程序的工作<a href=\\\"#%E6%9B%B4%E6%96%B0%E5%99%A8\\\">如下所述</a>。</p>\\n<p>一个节点<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L280\\\">以一个单独的进程运行</a>。之后，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L201\\\">等待，直到节点停止</a>。节点退出后，将检查其退出代码，如果等于 <code>20</code>，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L204\\\">重新启动 launcher</a>，否则我们退出。</p>\\n<p>在退出前日志会<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L207\\\">写入到日志文件</a>。要做到这一点，我们在启动时必须提供两个额外的参数：<code>--report-server</code> 和\\n<code>--node-log</code>。第一个参数定义了收集日志的 URl，第二个参数定义了日志文件的路径。我们将日志<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L343\\\">异步发送到收集日志服务器</a>。请注意 <code>--node-log</code> 参数中的文件必须存在。</p>\\n<h3>客户端场景</h3>\\n<p>当进程开始时，有三个步骤：</p>\\n<ol>\\n<li>运行更新程序。</li>\\n<li>运行一个节点。</li>\\n<li>运行一个钱包。</li>\\n</ol>\\n<p>对于步骤1和2，请参与上面的<a href=\\\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9C%BA%E6%99%AF\\\">服务器场景</a>。</p>\\n<p>钱包<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L227\\\">作为一个独立进程运行</a>。</p>\\n<p>之后，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L228\\\">等待节点或钱包停止</a>。当它停止时，我们会检查它：</p>\\n<ol>\\n<li>如果节点退出了，我们写一条日志（见上面<a href=\\\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9C%BA%E6%99%AF\\\">服务端场景</a>的解释），然后<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L235\\\">等待钱包退出</a>。  </li>\\n<li>如果钱包退出，我们会检查其退出代码，如果它等于 <code>20</code>，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L242\\\">杀死这个节点</a>，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L244\\\">重新启动客户端场景的启动程序</a>。请注意，不会立即杀死这个节点；节点在一定的超时过后才会被终止，其值从上述的 <code>--node-timeout</code> 参数获得。</li>\\n<li>如果钱包退出<em>并且</em>退出码不等于 <code>20</code>，我们立即杀死节点。</li>\\n</ol>\\n<h2>更新器</h2>\\n<p><code>cardano-launcher</code> 另一个非常重要的作用是更新节点。两种场景的公共步骤是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L255\\\">运行更新程序</a>。</p>\\n<p>核心思想非常简单。节点更新是一个特殊的 <code>.tar</code> 存档：它表明节点的旧（当前）版本和新版本之间的区别。这个归档的路径通过 <code>--update-archive</code> 参数获得。\\n因此，<code>cardano-launcher</code> 将该归档应用到该节点，并且在重新启动后可以使用该节点的新版本。</p>\\n<p>请注意，当我们的 <code>cardano-launcher</code> 在客户端场景下运行时，钱包的用户能够看到更新已经准备就绪，并且有两种可能的情况。</p>\\n<p>如果用户<em>同意</em>采用这次更新，钱包立即以退出码 <code>20</code> 退出。在这种情况下，如上所述，启动器重新启动节点并更新应用。</p>\\n<p>如果用户<em>不同意</em>采用这次更新，钱包将继续工作，当时，当它<em>被</em>重新启动（早晚的事情），这个更新<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L223\\\"><em>将</em>被应用</a></p>\\n<p><strong>重要</strong>：更新器同步运行，我们启动它，然后<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L269\\\">等待它完成</a>，如果更新程序<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/194f4876d7b72766f7fe72ed4a1fba828903cae0/src/launcher/Main.hs#L271\\\">成功</a>运行，<code>.tar</code> 文件将被删除。</p>\\n<h3>实现概述</h3>\\n<p>有关卡尔达诺结算层更新系统的更多实现细节，请参阅<a href=\\\"/technical/updater/\\\">这一章</a>。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/launcher/\",\"doc_title\":\"卡尔达诺结算层启动器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-06-explorer.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层浏览器 正如之前提到的，浏览器是一个在卡尔达诺网络中搜索卡尔达诺结算层 转账 ， 地址 ，时间区间（ epochs  和  slots ）信息的服务。 浏览器后端工作流 浏览器利用 命令行参数 选项启动。所有支持的选项都可以通过  cardano-explorer…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺结算层浏览器</h1>\\n<p>正如之前提到的，浏览器是一个在卡尔达诺网络中搜索卡尔达诺结算层<a href=\\\"/glossary/#%E8%BD%AC%E8%B4%A6\\\">转账</a>，<a href=\\\"/glossary/#address\\\">地址</a>，时间区间（<a href=\\\"/glossary/#epoch\\\">epochs</a> 和 <a href=\\\"/glossary/#slot\\\">slots</a>）信息的服务。</p>\\n<h2>浏览器后端工作流</h2>\\n<p>浏览器利用<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/explorer/ExplorerOptions.hs#L25\\\">命令行参数</a>选项启动。所有支持的选项都可以通过 <code>cardano-explorer --help</code> 命令查看。</p>\\n<p>然后，浏览器通过 <code>cardano-sl</code> 库运行『<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/explorer/Main.hs#L74\\\">内部节点</a>』。因此我们可以把浏览器当做有着两个<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/explorer/Main.hs#L70\\\">特殊插件</a> <code>explorerPlugin</code>, <code>notifierPlugin</code> 的普通节点。</p>\\n<p>第一个插件用于<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/e343db1def575cc2a47d9168414c22c2599c50e6/src/Pos/Explorer/Web/Api.hs#L25\\\">浏览器 web API</a>，第二个启动<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/e343db1def575cc2a47d9168414c22c2599c50e6/src/Pos/Explorer/Socket/App.hs#L164\\\">通知服务器</a>，这个基于 websocket 的服务器通知前端关于区块/转账的修改。</p>\\n<h2>浏览器后端 API</h2>\\n<p>目前，浏览器后端 Web API 提供了一系列从卡尔达诺网络获取信息的方法。<code>servant</code> 库提供了很多构建 API 的方法模块。该库使用组合器来构建 HTTP 原子操作，并将这些原子方法组合在一起形成更大，更完整的 API。</p>\\n<h3>HTTP API</h3>\\n<p>浏览器 web api 在<a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/Pos/Explorer/Web/Api.hs#L25\\\">这里</a>定义。如果事件请求失败，则有一个 <a href=\\\"https://github.com/input-output-hk/cardano-sl-explorer/blob/f64fb137415c03e8569129067a7798bb8a51456c/src/Pos/Explorer/Web/Error.hs#L11\\\"><code>ExplorerError</code></a> 类型，它简单地封装在 <code>Text</code> 里面，以显示发生了什么。</p>\\n<p>浏览器 Web API 的文档可以在<a href=\\\"https://cardanodocs.com/technical/explorer/api/\\\">这里</a>找到。</p>\\n<h3>socket.io API</h3>\\n<p>目前我们有这些事件客户可以订阅到：</p>\\n<pre><code class=\\\"language-haskell\\\">data ClientEvent\\n    = Subscribe Subscription\\n    | Unsubscribe Subscription\\n    | CallMe\\n</code></pre>\\n<p>订阅可以是以下事件：</p>\\n<pre><code class=\\\"language-haskell\\\">data Subscription\\n    = SubAddr\\n    | SubBlockLastPage\\n    | SubTx\\n</code></pre>\\n<p>相应的服务器事件是：</p>\\n<pre><code class=\\\"language-haskell\\\">data ServerEvent\\n    = AddrUpdated\\n    | BlocksLastPageUpdated\\n    | TxsUpdated\\n    | CallYou\\n</code></pre>\\n<p>用户可以调用所需的事件并订阅它们：</p>\\n<pre><code class=\\\"language-js\\\">var client = require('socket.io-client');\\nvar socket = client('http://localhost:8110');\\n\\nsocket.on('CallYou', function(msg){ console.log(msg); })\\nsocket.emit('CallMe', 'test');\\n</code></pre>\\n<p>你也可以尝试运行 purescript repl（<code>pulp psci</code> ），尝试一下事件：</p>\\n<pre><code class=\\\"language-purescript\\\">import Prelude\\nimport Control.SocketIO.Client\\nimport Control.Monad.Eff.Console\\n\\nlet socket = connect \\\"http://localhost:8110\\\"\\n\\nsocket >>= \\\\soc -> emit soc \\\"CallYou\\\" \\\"test\\\"\\n</code></pre>\",\"frontmatter\":{\"path\":\"/cn/technical/explorer/\",\"doc_title\":\"卡尔达诺结算层浏览器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-02-14-leader-selection.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层中的领导者选举 这一章描述 领导者 选举过程。 追随中本聪算法 如 前 所述，卡尔达诺结算层使用追随中本聪算法（FTS）来选择领导者。每个当前 epoch 的领导者在当前 epoch 开始的时候，由 FTS…\",\"html\":\"<!-- Reviewed at e1d0f9fb37a3f1378341716916f0321fb55698df -->\\n<h1>卡尔达诺结算层中的领导者选举</h1>\\n<p>这一章描述<a href=\\\"/glossary/#slot-leader\\\">领导者</a>选举过程。</p>\\n<h2>追随中本聪算法</h2>\\n<p>如<a href=\\\"/cardano/proof-of-stake/#follow-the-satoshi\\\">前</a>所述，卡尔达诺结算层使用追随中本聪算法（FTS）来选择领导者。每个当前 epoch 的领导者在当前 epoch 开始的时候，由 FTS 算法计算得出。所以创始区块包含一组领导者列表。领导者的数量和 epoch 的 slot 数量是一致的，这个数量<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/5f7b619c6ec9056c6fe778d862c426233af165df/core/Pos/Core/Constants/Raw.hs#L136\\\">取决</a>于在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/constants.yaml#L10\\\">配置文件</a>中定义的基本安全参数 <code>K</code>。</p>\\n<p>FTS 使用<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/Pos/Core/Types.hs#L256\\\">共享种子</a>，该<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/Pos/Core/Types.hs#L256\\\">共享种子</a>为上个 epoch 计算的结果：在 MPC 的结果中的一些节点会揭露它们的种子，这些种子的 XOR 就被称为共享种子，实际上共享种子就是一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/core/Pos/Core/Types.hs#L257\\\">字符串</a>。</p>\\n<p>股东被选举为领导者的概率与股东持有的币的数量相关。同一个股东可以在同一个 epoch 里面被选举为多个 slot 的领导者。</p>\\n<h2>算法</h2>\\n<p>在<a href=\\\"/glossary/#%E8%AE%BA%E6%96%87\\\">论文</a>的第11页从以学术角度描述了领导者的选举过程。</p>\\n<p>节点将所有未花费的输出(<code>utxo</code>)按照一种特定的方法（按字典）进行排序，因此结果是一对 <code>(StakeholderId, Coin)</code> 的有序<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/1f866450a8a530c119e3fc9edb84c97c56417aa2/src/Pos/Genesis.hs#L177\\\">序列</a>，<code>StakeholderId</code> 是股东的 ID（股东的公钥哈希值），<code>Coin</code> 是股东持有币的数量。这里假设 <code>utxo</code> <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/1f866450a8a530c119e3fc9edb84c97c56417aa2/src/Pos/Lrc/FtsPure.hs#L52\\\">不是空的</a>。</p>\\n<p>然后节点选择几个在 <code>1</code> 和<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/1f866450a8a530c119e3fc9edb84c97c56417aa2/src/Pos/Lrc/FtsPure.hs#L49\\\">系统中 Lovelaces 的数量</a>之间的随机数 <code>i</code>。为了找到第 <code>i</code> 个币的拥有者，节点找到最小的 <code>x</code>，使得这个列表从 <code>x</code> 到 <code>i</code> 的所有币的总数不小于 <code>i</code>(这样第 <code>x</code> 个地址就是第 <code>i</code> 个的拥有者)。</p>\\n<p>结果是一个非空的 <code>StakeholderId</code> 序列，也就是被选中的股东们的 ID，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/5f7b619c6ec9056c6fe778d862c426233af165df/core/Pos/Core/Types.hs#L264\\\"><code>SlotLeaders</code></a> 序列保存在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/da70b2597aab352d7574a3946a366395b09e97eb/node/src/Pos/Context/Context.hs#L94\\\">节点运行环境中</a>。</p>\\n<p>由于是 P2SH 地址，所以节点不知道是会谁将要给它们发送资金。因此，P2SH 地址可以包含目标地址，该目标地址指明哪些地址应该被视为『拥有』用于 FTS 的基金。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/leader-selection/\",\"doc_title\":\"卡尔达诺结算层中的领导者选举\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-02-16-delegation.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at c23493d7a33a82d559d5bd9d289486795cf6592f -->\\n<h1>卡尔达诺结算层股权委派</h1>\\n<p>这一章描述权益委托过程的实现细节。</p>\\n<p>如前所述。为了产生新区块，被选举为领导者的股东必须在线。这种情况可能没有什么吸引力，因为大多数的当选股东都必须为了刷新随机数而参加投币协议（领导者选举过程的关键属性）。如果有很多当选的领导者，会让股东和网络都有很大的压力，因为需要广播和存储大量的提交和共享。</p>\\n<p>委派的功能允许被称为发行人（<em>issuers</em>） <code>I1...In</code> 的股权所有人将他们的『参与义务』转移给某些代表团（<em>delegates</em>） <code>D1...Dm</code>，这些代表团会在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/4bd49d6b852e778c52c60a384a47681acec02d22/src/Pos/Ssc/GodTossing.hs\\\">投币协议</a>中代表股权所有人 <code>S1...Sn</code>。在这种情况下，真正参与到投币协议中节点的数量就少很多，可以看看<a href=\\\"/glossary/#paper\\\">论文</a>的第38页。</p>\\n<p>不仅如此，代表团不仅可以生产新区块，参与到 <a href=\\\"/technical/leader-selection/#follow-the-satoshi\\\">MPC/SSC</a> 中，还可以在<a href=\\\"/cardano/update-mechanism/\\\">系统更新</a>时进行投票。</p>\\n<h2>策略</h2>\\n<p>领导者可以将自己生产新区块的权利转移给代表团。为了转移这个权利，领导者使用一个代理委托的策略：领导者产生一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/4378a616654ff47faf828ef51ab2f455fa53d3a3/core/Pos/Crypto/SignTag.hs#L33\\\">代理签名钥匙</a>，或者说 PSK，然后代表团会使用它<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/ed6db6c8a44489e2919cd0e01582f638f4ad9b72/src/Pos/Delegation/Listeners.hs#L65\\\">签名</a>信息来认证一个区块。有两种类型的 PSK：重量级和轻量级（见下文）</p>\\n<p>具体来说，股权所有人通过自己的公钥构建一个特殊证书来指定代表团的身份。以便之后代表团可以在有限的信息空间内用已签名的证书在自己的公钥下为这些信息提供签名。</p>\\n<p>这是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/d01d392d49db8a25e17749173ec9bce057911191/core/Pos/Crypto/Signing.hs#L256\\\">代理签名</a>的格式。它包括了：</p>\\n<ul>\\n<li>代理私钥，</li>\\n<li>签名。</li>\\n</ul>\\n<p>代理私钥包括：</p>\\n<ol>\\n<li>omega 值，</li>\\n<li>发行人的公钥，</li>\\n<li>代表团的公钥，</li>\\n<li>代理证书。</li>\\n</ol>\\n<p>Omega (or ω) 是<a href=\\\"/glossary/#paper\\\">论文</a>中一个特殊的值。在我们的实现中，它是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f374a970dadef0fe62cf69e8b9a6b8cc606b5c7d/core/Pos/Core/Types.hs#L235\\\">一对 epoch 的标识符</a>。这些标识符定义了委托有效期：如果 epoch 索引在这个范围内那么生产的区块就是有效的。</p>\\n<p><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/d01d392d49db8a25e17749173ec9bce057911191/core/Pos/Crypto/Signing.hs#L209\\\">代理证书</a>就是 omega 和代表团公钥的<a href=\\\"https://github.com/input-output-hk/cardano-crypto/blob/84f8c358463bbf6bb09168aac5ad990faa9d310a/src/Cardano/Crypto/Wallet.hs#L74\\\">签名</a>。</p>\\n<h2>重量级委派</h2>\\n<p>重量级委托使用权益阈值 <code>T</code>，这意味着股权所有人拥有的权益不少于 <code>T</code> 时才能参与重量级委托。这个阈值在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/42f413b65eeacb59d0b439d04073edcc5adc2656/lib/configuration.yaml#L224\\\">配置文件</a>中定义。就像主网的这个阈值是总权益的 0.03%，这个值可以通过系统更新来改变。</p>\\n<p>来自重量级委托的代理签名证书存储在区块链中。请注意发行者在每个 epoch 只能发布一个证书。</p>\\n<p>请注意重量级委托有一个传递关系，所以，如果 <code>A</code> 委派给 B，然后 B 又委派给 <code>C</code>，那么 <code>C</code> 代表的权益等于 <code>A + B</code>，而不仅仅是 <code>B</code>。</p>\\n<h3>到期</h3>\\n<p>在每一个 epoch 开始时，股权所有人不再传递阈值 <code>T</code>, 那么重量级委派证书就会过期。这样做是为了预防委派池膨胀攻击：用户提交了一个证书然后将自己所有的钱（高于阈值）都转到另一个账户，并且重复此操作。</p>\\n<h2>轻量级委派</h2>\\n<p><strong>注意：目前轻量级委派功能是关闭的，在 <a href=\\\"https://cardanoroadmap.com/\\\">Shelley 版本</a>中会打开这个功能，所以下面的信息可能是过期的。</strong></p>\\n<p>与重量级委托相反，轻量级委派不要求代表团拥有 <code>T</code> 或更多的股份。所以轻量级委派可以用于任何的节点。但是轻量级委派的代理签名证书不存在区块链中，所以轻量级委派证书必须要广播到代表团。</p>\\n<p>之后轻量级 PSK 可以被指定发行者的公钥、签名和信息本身进行<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/42f413b65eeacb59d0b439d04073edcc5adc2656/lib/src/Pos/Delegation/Logic/Mempool.hs#L309\\\">验证</a>。</p>\\n<p>请注意『每个 epoch 只能发布一个证书』的规则在轻量级委托中不适用。因为轻量级证书不存储在区块链中，所以可以在每个 epoch 签发很多轻量级证书，不会导致区块链膨胀。</p>\\n<h3>确认代理签名支付</h3>\\n<p>代表团应该使用他拥有的代理签名密钥，使用 PSK 和代表团的钥匙制作一个 PSK 签名。如果签名是正确的，那么就是由代表团进行签名的（由 PSK 策略确保是这种结果）。</p>\\n<h2>为什么有两个委派</h2>\\n<p>你可以将重量级委托和轻量级委托想象成强委托和弱委托。</p>\\n<p>重量级委派证书被存储在区块链中，所以被委派的权益可能会通过加入到委派权益中而参与 MPC。所以有很多重量级委派的代表团可能会累计足够的权益通过阈值的门槛。不仅如此，重量级委派可以参与卡尔达诺结算层更新的投票。</p>\\n<p>与此相反，轻量级委派的权益不会被计算到代表团的 MPC 相关权益。所以轻量级委派只能用来生产新区块。</p>\\n<h2>回撤证书</h2>\\n<p>回撤证书是一种特殊的证书，发行者创建一个回撤证书来撤回委托。重量级委托和轻量级委托都可以被撤回，不过撤回的方法不同。</p>\\n<p>作为相同的标准 PSK 的发行者和委派，撤销证书也是相同的。（换句话说，发行者委派给他自己）</p>\\n<p>要撤销轻量级委派，发行者发送撤销证书给网络，要求撤销委派，但是不能强制撤销，因为轻量级的 PSK 不是区块链的一部分。所以理论上轻量级委派是可以忽略撤销证书的，这样的话，他就一直保持着委派直到它的委派过期。但这样的情况不会妨碍区块链。</p>\\n<p>重量级委派撤销的处理是另一种方式。因为来自重量级委派的代理签名证书是存储在区块链中的，撤销证书也会被提交到区块链中。这种情况下，节点会删除撤销证书签发之前的重量级委派证。不过有三点很重要：</p>\\n<ul>\\n<li>如果提交的重量级委派证书是在节点的内存池里，而且撤销证书也被提交了，那么委派证书将会从内存池中被删除，显然，这种情况下委派证书将永远不会添加到区块链中。  </li>\\n<li>如果一个用户提交委派证书后丢失了他的钱，他仍然可以撤销那个委派，即使那个时候他已经没有足够的钱了（也就是说他拥有的钱少于上面提到的阈值 <code>T</code>)  </li>\\n<li>尽管发行者在当前的 epoch 只能发布一个证书，在同一个 epoch 他可以撤销他的重量级委派。</li>\\n</ul>\",\"frontmatter\":{\"path\":\"/cn/technical/delegation/\",\"doc_title\":\"卡尔达诺股权委派\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-05-15-wallet-backend.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层钱包后端 地址 章节讨论的地址是发送和接收资金的基础，而钱包是简化用户最终流程的一种方式。 什么是钱包？ 在卡尔达诺中，钱包的定义如下： 其中  CWalletMeta…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺结算层钱包后端</h1>\\n<p><a href=\\\"/cardano/addresses/\\\">地址</a>章节讨论的地址是发送和接收资金的基础，而钱包是简化用户最终流程的一种方式。</p>\\n<h2>什么是钱包？</h2>\\n<p>在卡尔达诺中，钱包的定义如下：</p>\\n<pre><code class=\\\"language-haskell\\\">data CWallet = CWallet\\n    { cwId       :: !CWalletAddress\\n    , cwMeta     :: !CWalletMeta\\n    , cwAccounts :: ![CAccount]\\n    , cwAmount   :: !CCoin\\n    }\\n</code></pre>\\n<p>其中 <code>CWalletMeta</code> 指明当前钱包是共享的还是个人的，以及钱包使用的货币和钱包的名字。有了这个，钱包类型很容易扩展，因为任何附加的功能可以添加到 <code>CWalletMeta</code> 类型，而其他字段不变。每个钱包，无论名称，类型和货币，都必须具有上述字段。</p>\\n<h2>交易和钱包</h2>\\n<p>在<a href=\\\"/cardano/transactions/\\\">转账</a>章节定义了交易数据的结构。然而，为了方便客户的操作，交易在客户中有不同的表现形式，他们被表示为：</p>\\n<pre><code class=\\\"language-haskell\\\">data CTx = CTx\\n    { ctId            :: CTxId\\n    , ctAmount        :: CCoin\\n    , ctConfirmations :: Word\\n    , ctMeta          :: CTxMeta\\n    , ctInputAddrs    :: [CAddress Acc]\\n    , ctOutputAddrs   :: [CAddress Acc]\\n    }\\n</code></pre>\\n<p>本质上，一个客户端的转账由实际交易 <code>Id</code>，收到的币的数量，交易已得到的确认数（即当前位于包含所述交易区块顶部的区块数量），输入和输出地址。元数据，数据类型 <code>CTxMeta</code>，表明交易的货币，标题或名称，描述信息，以及 POSIX 格式的发送日期。</p>\\n<h2>钱包后端 API</h2>\\n<p>目前，钱包 API 提供了一系列使用钱包的方法。Haskell 库 <code>servant</code> 提供了一个模块化的 API 构建方法。该库使用组合器来构建院子 HTTP 操作，并将这些原子方法粘合在一起以形成更大和更完整的 API。</p>\\n<p>请注意，只有当您使用 <code>--wallet</code> 选项运行节点时，钱包 Web API 才可用，这个 API 的默认端口 <code>8090</code> 可以通过 <code>--wallet-port</code> 选项进行更改。</p>\\n<p>钱包 Web API 文档可以在<a href=\\\"https://cardanodocs.com/technical/wallet/api/\\\">这里</a>找到</p>\\n<h3>TLS 连接</h3>\\n<p>钱包 Web API 使用 TLS 进行安全通信。调用 API 需要发送客户端 CA 证书，该证书在启动节点时使用，并将客户端标识为允许调用服务器 API。</p>\\n<p>请注意，客户端证书文件是启动节点时 <code>--tlsca</code> 作为选项提供的文件。</p>\\n<p>例如，如果该文件是可用的 <code>ca.crt</code>，那么对于运行节点 <code>localhost:8090</code> 调用 curl 命令可以像这样：</p>\\n<pre><code class=\\\"language-bash\\\">curl --cacert ca.crt -v https://localhost:8090/api/settings/sync/progress\\n</code></pre>\\n<p>如果该请求成功，那么您已经正确配置了 TLS。</p>\\n<h3>处理错误</h3>\\n<p>如果事件请求失败，则有一个 <code>WalletError</code> 类型，它只封装一个 <code>Text</code> 来显示发生了什么。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/wallet-backend/\",\"doc_title\":\"卡尔达诺结算层钱包后端\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-05-14-hd-wallets.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"HD 钱包 HD 钱包是一个允许用户以一种确定性方式从普通种子中获取密钥的功能。基本上，你可以从一个随机种子中产生一个初始密钥。然后你就可以从  SK₀  得到孩子  SK₀-₀ ,  SK₀-₁ 。从这些孩子中，你可以得到  SK₀-₀-₀ ,  SK₀-₀-₁ ,  SK…\",\"html\":\"<!-- Reviewed at 866fd6a29a15c503e54426f17b91bd8b0903c5dc -->\\n<h1>HD 钱包</h1>\\n<p>HD 钱包是一个允许用户以一种确定性方式从普通种子中获取密钥的功能。基本上，你可以从一个随机种子中产生一个初始密钥。然后你就可以从 <code>SK₀</code> 得到孩子 <code>SK₀-₀</code>, <code>SK₀-₁</code>。从这些孩子中，你可以得到 <code>SK₀-₀-₀</code>, <code>SK₀-₀-₁</code>, <code>SK₀-₁-₀</code> 等（派生任意深度的树）。</p>\\n<!-- For subscripts and other symbols: https://help.ubuntu.com/community/ComposeKey -->\\n<p>我们会区分两种类型的键：</p>\\n<ul>\\n<li><strong>Hardened</strong></li>\\n<li><strong>Non-hardened</strong></li>\\n</ul>\\n<p>这里唯一的区别是 <strong>hardened</strong> 密钥允许从父密钥派生出子密钥。因此，为了派生一个 <strong>hardened</strong> 键，你必须拥有私钥。<strong>Non-hardened</strong>密钥允许从父公钥派生子公钥（不具有可用密钥）。</p>\\n<p>每个孩子被分配一个4字节的索引 <code>i</code>:</p>\\n<ul>\\n<li><code>i ≤ 2³¹ - 1</code> <strong>non-hardened</strong> 键。</li>\\n<li><code>i > 2³¹ - 1</code> <strong>hardened</strong> 键。</li>\\n</ul>\\n<h2>属性:</h2>\\n<ol>\\n<li>树结构保存在根地址中。用户需要复制公钥将其传递给任何想要恢复树的人。</li>\\n</ol>\\n<h2>地址格式</h2>\\n<p>我们使用 <code>PublicKey</code> 地址（已经存在于系统中），并添加属性字段。在由 <code>0</code> (<strong>HD 钱包属性</strong>) ，我们存储树数据。</p>\\n<p>树存储为<strong>派生路径</strong>的列表。每个<strong>派生路径</strong>被指定为<strong>派生索引</strong>的列表。每个<strong>派生索引</strong>都是4字节的无符号整数。</p>\\n<p>所得到的对象被序列化并使用对称方案（<em>ChaChaPoly1305</em>算法进行加密），密码被计算为根公钥的SHA-512散列。只要我们实际上没有再根密钥上存储任何资金（不通过共识规则，而是通过用户界面），那么将不允许攻击者将链上的所有地址映射到根。</p>\\n<p><strong>设计的关键点：</strong>根密钥不用于实际存储金钱。</p>\\n<h2>用例</h2>\\n<h3>财务审计</h3>\\n<p>应该提供一个根公钥的审计散列，让审计人员找到层次结构中的所有密钥。</p>\\n<h3>付款服务器</h3>\\n<p>它只适用于 <strong>non-hardened</strong> 键。</p>\\n<p>为了使服务器能够获得后续地址来收取付款，需要上传：</p>\\n<ul>\\n<li>根公钥</li>\\n<li>\\n<p>有效载荷：</p>\\n<ul>\\n<li><code>i</code> 级别的 <code>PK</code></li>\\n<li>跟公钥的哈希</li>\\n<li><code>PK</code> 的树路径</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>钱包</h3>\\n<p>要使钱包在某个子树上运行，需要提供：</p>\\n<ul>\\n<li>根密钥</li>\\n<li>\\n<p>有效载荷：</p>\\n<ul>\\n<li><code>SK</code> 级别的密钥 <code>i</code></li>\\n<li>根公钥的哈希</li>\\n<li><code>SK</code> 的树路径</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>要求</h2>\\n<p><code>A(K)</code> 表示保存密钥对信息的地址 <code>K</code>。<code>child(K, i)</code> 表示第 <code>i</code>个子密钥对 <code>K</code>。<code>tree(K)</code> 表示从 <code>K</code>（有证书余额）派生，以 <strong>utxo</strong> 保存的密钥对地址树。</p>\\n<p><code>a -> b</code> 表示 <code>b</code> 从 <code>a</code> 派生。<code>a -x b</code> 表示 <code>b</code> 不是从 <code>a</code> 派生的（在任何情况下）：</p>\\n<pre><code>priv(K) -> pub(K)\\npub(K) -> A(K)\\npub(K) -x priv(K)\\nA(K) -x pub(K)\\nA(K) -x A(child(K, i))\\n</code></pre>\\n<p>对于 <strong>hardened</strong> 键：</p>\\n<pre><code>(priv(K), utxo) -> tree(K)\\npub(K) -x pub(child(K, i))\\npriv(K) -> priv(child(K, i))\\n</code></pre>\\n<p>对于 <strong>non-hardened</strong> 键：</p>\\n<pre><code>(pub(K), utxo) -> tree(K)\\npub(K) -> pub(child(K, i))\\npriv(K) -> priv(child(K, i))\\n</code></pre>\\n<h2>派生加密接口</h2>\\n<h3>符号:</h3>\\n<ul>\\n<li><code>kp</code> 表示具有索引 <code>p</code> 的私钥。只是一个 <strong>Ed25519</strong> 私钥。</li>\\n<li><code>kp</code> 表示带有索引 <code>p</code> 的公钥。只是一个 <strong>Ed25519</strong> 公钥。</li>\\n<li><code>cp</code> 表示带有索引的链。</li>\\n</ul>\\n<h3>熵</h3>\\n<p>在比特币中，它们使用512位的散列，但 <code>kp</code> 只有 256 位，因为这个原因，我们需要遵循512位的密钥，所以我们不减少哈希空间。</p>\\n<ul>\\n<li>扩展的私钥是表示为 <code>(ki, ci)</code> 的一对。</li>\\n<li>扩展的私钥是表示为 <code>(Ki, ci)</code> 的一对。</li>\\n</ul>\\n<p>从应用角度来看，HD 钱包（BIP-32）引入了以下密码原语：</p>\\n<ul>\\n<li>\\n<p><code>CKDpriv :: ((kpar, cpar), i) → (ki, ci)</code><br>\\n从父扩展私钥计算自扩展私钥</p>\\n</li>\\n<li>\\n<p><code>CKDpub :: ((Kpar, cpar), i) → (Ki, ci)</code><br>\\n从父扩展私钥中调用一个子扩展私钥</p>\\n</li>\\n</ul>\\n<h1>代达罗斯 HD 钱包</h1>\\n<p>本节介绍 HD 钱包功能的使用方式。它分为两部分：</p>\\n<ol>\\n<li>扩展钱包后端 API 以在本地支持 HD 钱包结构（就像在比特币中完成的那样）</li>\\n<li>利用新的地指数型来扩展区块链处理以保持多个客户端实例的 HD 结构同步。</li>\\n</ol>\\n<h2>本地存储</h2>\\n<h3>旧的存储</h3>\\n<p>旧的钱包存储存的是地址列表。每个地址都与一个名称相关联，并且是从单独的密钥（由助记符备份并用消费密码加密）派生而来。</p>\\n<h3>新的存储</h3>\\n<p>钱包的存储扩展到存储<strong>钱包</strong>列表。每个钱包对应一个根密钥（由助记符备份并用消费密码加密）。</p>\\n<p>每个钱包都包含一个<strong>账户</strong>。</p>\\n<p>每个账户都包含多个<strong>地址</strong>（即地址是 HD 树中第二层的关键字）。</p>\\n<p>这映射到一个 HD 树：</p>\\n<ul>\\n<li>钱包组对应第 0 级（<em>根</em>）密钥。</li>\\n<li>钱包对应1级密钥（根的孩子）。</li>\\n<li>地址对应于第2级（根的孙子）的密钥。</li>\\n</ul>\\n<p>钱只保存在地址上。</p>\\n<p>当从一个或多个地址花费金钱时，如果有的话，将产生新的余额。</p>\\n<h3>可用性</h3>\\n<p>用户能够：</p>\\n<ul>\\n<li>导入/导出任意数量的<strong>钱包</strong>，</li>\\n<li>生成任意数量的<strong>账户</strong>，</li>\\n<li>分配<strong>钱包</strong>和<strong>账户</strong>名称，</li>\\n<li>生成任意数量的地址，</li>\\n<li>改变钱包消费密码。</li>\\n</ul>\\n<h2>从区块链中读取 HD 钱包数据</h2>\\n<p>有两种导入/导出钱包的方法：</p>\\n<ul>\\n<li>通过<strong>助记符</strong>，</li>\\n<li>通过导出文件。</li>\\n</ul>\\n<p>助记符在前端生成，并允许确定性地生成密钥。名称不会被恢复。</p>\\n<p>导出文件能够恢复整个钱包结构。</p>\\n<h3>导入</h3>\\n<p>在两种情况下我们都有一个根密钥。在导入的时候会执行下面的步骤：</p>\\n<ul>\\n<li>根密钥在本地存储中被检查为不存在。</li>\\n<li>遍历 <strong>utxo</strong> 查找与此根密钥对应的所有有余额的地址，并将它们与服务（钱包）一起添加到存储中。</li>\\n<li>在文件导入的情况下，从步骤2得到的结构标有名称。此外，导入的文件中列出的钱包/地址，目前没有被使用。</li>\\n</ul>\\n<h3>新的事务处理</h3>\\n<p>当有新的交易可用时（出现在区块或内存池中），输入会被分析。如果输入对应于具有 <strong>HD 钱包属性</strong>的公共密钥地址，则检查该地址是否对应于我们的<strong>钱包</strong>之一。如果是这样，地址将被导入到结构中（为了在用于界面显示余额）。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/hd-wallets/\",\"doc_title\":\"HD 钱包\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-05-16-wallet-frontend.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"…\",\"html\":\"<!-- Reviewed at cd26fb28eb48f893a4ca2d045a10da19c211b807 -->\\n<h1>卡尔达诺结算层钱包前端</h1>\\n<p>卡尔达诺结算层发展时，用户需要一个可以查看资金，发送接收转账，处理其他个人电子货币钱包的任务这样的用户界面，这一需求在增长。代达罗斯钱包是对于这些需求的解决方案。</p>\\n<p>目前，它允许用户使用上述功能，并计划在不久的将来提供对其他货币的支持，包括电子货币和非电子货币。</p>\\n<h2>构建代达罗斯客户端 API</h2>\\n<p>要在本地运行代达罗斯客户端 API，您必须按照下面的要求开启 <a href=\\\"https://github.com/input-output-hk/cardano-sl/\\\"><code>cardano-sl</code></a> 的钱包 API。</p>\\n<p>请确保您在 <code>cardano-sl</code> 的根目录。同时确保您已经安装 <a href=\\\"https://www.npmjs.com/\\\">npm</a> 程序。</p>\\n<h2>运行和测试代达罗斯客户端 API</h2>\\n<p>为了在操作中看到代达罗斯客户端 API，首先运行一个本地的卡尔达诺结算层网络：</p>\\n<pre><code class=\\\"language-bash\\\"># run tmux in another window\\n$ tmux\\n# launch nodes\\n$ ./scripts/launch/demo-with-wallet-api.sh\\n</code></pre>\\n<p>默认情况下，这将启动由3个互连节点组成的尔达诺结算层网络。一个节点运行钱包 API，它会同生产环境中运行的代达罗斯钱包行为一致。</p>\\n<h2>WEBSOCKETS 通知</h2>\\n<p>我们可以用一个小工具(<code>npm install -g wscat</code>)来测试 websocks：</p>\\n<pre><code class=\\\"language-bash\\\">> wscat -c ws://127.0.0.1:8090\\n\\nconnected (press CTRL+C to quit)\\n\\n&#x3C; {\\\"tag\\\":\\\"ConnectionOpened\\\"}\\n\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":1}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":1}}\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":2}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":2}}\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":3}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":3}}\\n&#x3C; {\\\"tag\\\":\\\"NetworkDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":4}}\\n&#x3C; {\\\"tag\\\":\\\"LocalDifficultyChanged\\\",\\\"contents\\\":{\\\"getChainDifficulty\\\":4}}\\n</code></pre>\\n<p>从这我们可以看到相同的改变：</p>\\n<pre><code class=\\\"language-bash\\\">curl http://localhost:8090/api/settings/sync/progress\\n</code></pre>\\n<p>Accound 应该重命名为地址。请查看这个 issues <a href=\\\"https://issues.serokell.io/issue/CSM-249\\\">CSM-249</a> 获取更多细节。</p>\\n<h2>钱包事件</h2>\\n<p>除了这些 HTTP 接入点外，还有一个从服务器到客户端的单向 websocket 通道，<code>notify</code> 接入点。</p>\\n<p>这个通道充当通知系统。以便可以告知代达罗斯 UI 相关事件。目前支持的事件有：</p>\\n<ul>\\n<li><code>LocalDifficultyChanged</code> - 当前区块链高度，</li>\\n<li><code>NetworkDifficultyChanged</code> - 全球区块链高度，</li>\\n<li><code>UpdateAvailable</code> - 新的系统可用更新，</li>\\n<li><code>ConnectedPeersChanged</code> - 连接到对等节点数量的改变，</li>\\n<li><code>ConnectionOpened</code> - 打开 websocket 连接，</li>\\n<li><code>ConnectionClosed</code> - 关闭 websocket 连接。</li>\\n</ul>\\n<p>由于此通道是单向的，因此从客户端发送到通道的任何消息都会被忽略。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/wallet-frontend/\",\"doc_title\":\"卡尔达诺结算层钱包前端\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-04-updater.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层更新器概览 更新系统的实现可以从  Pos.Update  系列模块中找到。实现的方法与 CSL 的其他子系统相同，比如 Txp, Ssc…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<!-- Updated at 6b5eda44e5942599a9781e5ad3f51eb820665b83 -->\\n<h1>卡尔达诺结算层更新器概览</h1>\\n<p>更新系统的实现可以从 <a href=\\\"https://github.com/input-output-hk/cardano-sl/tree/6b5eda44e5942599a9781e5ad3f51eb820665b83/src/Pos/Update\\\">Pos.Update</a> 系列模块中找到。实现的方法与 CSL 的其他子系统相同，比如 Txp, Ssc 和委派。更新系统有一个全局状态，存储在数据库中。全局状态可以从区块链中明确导出。本地状态，有时候也被称为『内存池』，被存储在内存中。内存池用于数据传输，将传输的数据保存到区块中。在<a href=\\\"/technical/protocols/binary-protocols/\\\">二进制文档</a>中描述的二进制协议在<a href=\\\"/technical/protocols/csl-application-level/\\\">应用级文档</a>中描述了网络协议（使用标准的 <a href=\\\"https://github.com/input-output-hk/cardano-sl/tree/43a2d079a026b90ba860e79b5be52d1337e26c6f/infra/Pos/Communication/Relay\\\">Inv/Req/Data\\npattern</a> 模式构建)。</p>\\n<p>目前，通过软件更新，执行研究部分所述的硬分叉来增加硬分叉的功能已经准备好了；软分叉（或者说软件更新）已经完全实现。</p>\\n<h2>软分叉可更新字段</h2>\\n<p>一个 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/Core/Types.hs#L110\\\">UpdateProposal</a> 包含用于修改由卡尔达诺结算层使用的一些参数（例如 slot 持续时间）的字段。具体来说，<code>upBlockVersion</code> 用于提议协议有了一些修改；如果 <code>upBlockVersion</code> 比上一次使用的区块还新，<code>upBlockVersionData</code> 的修改就会被采用。</p>\\n<p><code>upBlockVersionData</code> 具有 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/fe5e6a377ab63c506173545fd4d8633cd1afbdc6/core/Pos/Core/Types.hs#L206\\\">BlockVersionData</a> 的类型。</p>\\n<p>这些字段如下所述：</p>\\n<ul>\\n<li><code>bvdScriptVersion</code> - 用于验证脚本转账的脚本语言版本，如果协议中 <code>upBlockVersion</code> 增加了，它必须也给增加 <code>upBlockVersion</code> 1（不能保持不变）。</li>\\n<li><code>bvdSlotDuration</code> - slot 持续时间（以毫秒为单位）。</li>\\n<li><code>bvdMaxBlockSize</code> - 区块大小限制（以字节为单位）。与上一个限制相比而言，协议不能将区块的大小限制增加两倍以上。</li>\\n<li><code>bvdMaxHeaderSize</code> - 区块大小限制（以字节为单位）。</li>\\n<li><code>bvdMaxTxSize</code> - 转账大小限制（以字节为单位，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/core/constants.yaml#L17\\\">当前为4096字节</a>)，限制 <a href=\\\"/technical/protocols/binary-protocols/#transaction-auxilary\\\">TxAux</a> 的大小。</li>\\n</ul>\\n<p>这些检查在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/893e3c838bf847613313e8dbf04330176a788af4/update/Pos/Update/Poll/Logic/Base.hs#L232\\\">verifyNextBVData</a> 中进行。</p>\\n<p>此外，有一些现在未被使用，但将来会被使用的字段。以下是它们的简要说明：</p>\\n<ul>\\n<li><code>bvdMpcThd</code> MPC 的资格临界值。</li>\\n<li><code>bvdHeavyDelThd</code> 重量级委派的临界值。</li>\\n<li><code>bvdUpdateVoteThd</code> 投赞成票和反对更新所需的股份份额。</li>\\n<li><code>bvdUpdateProposalThd</code> 所有股份的一个份额，要让区块拥有 <code>UpdateProposal</code>，权益所有人的投票份额必须大于这一份额。</li>\\n<li><code>bvdUpdateImplicit</code> 静默更新之后的 slot 数（除非它有更多的否定票数）。</li>\\n<li><code>bvdUpdateSoftforkThd</code> 所有股份的一个份额，如果某些区块权益所有人的总持股比例比该数值大，则采用该区块版本。</li>\\n</ul>\\n<h2>内存池结构</h2>\\n<p><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/MemState/Types.hs#L29\\\"><code>内存池</code></a> 由投票和提案组成。除此以外，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/MemState/Types.hs#L39\\\"><code>内存池</code></a> 还包含 tip，slot 以及 <code>MemPool</code> 对应的 <code>PollModifier</code>（当前 <code>GState</code>，即应用的 <code>MemPool</code> 对应 <code>GState</code>）。无论是来自网络/内存池提案状态改变，还是来自区块链加载的提案状态改变，<code>PollModifier</code> 都表示全局状态的改变，会被应用到内存池。</p>\\n<h3>更新内存池</h3>\\n<p>随着节点反序列化<a href=\\\"/technical/protocols/binary-protocols/#update-system\\\">更新系统消息的数据</a>，内存池会被更新，实现在<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/43a2d079a026b90ba860e79b5be52d1337e26c6f/update/Pos/Update/MemState/Functions.hs#L35\\\">这里</a>。</p>\\n<p><code>MemPool</code> 在三种情况下会被更新：</p>\\n<ol>\\n<li>\\n<p><strong>当收到新的提案/表决时</strong>。在这种情况下，调用一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/763822c4fd906f36fa97b6b1f973d31d52342f3f/update/Pos/Update/Logic/Local.hs#L186\\\">处理函数</a>，然后调用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/dff5e00612c84af24964a98e5254602fa4f7fc17/update/Pos/Update/Poll/Logic/Apply.hs#L66\\\"><code>verifyAndApplyUSPayload</code></a> 并更新当前 <code>PollModifier</code> 和 <code>MemPool</code>。  </p>\\n</li>\\n<li>\\n<p><strong>当一个新 slot 开始时</strong>。在这种情况下，一些内存池的数据可能会失效。事实上，只有 epoch 发生变化时才会发生这种情况。这种情况可能会发生是因为稳定的股份分配发生了变化，有些投票可能没有足够的股份。这是 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/763822c4fd906f36fa97b6b1f973d31d52342f3f/update/Pos/Update/Logic/Local.hs#L283\\\"><code>processNewSlot</code></a> 方法实现的。</p>\\n</li>\\n<li>\\n<p><strong>当 <code>GState</code> 更新时</strong>。它被称为 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/763822c4fd906f36fa97b6b1f973d31d52342f3f/update/Pos/Update/Logic/Local.hs#L248\\\"><code>usNormalize</code></a>。有些数据可能由于区块应用程序或回滚而变得无效。例如，我们在内存中有个提案，将这个提案应用于区块，然后它变无效了（因为它已经在区块中）。我们应该放弃这个提案。或者我们从某个区块对提案进行投票，然后回滚这个区块，然后投票变得无效。它通过将所有本地数据应用于空状态来实现的，忽略所有不再有效的数据。</p>\\n</li>\\n</ol>\\n<h3>提案和投票累计</h3>\\n<p>要为提案投票，节点应该发送它们的<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/Core/Types.hs#L255\\\">投票</a>。提案和投票存储在内存池（即使没有足够的选票加入区块，这种方式也可以自动收集投票），或者从区块链收集，以确定哪个方案通过。</p>\\n<h2>与数据库的交互</h2>\\n<p>为了验证更新系统数据，我们必须从全局状态（数据库）获取这些数据。有一个文档详实的类型类 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/446444070ee09857603797a90af970fff215c8c5/update/Pos/Update/Poll/Class.hs#L29\\\"><code>MonadPollRead</code></a> 提供这样的接口。这种类型不但用于数据库交互，还用于在处理从网络接收到的数据时将内存池写入账户。非常重要的一点是，它的实现依赖于 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/DB.hs\\\"><code>Pos.Update.DB</code></a> 模块中的函数。</p>\\n<h2>核心类型</h2>\\n<p>核心类型在<a href=\\\"/technical/protocols/binary-protocols/\\\">二进制协议</a>文档中提到。这些类型直接反映了研究章节的概念，有关更多信息，请参阅<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/Core/Types.hs\\\">核心类型模块</a>。</p>\\n<h2>更新提案批准</h2>\\n<p>更新机制实现的一个很重要的部分是创始块的部分。这个逻辑在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/6b5eda44e5942599a9781e5ad3f51eb820665b83/src/Pos/Update/Poll/Logic/Softfork.hs#L68\\\"><code>processGenesisBlock</code></a> 中。下面将解释与该过程有关的术语。</p>\\n<h3>阈值</h3>\\n<p>假设有一个区块版本 <code>X</code>。以及在 slots <code>S</code> 中创建的版本为 <code>X</code> 的区块（其中 <code>S</code> 是一组 slots）。如果所有 slot 的领导者的总相对资产 <code>S</code> ≥ <code>softforkResolutionThreshold</code> (在代码中被称为阈值)，则 <code>X</code> 被采纳。请参阅<a href=\\\"/cardano/update-mechanism/#soft-fork-updates\\\">研究概述</a>获取更详细说明。</p>\\n<h3>提案状态</h3>\\n<p>更新的提案状态可处于下面的状态之一。</p>\\n<h4>未定</h4>\\n<p>这意味着更新提案被包含在其中一个区块中，但是它没有 <code>50%</code> 的赞成/反对票（这里的 <code>50%</code> 的意义是赞成/反对提案选民总数相对于系统所有权益相关者的总股权），默认赞同规则还没有触发。</p>\\n<!-- TODO: **Important remark:** when we are talking about stake, we need to be clear about\\nwhich stake distribution we are talking about. For each epoch we know stable distribution\\nfor this epoch. It used in leaders selection (follow-the-satoshi) and also in many other\\ncases. Stable distribution is distribution as it was ﻿⁠⁠⁠⁠2k﻿⁠⁠⁠⁠ slots before the end of epoch.\\nTo calculate stake of votes for proposal ﻿⁠⁠⁠⁠p﻿⁠⁠⁠⁠ we use stake distribution as per epoch in\\nwhich ﻿⁠⁠⁠⁠p﻿⁠⁠⁠⁠ was added to blocks. I. e. distribution which was ﻿⁠⁠⁠⁠2k﻿⁠⁠⁠⁠ slots before the\\nend of that epoch. This ensures that nobody can transfer his funds to another address\\nand vote from that address to increase total stake of voters.\\n\\n**Another important remark:** when we are talking about stake, it's also important to be\\nclear whether we consider delegated stake. I. e. if Alice delegated to Bob, do we consider\\nthat Alice's funds belong to Bob or Alice? When we use stake for votes, we consider delegated\\nstake, i. e. we consider that Alice's funds belong to Bob. Note that here we consider\\nonly heavyweight delegation. I hope it's covered in documentation, but I am not sure. -->\\n<h4>批准</h4>\\n<p>这意味着这个提案有超过 <code>50%</code> 的投票或很久之前加入了区块（根据默认批准规则），赞同的票数比反对的票数更多（与股权比较）。</p>\\n<h4>拒绝</h4>\\n<p>如果反对该提案的投票超过 <code>50%</code>，或很久之前加入了区块（根据默认批准规则），反对的票数比赞同的票数更多（再次与股权比较）。</p>\\n<h4>确认</h4>\\n<p>如果至少 <code>k</code> 个区块提案通过，那么这个<strong>批准</strong>的提案被称为<strong>确认</strong>。这时候我们可以确定该提案不会被拒绝。因为深度超过 <code>k</code> 的回滚是不可能的。</p>\\n<h4>废弃</h4>\\n<p>如果至少 <code>k</code> 个区块提案未通过，那么这个<strong>拒绝</strong>的提案被<strong>废弃</strong>。这时候我们可以确定该提案不会被通过。因为深度超过 <code>k</code> 的回滚是不可能的。</p>\\n<h2>下载新版本</h2>\\n<p>在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/src/Pos/Update/Download.hs\\\"><code>Pos.Update.Download</code></a> 模块中，实现了以下算法。已下载的更新通过一个叫做 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/82ba83c3ffb670201b309ff47e3d0ab5f4a17455/src/launcher/Main.hs\\\"><code>cardano-launcher</code></a> 的工具操作。</p>\\n<h3>下载更新的版本</h3>\\n<p>要下载更新的版本，我们从 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/04dc8e4a640a62f0d82633f3a78ab3d8540fd5e6/update/Pos/Update/Poll/Types.hs#L114\\\"><code>ConfirmedProposalState</code></a> 提取更新的哈希值。如果更新哈希值成功提取了，则调用『下载更新哈希值』算法以下载保存更新的版本，这取决于我们是否在给定的平台使用安装程序。</p>\\n<h3>通过哈希值下载更新</h3>\\n<p>为了<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/daa8b81785f38038187c45385c9a94510a5c3780/src/Pos/Update/Download.hs#L108\\\">通过哈希值下载更新</a>，我们会使用 HTTP 中的 <code>httpLBS</code>，遍历已知的更新服务器，用给定的哈希值下载更新。很简单：最后，我们要么完成了更新的下载，要么遍历完服务器清单，上报错误信息。已知更新服务器的 URI 使用 <code>cardano-node</code> 可执行文件的 <code>--update-server</code> 参数定义。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/updater/\",\"doc_title\":\"卡尔达诺结算层更新器\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-07-blocks.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺清算层的区块 这份指南介绍区块设计和区块处理的逻辑。 区块相关类型在  Pos.Block.Core.Main.Types  模块和  Pos.Block.Core.Genesis.Types  模块中定义。在\\n Pos.Block.Logic…\",\"html\":\"<!-- Reviewed at ac0126b2753f1f5ca6fbfb555783fbeb1aa141bd -->\\n<h1>卡尔达诺清算层的区块</h1>\\n<p>这份指南介绍区块设计和区块处理的逻辑。</p>\\n<p>区块相关类型在 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Types.hs\\\">Pos.Block.Core.Main.Types</a> 模块和 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Genesis/Types.hs\\\">Pos.Block.Core.Genesis.Types</a> 模块中定义。在\\n<a href=\\\"https://github.com/input-output-hk/cardano-sl/tree/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic\\\">Pos.Block.Logic.*</a> 模块中定义了使用区块的逻辑。</p>\\n<h2>设计</h2>\\n<p>区块是账本的基础部分。有两种类型的区块：<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Types.hs#L110\\\"><strong>主块</strong></a>和<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Genesis/Types.hs#L66\\\"><strong>生成块</strong></a>。</p>\\n<h3>主区块</h3>\\n<p>一个主区块由<em>头</em>和<em>主体</em>组成。<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/core/Pos/Core/Block.hs#L99\\\">区块头</a>包含块的元信息：</p>\\n<ol>\\n<li>指向前一个区块签名的头。</li>\\n<li>区块主体信息的验证。</li>\\n<li>验证共识算法的共识数据。</li>\\n<li>一些额外的数据。</li>\\n</ol>\\n<p>区块主体包含的有效载荷和一些额外的数据也是如此。有效载荷包括：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L66\\\">转账有效载荷</a>。这个有效载荷是最主要的。事务存储在 Merkle 树中。这个有效载荷也包括<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Txp/Core/Types.hs#L283\\\">见证名单</a>，请阅读<a href=\\\"/cardano/transactions/\\\">卡尔达诺结算层</a>的交易，了解交易和见证的更多信息。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L68\\\">SSC 有效载荷</a>。按照跟随<a href=\\\"/cardano/proof-of-stake/#follow-the-satoshi\\\">中本聪算法</a>使用 SSC（共享种子计算）。在每一个 epoch 中，必须选出下一个 epoch 的领导者。这些 slot 的领导者将能够生成主区块并加入到账本中。所以 SSC 被用作领导者选举过程的随机来源。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L70\\\">委派的有效载荷</a>。该有效载荷由<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Delegation/Types.hs#L49\\\">重量级代理签名密钥列表</a>组成。请阅读关于<a href=\\\"/technical/delegation/\\\">卡尔达诺结算层的股权委派</a>获取更多信息。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Chain.hs#L72\\\">更新有效载荷</a>。它包含软件更新的<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/732a2c765a417ba0a5010df81061c4473f80a0dc/update/Pos/Update/Core/Types.hs#L300\\\">建议</a>和特定更新的选项列表。请阅读<a href=\\\"/cardano/update-mechanism/\\\">更新系统模型</a>获得更多信息。</li>\\n</ol>\\n<h3>创世块</h3>\\n<p>一个创始块不包含交易，每个 epoch 我们都只有一个创始块。创始块就像主区块一样，只有一个区块头和一个区块主体。该块的主题包括：</p>\\n<ol>\\n<li>与该区块相关的 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Genesis/Chain.hs#L33\\\">epoch 索引</a>。</li>\\n<li>这个 epoch 的 slot 领导者列表。该列表<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/b4b2c282b0e2a2e4415163e70dcb559396a2237c/core/Pos/Core/Types.hs#L272\\\">不能为空</a>。</li>\\n<li>链复杂度。他表示生成一个链的复杂度，它是链中主块的数量。</li>\\n</ol>\\n<h2>区块处理逻辑</h2>\\n<p>我们根据区块和区块头进行处理。基本上，我们可以：</p>\\n<ul>\\n<li>创建一个区块</li>\\n<li>验证一个区块</li>\\n<li>申请块</li>\\n<li>回滚一个块</li>\\n</ul>\\n<p>以及：</p>\\n<ul>\\n<li>按不同的标准获取块头</li>\\n<li>给区块头分类</li>\\n</ul>\\n<h2>创建区块</h2>\\n<p>如上所述，有两种区块：<strong>主</strong>区块和<strong>生成</strong>块。主区块由 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L156\\\"><code>createMainBlock</code></a> 函数创建，生成块由 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L92\\\"><code>createGenesisBlock</code></a> 创建。</p>\\n<h3>主区块创建</h3>\\n<p>如果可能的话，我们尝试在最佳链的顶部创建一个新的主区块。如果满足以下条件，可以创建一个新区块：</p>\\n<ul>\\n<li>我们知道 epoch 给定 slot ID 的主区块，</li>\\n<li>最后一个已知的区块不超过给定的 slot 的 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f571087e5b5af339767198141981c850227ca99c/core/Pos/Core/Constants.hs#L86\\\"><code>slotSecurityParam</code></a> 个区块。</li>\\n</ul>\\n<p><code>slotSecurityParam</code>（实际上是 slot 的数量）的值取决于可被回滚区块的最大数量。这个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/core/Pos/Core/Constants.hs#L81\\\">最大数量</a>来自<a href=\\\"/glossary/#paper\\\">论文</a>中的安全参数。</p>\\n<p>首先，我们必须检查我们的软件是否可以<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Update/Logic/Global.hs#L139\\\">根据当前的全局状态</a>创建一个区块，如果不能，我们会<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L172\\\">报告</a>。如果可以的话，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L206\\\">创建并应用区块</a>。</p>\\n<h3>创世纪块的创建</h3>\\n<p>当当前已知最佳链的头 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Core/Main/Types.hs#L112\\\"><code>MainBlock</code></a>  对应于 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/core/Pos/Core/Constants.hs#L81\\\"><code>slotSecurityParam</code></a> （i-1）个时期的最后一个 slot 之一时，为当前时期创建一个生成块。</p>\\n<p>首先，我们试图获得 slot 领导者，如果<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L99\\\">没有领导者</a>或 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L102\\\">LRC 没有足够的区块</a>，则会报告错误。否则，我们试图创建一个<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L115\\\">新的创始块</a>。然而有时候我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L106\\\">不应该创建</a>。例如，我们不应该在第 0 个 epoch 做这件事情，因为<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Creation.hs#L108\\\">第 0 个 epoch</a> 的生成块是硬编码的。</p>\\n<h2>区块应用</h2>\\n<p>我们使用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/VAR.hs#L182\\\"><code>applyBlocks</code></a> 函数应用区块。区块的顺序应该是绝对有效的：我们必须验证关于块的所有谓词和数据检查。</p>\\n<p><strong>重要</strong>： 在这个序列中的所有区块都必须是相同的 epoch！</p>\\n<p>如果所有的条件都满足了，我们<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L107\\\">真正应用区块</a>：</p>\\n<ul>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L141\\\">应用 US (更新系统)</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L142\\\">应用委派</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/09e4fcf8a7f1a5a587d0241aa93f23e2d72c7c70/src/Pos/Block/Logic/Internal.hs#L143\\\">应用转账</a>。</li>\\n</ul>\\n<p>而且，我们可以在应用程序之前验证区块（即只有在区块有效时才应用区块）。我们使用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L99\\\"><code>verifyAndApplyBlocks</code></a> 函数的功能，如果在应用程序发生错误，有两个选项：</p>\\n<ol>\\n<li>在这个函数中应用的所有区块都将<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L137\\\">回滚</a>。</li>\\n<li>这个函数将尝试<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L126\\\">尽可能地多应用区块</a></li>\\n</ol>\\n<h2>区块回滚</h2>\\n<p>您可以把回滚视为应用程序的对立面：当执行回滚时，应用程序所做的所有修改都将被取消，为此，我们使用 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/VAR.hs#L208\\\"><code>rollbackBlocks</code></a> 函数的功能。</p>\\n<p>get the tip？第一个区块将回滚。如果他们不匹配，则报告错误。如果他们匹配，我们实际上回滚区块的顺序为：</p>\\n<ul>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Internal.hs#L173\\\">回滚委派</a>，抹掉内存池中的认证。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Internal.hs#L174\\\">回滚 US</a></li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Internal.hs#L172\\\">回滚交易</a></li>\\n</ul>\\n<h2>区块头分类</h2>\\n<p>区块头部可以分为：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L51\\\">继续</a>。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L54\\\">可选</a>。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L59\\\">无效</a>。</li>\\n<li><a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L57\\\">无用</a>。</li>\\n</ol>\\n<p>如果<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L120\\\">验证成功</a>，则头部为<strong>继续</strong>：头部是主链的直接延续（即，其服务是我们的 tip）。</p>\\n<p>如果头部的父亲不是我们的 tip，<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L124\\\">它不太可能是我们的主链</a>，头部为<strong>可选</strong>。</p>\\n<p>如果<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L170\\\">头部链中有任何错误</a>，或者<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L172\\\">没有对应链中最老元素（应该是检查点之一）</a>的父亲的块，那么头部被视为<strong>无效</strong>。</p>\\n<p>如果在不同的条件下（例如，头部的 slot <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L94\\\">小于或等于我们 tip 的 slot</a>，或者<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/11fdc35884368ba61ec32e3277c037e20dc1c266/src/Pos/Block/Logic/Header.hs#L129\\\">头部与主链不连续，复杂度更大</a>），头部为<strong>无用</strong>。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/blocks/\",\"doc_title\":\"卡尔达诺结算层区块\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-02-15-pvss.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层中 PVSS 的实现 卡尔达诺结算层使用公开验证密钥共享模式，它基于『SCRAPE：可扩展的随机性公共实体证明』这篇由 Ignacio Cascudo 和 Bernardo David 写的 论文 。接下来我们将引用论文中的页，比如  [6]  表示第…\",\"html\":\"<!-- Reviewed at 18852484704ff4a7ce3fcac2791499c340eb8e02 -->\\n<h1>卡尔达诺结算层中 PVSS 的实现</h1>\\n<p>卡尔达诺结算层使用公开验证密钥共享模式，它基于『SCRAPE：可扩展的随机性公共实体证明』这篇由 Ignacio Cascudo 和 Bernardo David 写的<a href=\\\"https://eprint.iacr.org/2017/216.pdf\\\">论文</a>。接下来我们将引用论文中的页，比如 <code>[6]</code> 表示第6页。</p>\\n<p>本指南介绍了<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/65e295599817ec1f52f225810264d856f882fbb7/core/Pos/Crypto/SecretSharing.hs#L1\\\">卡尔达诺结算层</a>中 <code>pvss-haskell</code> <a href=\\\"https://github.com/input-output-hk/pvss-haskell\\\">库</a>的实现细节。</p>\\n<h2>什么是 PVSS</h2>\\n<p>VSS 模式的核心思想是参与者验证自己的份额，成功构建密钥（之前由参与者中的经销商分发（TODO））的能力。而 PVSS 模式的核心思想是，参与者不仅可以验证其股权，而且任何人都可以验证参与者是否收到了正确的股权。因此（参考我们的重建协议），参与者不仅要发行他们的股权，还要为每个发行的股票提供一个正确地证明(<code>[9]</code>)。（TODO）</p>\\n<p>我们使用 <code>t-out-of-n</code> 重建方案(<code>[8]</code>)，其中 <code>n</code> 是参与者的数量，<code>t</code> 是一个阈值。所以任何 <code>t+1</code> 份额的子集可以用来成功恢复密钥。</p>\\n<p>所以，协议有四个基本阶段(<code>[8]</code>)组成：</p>\\n<ol>\\n<li>建立，</li>\\n<li>分配，</li>\\n<li>验证，</li>\\n<li>重建。</li>\\n</ol>\\n<h2>建立</h2>\\n<p>每个参与者 <code>Pi</code> 必须生成器私钥 <code>SKi</code> 并注册其公钥 <code>PKi</code>。</p>\\n<h2>分配</h2>\\n<p>首先，我们准备一个新的托管环境。要做到这一点，我们需要上面提到的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L76\\\">阈值</a>和参与者的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L175\\\">公钥清单</a>。该操作的结果是 <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L120\\\"><code>Escrow</code></a>，它包括：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L85\\\">额外的生成器</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/Polynomial.hs#L24\\\">多项式</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L89\\\">密钥</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L39\\\">证明</a>。</li>\\n</ol>\\n<p>额外的生成器基于一个<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L92\\\">点</a>（<a href=\\\"http://hackage.haskell.org/package/cryptonite-openssl-0.6/docs/Crypto-OpenSSL-ECC.html#t:EcPoint\\\">椭圆曲线点</a>）。我们使用 <code>prime256v1</code> 椭圆曲线，参见 <a href=\\\"https://www.ietf.org/rfc/rfc5480.txt\\\">RFC</a>。</p>\\n<p>多项式是一组从 smallest degree 开始的一组系数（这些系统是<a href=\\\"http://hackage.haskell.org/package/cryptonite-0.23/docs/Crypto-PubKey-ECC-P256.html#t:Scalar\\\">标</a>值）。</p>\\n<p>密钥也基于一个<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L92\\\">点</a>，实际上它是上面提到的多项式的第一个<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L140\\\">元素</a>。</p>\\n<p>证明从<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L142\\\">挑战</a>，<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L140\\\">原始密钥</a>，<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L143\\\">DEEQ-参数生成</a>中<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L62\\\">生成</a>。</p>\\n<p>挑战是基于<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L125\\\">加密哈希</a>。</p>\\n<p>之后，我们必须<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L168\\\">完成托管创建</a>。参与者的公共密钥列表被用于<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L202\\\">创建加密股份</a>和<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L202\\\">承诺</a>。加密的股份包括：</p>\\n<ol>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L82\\\">分享 ID</a>，</li>\\n<li>通过参与者公钥加密的 <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L99\\\">Value</a>，</li>\\n<li><a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L99\\\">证明</a>这个股份是有效的 (<code>[8]</code>)。</li>\\n</ol>\\n<h2>验证</h2>\\n<p>现在可以在参与者之间发布承诺和加密的股份。由于 PVSS 模式的公共性质，任何知道公共密钥的人都可以通过散列匹配来<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L249\\\">验证加密的股份</a>。</p>\\n<h2>重建</h2>\\n<p>首先，参与者必须使用<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L84\\\">公钥</a>，<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L80\\\">私钥</a>密钥对<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L230\\\">解密加密的股份</a>。为了获得 DLEQ 的值，我们使用 <code>prime256v1</code> <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L156\\\">曲线生成器</a>。结果，我们得到 <a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L109\\\"><code>DecryptedShare</code></a>，其结构与加密股份相同。</p>\\n<p>由于解密的股份包含一个证明，所以我们可以确定解密的股份和加密的股份是一样的，并且有<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L260\\\">验证功能</a>。要<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L74\\\">做到这一点</a>，我们使用 DLEQ 值和来自<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L263\\\">解密股份的证明</a>。实际的验证是 DLEQ 点的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L146\\\">散列</a>的<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L77\\\">比较</a>。</p>\\n<p>现在，如果我们有 <code>t+1</code> 解密股份，我们可以<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L285\\\">恢复一个密钥</a>。</p>\\n<p>恢复的密钥也可以被<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L267\\\">验证</a>。所以我们可以确定恢复的密钥是相同的托管。要做到这一点，我们不仅需要一个证明和一个密钥，还需要<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L268\\\">承诺</a>（实际上是<a href=\\\"https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L278\\\">第一个</a>）。</p>\\n<h2>VSS 证书</h2>\\n<p>正如<a href=\\\"/cardano/differences/#coin-tossing-and-verifiable-secret-sharing\\\">前面所说的</a>，同时使用 PVSS 方案的挑战之一是相关联的用于与签名的公钥用于 VSS 方案。这是通过引入 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f0de5f1dd31cc4afb0c67a24deca713cf6304814/core/Pos/Core/Vss/Types.hs#L46\\\">VSS 证书</a>来解决的。</p>\\n<p>VSS 证书包括：</p>\\n<ol>\\n<li>用于 VSS 方案的公钥（例如 <a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/fefc39f058f5a053fc1e59bc3594bdadf7699ca0/core/Pos/Crypto/SecretSharing.hs#L57\\\">VSS 密钥</a>)。</li>\\n<li>用于签名的公钥（<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/f0de5f1dd31cc4afb0c67a24deca713cf6304814/core/Pos/Core/Vss/Types.hs#L51\\\">例如签名密钥</a>）。</li>\\n<li>过期 epoch 的索引（例如，在 epoch 的最后，证书是有效的）。</li>\\n<li>签名对 <code>(A,B)</code>，其中 <code>A</code> 是一个 VSS 键，<code>B</code> 是一个 epoch 索引。</li>\\n</ol>\\n<p>最初，拥有足够股份参与随机生成的所有权益相关者（我们成为<a href=\\\"/glossary/#richman\\\">富人</a>）<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Workers.hs#L163\\\">拥有自己的证书</a>。当出现一个拥有足够多股权的新利益相关者时，或者现有证书过期时，应该生成一个新的证书并<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Workers.hs#L166\\\">提交给网络</a>。其他节点接受此证书，如果该证书有效并且该节点具有足够的股权。证书存储在区块中。</p>\\n<p>请注意 VSS 证书在使用前必须是稳定的。如果我们检索证书的 epoch 是第一个（即有索引 <code>0</code>)，稳定的证书是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Functions.hs#L139\\\">起始证书</a>，否则，稳定的证书是<a href=\\\"https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Functions.hs#L141\\\">最后一个已知 slot 的未到期证书</a>。</p>\",\"frontmatter\":{\"path\":\"/cn/technical/pvss/\",\"doc_title\":\"卡尔达诺结算层 PVSS\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}},{\"node\":{\"id\":\"/Users/robinclark/iohk-sites/cardanodocs.com/src/pages/cn/docs/technical/2017-01-01-cli-options.cn.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"卡尔达诺结算层命令行选项 这份文档描述了卡尔达诺结算层的所有可执行文件以及所有相应的命令行参数。 cardano-node cardano-keygen cardano-explorer-swagger cardano-node-simple cardano-launcher…\",\"html\":\"<!-- THIS IS AUTOGENERATED CHAPTER. DO NOT CHANGE IT MANUALLY! -->\\n<h2>卡尔达诺结算层命令行选项</h2>\\n<p>这份文档描述了卡尔达诺结算层的所有可执行文件以及所有相应的命令行参数。</p>\\n<h2>cardano-node</h2>\\n<pre><code>Cardano SL node.\\n\\nUsage: cardano-node [--version] [--db-path FILEPATH] [--rebuild-db]\\n                    [--genesis-secret INT] [--keyfile FILEPATH]\\n                    [--backup-phrase PHRASE] [--topology FILEPATH]\\n                    [--kademlia FILEPATH] [--node-id NODE_ID]\\n                    [--default-port PORT] [--policies FILEPATH]\\n                    [--address IP:PORT] [--listen IP:PORT] [--json-log FILEPATH]\\n                    [--log-config FILEPATH] [--logs-prefix FILEPATH]\\n                    [--report-server URI] [--update-server URI]\\n                    [--configuration-file FILEPATH] [--configuration-key TEXT]\\n                    [--system-start TIMESTAMP] [--configuration-seed INTEGER]\\n                    [--update-latest-path FILEPATH] [--update-with-package]\\n                    [--no-ntp] [--route53-health-check IP:PORT] [--metrics]\\n                    [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                    [--statsd-interval MILLISECONDS] [--statsd-debug BOOL]\\n                    [--statsd-prefix TEXT] [--statsd-suffix TEXT]\\n                    [--dump-genesis-data-to ARG] [--web] [--web-port PORT]\\n                    [--tlscert FILEPATH] [--tlskey FILEPATH] [--tlsca FILEPATH]\\n                    [--wallet-address IP:PORT] [--wallet-db-path ARG]\\n                    [--wallet-rebuild-db]\\n                    [--wallet-acid-cleanup-interval MINUTES] [--wallet-debug]\\n                    [--flush-wallet-db]\\n  Cardano SL main server node w/ wallet.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --web                    Activate web API (it’s not linked with a wallet web\\n                           API).\\n  --web-port PORT          Port for web API. (default: 8080)\\n  --tlscert FILEPATH       Path to file with TLS certificate\\n  --tlskey FILEPATH        Path to file with TLS key\\n  --tlsca FILEPATH         Path to file with TLS certificate authority\\n  --wallet-address IP:PORT IP and port for backend wallet\\n                           API. (default: (\\\"127.0.0.1\\\",8090))\\n  --wallet-db-path ARG     Path to the wallet's database.\\n  --wallet-rebuild-db      If wallet's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --wallet-acid-cleanup-interval MINUTES\\n                           Interval on which to execute wallet cleanup action\\n                           (create checkpoint and archive and cleanup archive\\n                           partially)\\n  --wallet-debug           Run wallet with debug params (e.g. include all the\\n                           genesis keys in the set of secret keys).\\n  --flush-wallet-db        Flushes all blockchain-recoverable data from DB\\n                           (everything excluding wallets/accounts/addresses,\\n                           metadata)\\n\\nCommand example:\\n\\n  stack exec -- cardano-node                                             \\\\\\n    --db-path node-db0                                                   \\\\\\n    --rebuild-db                                                         \\\\\\n    --keyfile secrets/secret-1.key                                       \\\\\\n    --kademlia-id a_P8zb6fNP7I2H54FtGuhqxaMDAwMDAwMDAwMDAwMDA=           \\\\\\n    --address 127.0.0.1:3000                                             \\\\\\n    --listen 127.0.0.1:3000                                              \\\\\\n    --kademlia-address 127.0.0.1:3000                                    \\\\\\n    --json-log=/tmp/logs/2017-05-22_181224/node0.json                    \\\\\\n    --logs-prefix /tmp/logs/2017-05-22_181224                            \\\\\\n    --log-config /tmp/logs/2017-05-22_181224/conf/node0.log.yaml         \\\\\\n    --kademlia-dump-path /tmp/logs/2017-05-22_181224/dump/kademlia0.dump \\\\\\n    --system-start 1495462345\\n</code></pre>\\n<h2>cardano-keygen</h2>\\n<pre><code>Tool to generate keyfiles-related data\\n\\nUsage: cardano-keygen [--version] COMMAND [--configuration-file FILEPATH]\\n                      [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                      [--configuration-seed INTEGER]\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n\\nAvailable commands:\\n  rearrange                Rearrange keyfiles.\\n  generate-key             Generate keyfile.\\n  generate-vss             Generate VSS certificate.\\n  read-key                 Dump keyfile contents.\\n  generate-avvm-seeds      Generate avvm seeds with public keys.\\n  generate-keys-by-spec    Generate secret keys and avvm seed by\\n                           genesis-spec.yaml\\n  dump-genesis-data        Dump genesis data (as per configuration) in json\\n                           format\\n</code></pre>\\n<h2>cardano-explorer-swagger</h2>\\n<pre><code>Cardano SL Explorer web API docs generator.\\n\\nUsage: cardano-explorer-swagger [--version]\\n  Generate Swagger specification for Explorer web API.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n\\nThis program runs during 'cardano-sl' building on Travis CI. Generated file\\n'explorer-web-api-swagger.json' will be used to produce HTML documentation. This\\ndocumentation will be published at cardanodocs.com using\\n'update-explorer-web-api-docs.sh'.\\n</code></pre>\\n<h2>cardano-node-simple</h2>\\n<pre><code>Cardano SL node.\\n\\nUsage: cardano-node-simple [--version] [--db-path FILEPATH] [--rebuild-db]\\n                           [--genesis-secret INT] [--keyfile FILEPATH]\\n                           [--backup-phrase PHRASE] [--topology FILEPATH]\\n                           [--kademlia FILEPATH] [--node-id NODE_ID]\\n                           [--default-port PORT] [--policies FILEPATH]\\n                           [--address IP:PORT] [--listen IP:PORT]\\n                           [--json-log FILEPATH] [--log-config FILEPATH]\\n                           [--logs-prefix FILEPATH] [--report-server URI]\\n                           [--update-server URI] [--configuration-file FILEPATH]\\n                           [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                           [--configuration-seed INTEGER]\\n                           [--update-latest-path FILEPATH]\\n                           [--update-with-package] [--no-ntp]\\n                           [--route53-health-check IP:PORT] [--metrics]\\n                           [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                           [--statsd-interval MILLISECONDS]\\n                           [--statsd-debug BOOL] [--statsd-prefix TEXT]\\n                           [--statsd-suffix TEXT] [--dump-genesis-data-to ARG]\\n                           [--behavior FILE]\\n  Cardano SL main server node.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --behavior FILE          Path to the behavior config\\n\\nCommand example:\\n\\n  stack exec -- cardano-node                                             \\\\\\n    --db-path node-db0                                                   \\\\\\n    --rebuild-db                                                         \\\\\\n    --keyfile secrets/secret-1.key                                       \\\\\\n    --kademlia-id a_P8zb6fNP7I2H54FtGuhqxaMDAwMDAwMDAwMDAwMDA=           \\\\\\n    --address 127.0.0.1:3000                                             \\\\\\n    --listen 127.0.0.1:3000                                              \\\\\\n    --kademlia-address 127.0.0.1:3000                                    \\\\\\n    --json-log=/tmp/logs/2017-05-22_181224/node0.json                    \\\\\\n    --logs-prefix /tmp/logs/2017-05-22_181224                            \\\\\\n    --log-config /tmp/logs/2017-05-22_181224/conf/node0.log.yaml         \\\\\\n    --kademlia-dump-path /tmp/logs/2017-05-22_181224/dump/kademlia0.dump \\\\\\n    --system-start 1495462345\\n</code></pre>\\n<h2>cardano-launcher</h2>\\n<pre><code>Tool to launch Cardano SL.\\n\\nUsage: cardano-launcher [--version] --node PATH [-n ARG]\\n                        [--node-log-config PATH] [--node-log-path PATH]\\n                        [--wallet PATH] [-w ARG] --updater PATH [-u ARG]\\n                        [--update-archive PATH] [--updater-windows-runner PATH]\\n                        --node-timeout SEC [--report-server URL]\\n                        [--configuration-file FILEPATH]\\n                        [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                        [--configuration-seed INTEGER]\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --node PATH              Path to the node executable.\\n  -n ARG                   An argument to be passed to the node.\\n  --node-log-config PATH   Path to log config that will be used by the node.\\n  --node-log-path PATH     File where node stdout/err will be redirected (def:\\n                           temp file).\\n  --wallet PATH            Path to the wallet executable.\\n  -w ARG                   An argument to be passed to the wallet.\\n  --updater PATH           Path to the updater executable.\\n  -u ARG                   An argument to be passed to the updater.\\n  --update-archive PATH    Path to the update archive, it will be passed to the\\n                           updater.\\n  --updater-windows-runner PATH\\n                           Path to write the Windows batch file executing\\n                           updater\\n  --node-timeout SEC       How much to wait for the node to exit before killing\\n                           it.\\n  --report-server URL      Where to send logs in case of failure.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n\\nCommand example:\\n\\n  stack exec -- cardano-launcher                                   \\\\\\n    --node binaries_v000/cardano-node                              \\\\\\n    --node-log-config scripts/log-templates/update-log-config.yaml \\\\\\n    -n \\\"--update-server\\\"                                           \\\\\\n    -n \\\"http://localhost:3001\\\"                                     \\\\\\n    -n \\\"--update-latest-path\\\"                                      \\\\\\n    -n \\\"updateDownloaded.tar\\\"                                      \\\\\\n    -n \\\"--listen\\\"                                                  \\\\\\n    -n \\\"127.0.0.1:3004\\\"                                            \\\\\\n    -n \\\"--kademlia-id\\\"                                             \\\\\\n    -n \\\"a_P8zb6fNP7I2H54FtGuhqxaMDAwMDAwMDAwMDAwMDA=\\\"              \\\\\\n    -n \\\"--flat-distr\\\"                                              \\\\\\n    -n \\\"(3,100000)\\\"                                                \\\\\\n    -n \\\"--rebuild-db\\\"                                              \\\\\\n    -n \\\"--wallet\\\"                                                  \\\\\\n    -n \\\"--web-port\\\"                                                \\\\\\n    -n 8080                                                        \\\\\\n    -n \\\"--wallet-rebuild-db\\\"                                       \\\\\\n    --updater cardano-updater                                      \\\\\\n    -u \\\"dir\\\"                                                       \\\\\\n    -u \\\"binaries_v000\\\"                                             \\\\\\n    --node-timeout 5                                               \\\\\\n    --update-archive updateDownloaded.tar\\n</code></pre>\\n<h2>cardano-block-gen</h2>\\n<pre><code>Cardano SL blockchain generator\\n\\nUsage: cardano-block-gen [--version] --blocks INT --nodes INT\\n                         [--generated-db FILEPATH] [--append] [--seed INT]\\n                         [--tx-count (INT,INT)] [--tx-max-outs INT]\\n  It generates database of node, corresponding to some correct blockchain\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --blocks INT             Length of blockchain.\\n  --nodes INT              Number of nodes.\\n  --generated-db FILEPATH  Location of generated database.\\n  --append                 If database already exists, append to it.\\n  --seed INT               Custom seed to generate blocks.\\n  --tx-count (INT,INT)     Tx count range.\\n  --tx-max-outs INT        Max number of outputs in tx\\n\\nCommand example:\\n\\n  stack exec -- cardano-block-gen           \\\\\\n    --blocks 5000                           \\\\\\n    --nodes 3                               \\\\\\n    --coins 100                             \\\\\\n    --generated-db /path/to/existed/db      \\\\\\n    --seed 123                              \\\\\\n    --append\\n</code></pre>\\n<h2>cardano-report-server</h2>\\n<pre><code>CardanoSL report server\\n\\nUsage: cardano-report-server [-p|--port INTEGER] [--logsdir FILEPATH]\\n                             [--severity SEVERITY] [--size-limit BYTES]\\n                             [--version]\\n  CardanoSL reporting server daemon\\n\\nAvailable options:\\n  -p,--port INTEGER        Port server is running on\\n  --logsdir FILEPATH       Directory server will be saving logs in\\n  --severity SEVERITY      Logging severity\\n  --size-limit BYTES       Maximum body size allowed (will send 413 responses if\\n                           bigger)\\n  -h,--help                Show this help text\\n  --version                Show version\\n</code></pre>\\n<h2>cardano-dht-keygen</h2>\\n<pre><code>Generator of random key for Kademlia DHT.\\n\\nUsage: cardano-dht-keygen [--version] (-n|--nonce STRING)\\n  Generated key will be print to stdout.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  -n,--nonce STRING        14-characters string.\\n</code></pre>\\n<h2>cardano-explorer-mock</h2>\\n<pre><code>Cardano SL Explorer web mock.\\n\\nUsage: cardano-explorer-mock [--version]\\n  Run mock for Explorer web API.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n\\nThis program returns just the mocked data. It doesn't call any CSL functions and\\ndoesn't interact with it. It just implements the API and returns simeple test\\ndata.\\n</code></pre>\\n<h2>cardano-addr-convert</h2>\\n<pre><code>Tool to convert vending addresses into testnet addresses.\\n\\nUsage: cardano-addr-convert [--version] [-a|--address STRING]\\n  Produce public key and write it in stdout.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  -a,--address STRING      Address to convert. It must be in base64(url) format.\\n\\nCommand example:\\n\\n  stack exec -- cardano-addr-convert -a 2HF83bvYCTzoCbVta6t64W8rFEnvnkJbIUFoT5tOyoU=\\n\\nOutput example:\\n\\n  3mhNKjfhaCT13DjcQ9eMK4VHfZrFxmyXq8SjVPRtz7SWfP\\n\\nYou can also run it without arguments to switch to interactive mode.\\nIn this case each entered vending address is echoed with a testnet address.\\n</code></pre>\\n<h2>cardano-blockchain-analyser</h2>\\n<pre><code>Cardano SL blockchain generator\\n\\nUsage: cardano-blockchain-analyser --db FILEPATH ([-k] | [-m] | [-g] | [-a] |\\n                                   [-b]) [--print-mode [human|csv|table]]\\n                                   [-i|--incremental] [--log-config FILEPATH]\\n                                   [--logs-prefix FILEPATH]\\n                                   [--report-server URI] [--update-server URI]\\n                                   [--configuration-file FILEPATH]\\n                                   [--configuration-key TEXT]\\n                                   [--system-start TIMESTAMP]\\n                                   [--configuration-seed INTEGER]\\n  Analyse a blockchain and spit out useful metrics.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --db FILEPATH            Location of the database where the blockchain is\\n                           stored.\\n  -k                       Display block counts in kilobytes (KB).\\n  -m                       Display block counts in megabytes (MB).\\n  -g                       Display block counts in gigabytes (GB).\\n  -a                       Display block counts using an adaptive multiplier.\\n  -b                       Display block counts in bytes (B).\\n  --print-mode [human|csv|table]\\n                           Select the desidered rendering mode, one between\\n                           'human', 'csv' or 'table'.\\n  -i,--incremental         Run in incremental mode. In this mode, table output\\n                           will be disabled and rendered as a .csv, as is not\\n                           possible to generate nice-looking tables whilst\\n                           reading the blockchain one block at time. You almost\\n                           always want to be using this mode for huge\\n                           blockchains, as it's much more memory efficient.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n\\nCommand example:\\n\\n  cardano-blockchain-analyser --db /path/to/existing/db\\n</code></pre>\\n<h2>cardano-auxx</h2>\\n<pre><code>CLI-based utilities (auxx).\\n\\nUsage: cardano-auxx [--version] COMMAND [--db-path FILEPATH] [--rebuild-db]\\n                    [--genesis-secret INT] [--keyfile FILEPATH]\\n                    [--backup-phrase PHRASE] [--topology FILEPATH]\\n                    [--kademlia FILEPATH] [--node-id NODE_ID]\\n                    [--default-port PORT] [--policies FILEPATH]\\n                    [--address IP:PORT] [--listen IP:PORT] [--json-log FILEPATH]\\n                    [--log-config FILEPATH] [--logs-prefix FILEPATH]\\n                    [--report-server URI] [--update-server URI]\\n                    [--configuration-file FILEPATH] [--configuration-key TEXT]\\n                    [--system-start TIMESTAMP] [--configuration-seed INTEGER]\\n                    [--update-latest-path FILEPATH] [--update-with-package]\\n                    [--no-ntp] [--route53-health-check IP:PORT] [--metrics]\\n                    [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                    [--statsd-interval MILLISECONDS] [--statsd-debug BOOL]\\n                    [--statsd-prefix TEXT] [--statsd-suffix TEXT]\\n                    [--dump-genesis-data-to ARG] [--peer HOST:PORT]\\n                    [--node-enabled]\\n  Cardano SL CLI utilities.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --peer HOST:PORT         Address of a peer.\\n  --node-enabled           Run auxx as a plugin for the node, as opposed to\\n                           running it standalone (default: standalone).\\n\\nAvailable commands:\\n  repl                     Run REPL in console to evaluate the commands.\\n  cmd                      Execute a list of predefined commands.\\n\\nCommand example:\\n\\n  stack exec -- cardano-auxx                                     \\\\\\n    --db-path run/auxx-db                                        \\\\\\n    --rebuild-db                                                 \\\\\\n    --json-log=/tmp/logs/2017-05-22_181224/node0.json            \\\\\\n    --logs-prefix /tmp/logs/2017-05-22_181224                    \\\\\\n    --log-config /tmp/logs/2017-05-22_181224/conf/node0.log.yaml \\\\\\n    --system-start 1495462345                                    \\\\\\n    --peer 127.0.0.1:3001                                        \\\\\\n    repl\\n</code></pre>\\n<h2>cardano-cli-docs</h2>\\n<pre><code>Tool to generate CLI-docs for Cardano SL executable files.\\n\\nUsage: cardano-cli-docs [--version] --bin-dir PATH\\n  Generate Markdown chapter for cardanodocs.com.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --bin-dir PATH           Path to the directory with Cardano SL executable\\n                           files.\\n\\nAssumed that this program will run on Travis CI. Produced file\\n'cardano-cli-docs.md' will be renamed in a chapter and pushed in cardanodocs.com\\nrepository.\\n</code></pre>\\n<h2>cardano-genupdate</h2>\\n<pre><code>Cardano SL updates generator.\\n\\nUsage: cardano-genupdate [--version] --old PATH --new PATH (-o|--output PATH)\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --old PATH               Path to directory with old program.\\n  --new PATH               Path to directory with new program.\\n  -o,--output PATH         Path to output .tar-file with diff.\\n\\nCommand example:\\n\\n  stack exec -- cardano-genupdate --old /tmp/app-v000 --new /tmp/app-v001 -o /tmp/app-update.tar\\n\\nBoth directories must have equal file structure (e.g. they must contain the same\\nfiles in the same subdirectories correspondingly), otherwise 'cardano-genupdate' will fail.\\n\\nPlease note that 'cardano-genupdate' uses 'bsdiff' program, so make sure 'bsdiff' is available in the PATH.\\n</code></pre>\\n<h2>cardano-explorer</h2>\\n<pre><code>Cardano SL explorer.\\n\\nUsage: cardano-explorer [--version] [--db-path FILEPATH] [--rebuild-db]\\n                        [--genesis-secret INT] [--keyfile FILEPATH]\\n                        [--backup-phrase PHRASE] [--topology FILEPATH]\\n                        [--kademlia FILEPATH] [--node-id NODE_ID]\\n                        [--default-port PORT] [--policies FILEPATH]\\n                        [--address IP:PORT] [--listen IP:PORT]\\n                        [--json-log FILEPATH] [--log-config FILEPATH]\\n                        [--logs-prefix FILEPATH] [--report-server URI]\\n                        [--update-server URI] [--configuration-file FILEPATH]\\n                        [--configuration-key TEXT] [--system-start TIMESTAMP]\\n                        [--configuration-seed INTEGER]\\n                        [--update-latest-path FILEPATH] [--update-with-package]\\n                        [--no-ntp] [--route53-health-check IP:PORT] [--metrics]\\n                        [--ekg-server IP:PORT] [--statsd-server IP:PORT]\\n                        [--statsd-interval MILLISECONDS] [--statsd-debug BOOL]\\n                        [--statsd-prefix TEXT] [--statsd-suffix TEXT]\\n                        [--dump-genesis-data-to ARG] [--web-port PORT]\\n                        [--notifier-port PORT]\\n  Cardano SL main server node w/ explorer.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n  --db-path FILEPATH       Path to directory with all DBs used by the node. If\\n                           specified path doesn’t exist, a directory will be\\n                           created.\\n  --rebuild-db             If node's database already exists, discard its\\n                           contents and create a new one from scratch.\\n  --genesis-secret INT     Used genesis secret key index.\\n  --keyfile FILEPATH       Path to file with secret key (we use it for\\n                           Daedalus).\\n  --backup-phrase PHRASE   12-word phrase to recover the wallet. Words should be\\n                           separated by spaces.\\n  --topology FILEPATH      Path to a YAML file containing the network topology\\n  --kademlia FILEPATH      Path to a YAML file containing the kademlia\\n                           configuration\\n  --node-id NODE_ID        Identifier for this node within the network\\n  --default-port PORT      Port number for IP address to node ID translation\\n  --policies FILEPATH      Path to a YAML file containing the network policies\\n  --address IP:PORT        IP and port of external address. Please make sure\\n                           these IP and port (on which node is running) are\\n                           accessible otherwise proper work of CSL isn't\\n                           guaranteed. 0.0.0.0 is not accepted as a valid host.\\n  --listen IP:PORT         IP and port on which to bind and listen. Please make\\n                           sure these IP and port are accessible, otherwise\\n                           proper work of CSL isn't guaranteed.\\n  --json-log FILEPATH      Path to JSON log file.\\n  --log-config FILEPATH    Path to logger configuration.\\n  --logs-prefix FILEPATH   Prefix to logger output path.\\n  --report-server URI      Reporting server to send crash/error logs on.\\n  --update-server URI      Server to download updates from.\\n  --configuration-file FILEPATH\\n                           Path to a yaml configuration file\\n  --configuration-key TEXT Key within the configuration file to use\\n  --system-start TIMESTAMP System start time. Format - seconds since Unix Epoch.\\n  --configuration-seed INTEGER\\n                           Seed for genesis generation. Overrides one from\\n                           configuration file.\\n  --update-latest-path FILEPATH\\n                           Path to update installer file, which should be\\n                           downloaded by Update System.\\n  --update-with-package    Enable updating via installer.\\n  --no-ntp                 Whether to use real NTP servers to synchronise time\\n                           or rely on local time\\n  --route53-health-check IP:PORT\\n                           Host and port for the Route53 DNS health check.\\n  --metrics                Enable metrics (EKG, statsd)\\n  --ekg-server IP:PORT     Host and port for the EKG server\\n  --statsd-server IP:PORT  Host and port for the statsd server\\n  --statsd-interval MILLISECONDS\\n                           Polling interval for statsd (milliseconds)\\n  --statsd-debug BOOL      Enable statsd debug mode\\n  --statsd-prefix TEXT     Prefix for statsd\\n  --statsd-suffix TEXT     Suffix for statsd\\n  --dump-genesis-data-to ARG\\n                           Dump genesis data in canonical JSON format to this\\n                           file.\\n  --web-port PORT          Port for web API. (default: 8100)\\n  --notifier-port PORT     Port for update notifier, the socket.io\\n                           backend. (default: 8110)\\n</code></pre>\\n<h2>cardano-swagger</h2>\\n<pre><code>Cardano SL Wallet web API docs generator.\\n\\nUsage: cardano-swagger [--version]\\n  Generate Swagger specification for Wallet web API.\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n  --version                Show version.\\n\\nThis program runs during 'cardano-sl' building on Travis CI. Generated file\\n'wallet-web-api-swagger.json' will be used to produce HTML documentation. This\\ndocumentation will be published at cardanodocs.com using\\n'update_wallet_web_api_docs.sh'.\\n</code></pre>\\n<h2>cardano-post-mortem</h2>\\n<pre><code>cardano-post-mortem\\n\\nUsage: cardano-post-mortem COMMAND\\n  analyzes the json logs from several directories or focusses on a single\\n  transaction\\n\\nAvailable options:\\n  -h,--help                Show this help text\\n\\nAvailable commands:\\n  overview                 analyzes the json logs from LOGDIRS...\\n  focus                    analyzes transaction FOCUS in log folder LOGDIR\\n  txrelay                  analyzes transaction relays in the json logs from\\n                           LOGDIRS...\\n  throughput               analyzes transaction throughput and waiting time per\\n                           time windows TXWINDOW and WAITWINDOW in the json logs\\n                           from LOGDIRS...\\n</code></pre>\",\"frontmatter\":{\"path\":\"/cn/technical/cli-options/\",\"doc_title\":\"卡尔达诺结算层命令行选项\",\"author\":null,\"date\":\"2017-01-01\",\"language\":\"cn\",\"label\":\"docs\",\"keywords\":null,\"group\":\"technical\"}}}]}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/cn.json\n// module id = 493\n// module chunks = 29311135075861"],"sourceRoot":""}